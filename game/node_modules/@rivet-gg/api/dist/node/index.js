"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __esm = (fn, res) => function __init() {
  return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
};
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/core/schemas/Schema.ts
var SchemaType;
var init_Schema = __esm({
  "src/core/schemas/Schema.ts"() {
    "use strict";
    SchemaType = {
      DATE: "date",
      ENUM: "enum",
      LIST: "list",
      STRING_LITERAL: "stringLiteral",
      OBJECT: "object",
      ANY: "any",
      BOOLEAN: "boolean",
      NUMBER: "number",
      STRING: "string",
      UNKNOWN: "unknown",
      RECORD: "record",
      SET: "set",
      UNION: "union",
      UNDISCRIMINATED_UNION: "undiscriminatedUnion",
      OPTIONAL: "optional"
    };
  }
});

// src/core/schemas/builders/schema-utils/stringifyValidationErrors.ts
function stringifyValidationError(error) {
  if (error.path.length === 0) {
    return error.message;
  }
  return `${error.path.join(" -> ")}: ${error.message}`;
}
var init_stringifyValidationErrors = __esm({
  "src/core/schemas/builders/schema-utils/stringifyValidationErrors.ts"() {
    "use strict";
  }
});

// src/core/schemas/builders/schema-utils/JsonError.ts
var JsonError;
var init_JsonError = __esm({
  "src/core/schemas/builders/schema-utils/JsonError.ts"() {
    "use strict";
    init_stringifyValidationErrors();
    JsonError = class extends Error {
      constructor(errors) {
        super(errors.map(stringifyValidationError).join("; "));
        this.errors = errors;
        Object.setPrototypeOf(this, JsonError.prototype);
      }
    };
  }
});

// src/core/schemas/builders/schema-utils/ParseError.ts
var ParseError;
var init_ParseError = __esm({
  "src/core/schemas/builders/schema-utils/ParseError.ts"() {
    "use strict";
    init_stringifyValidationErrors();
    ParseError = class extends Error {
      constructor(errors) {
        super(errors.map(stringifyValidationError).join("; "));
        this.errors = errors;
        Object.setPrototypeOf(this, ParseError.prototype);
      }
    };
  }
});

// src/core/schemas/builders/schema-utils/getSchemaUtils.ts
function getSchemaUtils(schema) {
  return {
    optional: () => optional(schema),
    transform: (transformer) => transform(schema, transformer),
    parseOrThrow: async (raw, opts) => {
      const parsed = await schema.parse(raw, opts);
      if (parsed.ok) {
        return parsed.value;
      }
      throw new ParseError(parsed.errors);
    },
    jsonOrThrow: async (parsed, opts) => {
      const raw = await schema.json(parsed, opts);
      if (raw.ok) {
        return raw.value;
      }
      throw new JsonError(raw.errors);
    }
  };
}
function optional(schema) {
  const baseSchema = {
    parse: (raw, opts) => {
      if (raw == null) {
        return {
          ok: true,
          value: void 0
        };
      }
      return schema.parse(raw, opts);
    },
    json: (parsed, opts) => {
      if (parsed == null) {
        return {
          ok: true,
          value: null
        };
      }
      return schema.json(parsed, opts);
    },
    getType: () => SchemaType.OPTIONAL
  };
  return {
    ...baseSchema,
    ...getSchemaUtils(baseSchema)
  };
}
function transform(schema, transformer) {
  const baseSchema = {
    parse: async (raw, opts) => {
      const parsed = await schema.parse(raw, opts);
      if (!parsed.ok) {
        return parsed;
      }
      return {
        ok: true,
        value: transformer.transform(parsed.value)
      };
    },
    json: async (transformed, opts) => {
      const parsed = await transformer.untransform(transformed);
      return schema.json(parsed, opts);
    },
    getType: () => schema.getType()
  };
  return {
    ...baseSchema,
    ...getSchemaUtils(baseSchema)
  };
}
var init_getSchemaUtils = __esm({
  "src/core/schemas/builders/schema-utils/getSchemaUtils.ts"() {
    "use strict";
    init_Schema();
    init_JsonError();
    init_ParseError();
  }
});

// src/core/schemas/builders/schema-utils/index.ts
var init_schema_utils = __esm({
  "src/core/schemas/builders/schema-utils/index.ts"() {
    "use strict";
    init_getSchemaUtils();
    init_JsonError();
    init_ParseError();
  }
});

// src/core/schemas/builders/date/date.ts
function date() {
  const baseSchema = {
    parse: (raw) => {
      if (typeof raw === "string" && ISO_8601_REGEX.test(raw)) {
        return {
          ok: true,
          value: new Date(raw)
        };
      } else {
        return {
          ok: false,
          errors: [
            {
              path: [],
              message: "Not an ISO 8601 date string"
            }
          ]
        };
      }
    },
    json: (date2) => {
      if (date2 instanceof Date) {
        return {
          ok: true,
          value: date2.toISOString()
        };
      } else {
        return {
          ok: false,
          errors: [
            {
              path: [],
              message: "Not a Date object"
            }
          ]
        };
      }
    },
    getType: () => SchemaType.DATE
  };
  return {
    ...baseSchema,
    ...getSchemaUtils(baseSchema)
  };
}
var ISO_8601_REGEX;
var init_date = __esm({
  "src/core/schemas/builders/date/date.ts"() {
    "use strict";
    init_Schema();
    init_schema_utils();
    ISO_8601_REGEX = /^([+-]?\d{4}(?!\d{2}\b))((-?)((0[1-9]|1[0-2])(\3([12]\d|0[1-9]|3[01]))?|W([0-4]\d|5[0-2])(-?[1-7])?|(00[1-9]|0[1-9]\d|[12]\d{2}|3([0-5]\d|6[1-6])))([T\s]((([01]\d|2[0-3])((:?)[0-5]\d)?|24:?00)([.,]\d+(?!:))?)?(\17[0-5]\d([.,]\d+)?)?([zZ]|([+-])([01]\d|2[0-3]):?([0-5]\d)?)?)?)?$/;
  }
});

// src/core/schemas/builders/date/index.ts
var init_date2 = __esm({
  "src/core/schemas/builders/date/index.ts"() {
    "use strict";
    init_date();
  }
});

// src/core/schemas/utils/createIdentitySchemaCreator.ts
function createIdentitySchemaCreator(schemaType, validate) {
  return () => {
    const baseSchema = {
      parse: validate,
      json: validate,
      getType: () => schemaType
    };
    return {
      ...baseSchema,
      ...getSchemaUtils(baseSchema)
    };
  };
}
var init_createIdentitySchemaCreator = __esm({
  "src/core/schemas/utils/createIdentitySchemaCreator.ts"() {
    "use strict";
    init_schema_utils();
  }
});

// src/core/schemas/builders/enum/enum.ts
function enum_(values) {
  const validValues = new Set(values);
  const schemaCreator = createIdentitySchemaCreator(
    SchemaType.ENUM,
    (value, { allowUnrecognizedEnumValues } = {}) => {
      if (typeof value === "string" && (validValues.has(value) || allowUnrecognizedEnumValues)) {
        return {
          ok: true,
          value
        };
      } else {
        return {
          ok: false,
          errors: [
            {
              path: [],
              message: "Not one of the allowed values"
            }
          ]
        };
      }
    }
  );
  return schemaCreator();
}
var init_enum = __esm({
  "src/core/schemas/builders/enum/enum.ts"() {
    "use strict";
    init_Schema();
    init_createIdentitySchemaCreator();
  }
});

// src/core/schemas/builders/enum/index.ts
var init_enum2 = __esm({
  "src/core/schemas/builders/enum/index.ts"() {
    "use strict";
    init_enum();
  }
});

// src/core/schemas/builders/lazy/lazy.ts
function lazy(getter) {
  const baseSchema = constructLazyBaseSchema(getter);
  return {
    ...baseSchema,
    ...getSchemaUtils(baseSchema)
  };
}
function constructLazyBaseSchema(getter) {
  return {
    parse: async (raw, opts) => (await getMemoizedSchema(getter)).parse(raw, opts),
    json: async (parsed, opts) => (await getMemoizedSchema(getter)).json(parsed, opts),
    getType: async () => (await getMemoizedSchema(getter)).getType()
  };
}
async function getMemoizedSchema(getter) {
  const castedGetter = getter;
  if (castedGetter.__zurg_memoized == null) {
    castedGetter.__zurg_memoized = await getter();
  }
  return castedGetter.__zurg_memoized;
}
var init_lazy = __esm({
  "src/core/schemas/builders/lazy/lazy.ts"() {
    "use strict";
    init_schema_utils();
  }
});

// src/core/schemas/utils/entries.ts
function entries(object2) {
  return Object.entries(object2);
}
var init_entries = __esm({
  "src/core/schemas/utils/entries.ts"() {
    "use strict";
  }
});

// src/core/schemas/utils/filterObject.ts
function filterObject(obj, keysToInclude) {
  const keysToIncludeSet = new Set(keysToInclude);
  return Object.entries(obj).reduce((acc, [key, value]) => {
    if (keysToIncludeSet.has(key)) {
      acc[key] = value;
    }
    return acc;
  }, {});
}
var init_filterObject = __esm({
  "src/core/schemas/utils/filterObject.ts"() {
    "use strict";
  }
});

// src/core/schemas/utils/isPlainObject.ts
function isPlainObject(value) {
  if (typeof value !== "object" || value === null) {
    return false;
  }
  if (Object.getPrototypeOf(value) === null) {
    return true;
  }
  let proto = value;
  while (Object.getPrototypeOf(proto) !== null) {
    proto = Object.getPrototypeOf(proto);
  }
  return Object.getPrototypeOf(value) === proto;
}
var NOT_AN_OBJECT_ERROR_MESSAGE;
var init_isPlainObject = __esm({
  "src/core/schemas/utils/isPlainObject.ts"() {
    "use strict";
    NOT_AN_OBJECT_ERROR_MESSAGE = "Not an object";
  }
});

// src/core/schemas/utils/keys.ts
function keys(object2) {
  return Object.keys(object2);
}
var init_keys = __esm({
  "src/core/schemas/utils/keys.ts"() {
    "use strict";
  }
});

// src/core/schemas/utils/partition.ts
function partition(items, predicate) {
  const trueItems = [], falseItems = [];
  for (const item of items) {
    if (predicate(item)) {
      trueItems.push(item);
    } else {
      falseItems.push(item);
    }
  }
  return [trueItems, falseItems];
}
var init_partition = __esm({
  "src/core/schemas/utils/partition.ts"() {
    "use strict";
  }
});

// src/core/schemas/builders/object-like/getObjectLikeUtils.ts
function getObjectLikeUtils(schema) {
  return {
    withParsedProperties: (properties) => withParsedProperties(schema, properties)
  };
}
function withParsedProperties(objectLike, properties) {
  const objectSchema = {
    parse: async (raw, opts) => {
      const parsedObject = await objectLike.parse(raw, opts);
      if (!parsedObject.ok) {
        return parsedObject;
      }
      const additionalProperties = Object.entries(properties).reduce(
        (processed, [key, value]) => {
          return {
            ...processed,
            [key]: typeof value === "function" ? value(parsedObject.value) : value
          };
        },
        {}
      );
      return {
        ok: true,
        value: {
          ...parsedObject.value,
          ...additionalProperties
        }
      };
    },
    json: (parsed, opts) => {
      if (!isPlainObject(parsed)) {
        return {
          ok: false,
          errors: [
            {
              path: [],
              message: NOT_AN_OBJECT_ERROR_MESSAGE
            }
          ]
        };
      }
      const addedPropertyKeys = new Set(Object.keys(properties));
      const parsedWithoutAddedProperties = filterObject(
        parsed,
        Object.keys(parsed).filter((key) => !addedPropertyKeys.has(key))
      );
      return objectLike.json(parsedWithoutAddedProperties, opts);
    },
    getType: () => objectLike.getType()
  };
  return {
    ...objectSchema,
    ...getSchemaUtils(objectSchema),
    ...getObjectLikeUtils(objectSchema)
  };
}
var init_getObjectLikeUtils = __esm({
  "src/core/schemas/builders/object-like/getObjectLikeUtils.ts"() {
    "use strict";
    init_filterObject();
    init_isPlainObject();
    init_schema_utils();
  }
});

// src/core/schemas/builders/object-like/index.ts
var init_object_like = __esm({
  "src/core/schemas/builders/object-like/index.ts"() {
    "use strict";
    init_getObjectLikeUtils();
  }
});

// src/core/schemas/builders/object/property.ts
function property(rawKey, valueSchema) {
  return {
    rawKey,
    valueSchema,
    isProperty: true
  };
}
function isProperty(maybeProperty) {
  return maybeProperty.isProperty;
}
var init_property = __esm({
  "src/core/schemas/builders/object/property.ts"() {
    "use strict";
  }
});

// src/core/schemas/builders/object/object.ts
function object(schemas) {
  const baseSchema = {
    _getRawProperties: () => Promise.resolve(
      Object.entries(schemas).map(
        ([parsedKey, propertySchema]) => isProperty(propertySchema) ? propertySchema.rawKey : parsedKey
      )
    ),
    _getParsedProperties: () => Promise.resolve(keys(schemas)),
    parse: async (raw, opts) => {
      const rawKeyToProperty = {};
      const requiredKeys = [];
      for (const [parsedKey, schemaOrObjectProperty] of entries(schemas)) {
        const rawKey = isProperty(schemaOrObjectProperty) ? schemaOrObjectProperty.rawKey : parsedKey;
        const valueSchema = isProperty(schemaOrObjectProperty) ? schemaOrObjectProperty.valueSchema : schemaOrObjectProperty;
        const property2 = {
          rawKey,
          parsedKey,
          valueSchema
        };
        rawKeyToProperty[rawKey] = property2;
        if (await isSchemaRequired(valueSchema)) {
          requiredKeys.push(rawKey);
        }
      }
      return validateAndTransformObject({
        value: raw,
        requiredKeys,
        getProperty: (rawKey) => {
          const property2 = rawKeyToProperty[rawKey];
          if (property2 == null) {
            return void 0;
          }
          return {
            transformedKey: property2.parsedKey,
            transform: (propertyValue) => property2.valueSchema.parse(propertyValue, opts)
          };
        },
        unrecognizedObjectKeys: opts == null ? void 0 : opts.unrecognizedObjectKeys
      });
    },
    json: async (parsed, opts) => {
      const requiredKeys = [];
      for (const [parsedKey, schemaOrObjectProperty] of entries(schemas)) {
        const valueSchema = isProperty(schemaOrObjectProperty) ? schemaOrObjectProperty.valueSchema : schemaOrObjectProperty;
        if (await isSchemaRequired(valueSchema)) {
          requiredKeys.push(parsedKey);
        }
      }
      return validateAndTransformObject({
        value: parsed,
        requiredKeys,
        getProperty: (parsedKey) => {
          const property2 = schemas[parsedKey];
          if (property2 == null) {
            return void 0;
          }
          if (isProperty(property2)) {
            return {
              transformedKey: property2.rawKey,
              transform: (propertyValue) => property2.valueSchema.json(propertyValue, opts)
            };
          } else {
            return {
              transformedKey: parsedKey,
              transform: (propertyValue) => property2.json(propertyValue, opts)
            };
          }
        },
        unrecognizedObjectKeys: opts == null ? void 0 : opts.unrecognizedObjectKeys
      });
    },
    getType: () => SchemaType.OBJECT
  };
  return {
    ...baseSchema,
    ...getSchemaUtils(baseSchema),
    ...getObjectLikeUtils(baseSchema),
    ...getObjectUtils(baseSchema)
  };
}
async function validateAndTransformObject({
  value,
  requiredKeys,
  getProperty,
  unrecognizedObjectKeys = "fail"
}) {
  if (!isPlainObject(value)) {
    return {
      ok: false,
      errors: [
        {
          path: [],
          message: NOT_AN_OBJECT_ERROR_MESSAGE
        }
      ]
    };
  }
  const missingRequiredKeys = new Set(requiredKeys);
  const errors = [];
  const transformed = {};
  for (const [preTransformedKey, preTransformedItemValue] of Object.entries(value)) {
    const property2 = getProperty(preTransformedKey);
    if (property2 != null) {
      missingRequiredKeys.delete(preTransformedKey);
      const value2 = await property2.transform(preTransformedItemValue);
      if (value2.ok) {
        transformed[property2.transformedKey] = value2.value;
      } else {
        errors.push(
          ...value2.errors.map((error) => ({
            path: [preTransformedKey, ...error.path],
            message: error.message
          }))
        );
      }
    } else {
      switch (unrecognizedObjectKeys) {
        case "fail":
          errors.push({
            path: [preTransformedKey],
            message: `Unrecognized key "${preTransformedKey}"`
          });
          break;
        case "strip":
          break;
        case "passthrough":
          transformed[preTransformedKey] = preTransformedItemValue;
          break;
      }
    }
  }
  errors.push(
    ...requiredKeys.filter((key) => missingRequiredKeys.has(key)).map((key) => ({
      path: [],
      message: `Missing required key "${key}"`
    }))
  );
  if (errors.length === 0) {
    return {
      ok: true,
      value: transformed
    };
  } else {
    return {
      ok: false,
      errors
    };
  }
}
function getObjectUtils(schema) {
  return {
    extend: (extension) => {
      const baseSchema = {
        _getParsedProperties: async () => [
          ...await schema._getParsedProperties(),
          ...await extension._getParsedProperties()
        ],
        _getRawProperties: async () => [
          ...await schema._getRawProperties(),
          ...await extension._getRawProperties()
        ],
        parse: async (raw, opts) => {
          return validateAndTransformExtendedObject({
            extensionKeys: await extension._getRawProperties(),
            value: raw,
            transformBase: (rawBase) => schema.parse(rawBase, opts),
            transformExtension: (rawExtension) => extension.parse(rawExtension, opts)
          });
        },
        json: async (parsed, opts) => {
          return validateAndTransformExtendedObject({
            extensionKeys: await extension._getParsedProperties(),
            value: parsed,
            transformBase: (parsedBase) => schema.json(parsedBase, opts),
            transformExtension: (parsedExtension) => extension.json(parsedExtension, opts)
          });
        },
        getType: () => SchemaType.OBJECT
      };
      return {
        ...baseSchema,
        ...getSchemaUtils(baseSchema),
        ...getObjectLikeUtils(baseSchema),
        ...getObjectUtils(baseSchema)
      };
    }
  };
}
async function validateAndTransformExtendedObject({
  extensionKeys,
  value,
  transformBase,
  transformExtension
}) {
  const extensionPropertiesSet = new Set(extensionKeys);
  const [extensionProperties, baseProperties] = partition(
    keys(value),
    (key) => extensionPropertiesSet.has(key)
  );
  const transformedBase = await transformBase(filterObject(value, baseProperties));
  const transformedExtension = await transformExtension(filterObject(value, extensionProperties));
  if (transformedBase.ok && transformedExtension.ok) {
    return {
      ok: true,
      value: {
        ...transformedBase.value,
        ...transformedExtension.value
      }
    };
  } else {
    return {
      ok: false,
      errors: [
        ...transformedBase.ok ? [] : transformedBase.errors,
        ...transformedExtension.ok ? [] : transformedExtension.errors
      ]
    };
  }
}
async function isSchemaRequired(schema) {
  return !await isSchemaOptional(schema);
}
async function isSchemaOptional(schema) {
  switch (await schema.getType()) {
    case SchemaType.ANY:
    case SchemaType.UNKNOWN:
    case SchemaType.OPTIONAL:
      return true;
    default:
      return false;
  }
}
var init_object = __esm({
  "src/core/schemas/builders/object/object.ts"() {
    "use strict";
    init_Schema();
    init_entries();
    init_filterObject();
    init_isPlainObject();
    init_keys();
    init_partition();
    init_object_like();
    init_schema_utils();
    init_property();
  }
});

// src/core/schemas/builders/object/index.ts
var init_object2 = __esm({
  "src/core/schemas/builders/object/index.ts"() {
    "use strict";
    init_object();
    init_property();
  }
});

// src/core/schemas/builders/lazy/lazyObject.ts
function lazyObject(getter) {
  const baseSchema = {
    ...constructLazyBaseSchema(getter),
    _getRawProperties: async () => (await getMemoizedSchema(getter))._getRawProperties(),
    _getParsedProperties: async () => (await getMemoizedSchema(getter))._getParsedProperties()
  };
  return {
    ...baseSchema,
    ...getSchemaUtils(baseSchema),
    ...getObjectLikeUtils(baseSchema),
    ...getObjectUtils(baseSchema)
  };
}
var init_lazyObject = __esm({
  "src/core/schemas/builders/lazy/lazyObject.ts"() {
    "use strict";
    init_object2();
    init_object_like();
    init_schema_utils();
    init_lazy();
  }
});

// src/core/schemas/builders/lazy/index.ts
var init_lazy2 = __esm({
  "src/core/schemas/builders/lazy/index.ts"() {
    "use strict";
    init_lazy();
    init_lazyObject();
  }
});

// src/core/schemas/builders/list/list.ts
function list(schema) {
  const baseSchema = {
    parse: async (raw, opts) => validateAndTransformArray(raw, (item) => schema.parse(item, opts)),
    json: (parsed, opts) => validateAndTransformArray(parsed, (item) => schema.json(item, opts)),
    getType: () => SchemaType.LIST
  };
  return {
    ...baseSchema,
    ...getSchemaUtils(baseSchema)
  };
}
async function validateAndTransformArray(value, transformItem) {
  if (!Array.isArray(value)) {
    return {
      ok: false,
      errors: [
        {
          message: "Not a list",
          path: []
        }
      ]
    };
  }
  const maybeValidItems = await Promise.all(value.map((item) => transformItem(item)));
  return maybeValidItems.reduce(
    (acc, item, index) => {
      if (acc.ok && item.ok) {
        return {
          ok: true,
          value: [...acc.value, item.value]
        };
      }
      const errors = [];
      if (!acc.ok) {
        errors.push(...acc.errors);
      }
      if (!item.ok) {
        errors.push(
          ...item.errors.map((error) => ({
            path: [`[${index}]`, ...error.path],
            message: error.message
          }))
        );
      }
      return {
        ok: false,
        errors
      };
    },
    { ok: true, value: [] }
  );
}
var init_list = __esm({
  "src/core/schemas/builders/list/list.ts"() {
    "use strict";
    init_Schema();
    init_schema_utils();
  }
});

// src/core/schemas/builders/list/index.ts
var init_list2 = __esm({
  "src/core/schemas/builders/list/index.ts"() {
    "use strict";
    init_list();
  }
});

// src/core/schemas/builders/literals/stringLiteral.ts
function stringLiteral(literal) {
  const schemaCreator = createIdentitySchemaCreator(SchemaType.STRING_LITERAL, (value) => {
    if (value === literal) {
      return {
        ok: true,
        value: literal
      };
    } else {
      return {
        ok: false,
        errors: [
          {
            path: [],
            message: `Not equal to "${literal}"`
          }
        ]
      };
    }
  });
  return schemaCreator();
}
var init_stringLiteral = __esm({
  "src/core/schemas/builders/literals/stringLiteral.ts"() {
    "use strict";
    init_Schema();
    init_createIdentitySchemaCreator();
  }
});

// src/core/schemas/builders/literals/index.ts
var init_literals = __esm({
  "src/core/schemas/builders/literals/index.ts"() {
    "use strict";
    init_stringLiteral();
  }
});

// src/core/schemas/builders/primitives/any.ts
var any;
var init_any = __esm({
  "src/core/schemas/builders/primitives/any.ts"() {
    "use strict";
    init_Schema();
    init_createIdentitySchemaCreator();
    any = createIdentitySchemaCreator(SchemaType.ANY, (value) => ({ ok: true, value }));
  }
});

// src/core/schemas/builders/primitives/boolean.ts
var boolean;
var init_boolean = __esm({
  "src/core/schemas/builders/primitives/boolean.ts"() {
    "use strict";
    init_Schema();
    init_createIdentitySchemaCreator();
    boolean = createIdentitySchemaCreator(SchemaType.BOOLEAN, (value) => {
      if (typeof value === "boolean") {
        return {
          ok: true,
          value
        };
      } else {
        return {
          ok: false,
          errors: [
            {
              path: [],
              message: "Not a boolean"
            }
          ]
        };
      }
    });
  }
});

// src/core/schemas/builders/primitives/number.ts
var number;
var init_number = __esm({
  "src/core/schemas/builders/primitives/number.ts"() {
    "use strict";
    init_Schema();
    init_createIdentitySchemaCreator();
    number = createIdentitySchemaCreator(SchemaType.NUMBER, (value) => {
      if (typeof value === "number") {
        return {
          ok: true,
          value
        };
      } else {
        return {
          ok: false,
          errors: [
            {
              path: [],
              message: "Not a number"
            }
          ]
        };
      }
    });
  }
});

// src/core/schemas/builders/primitives/string.ts
var string;
var init_string = __esm({
  "src/core/schemas/builders/primitives/string.ts"() {
    "use strict";
    init_Schema();
    init_createIdentitySchemaCreator();
    string = createIdentitySchemaCreator(SchemaType.STRING, (value) => {
      if (typeof value === "string") {
        return {
          ok: true,
          value
        };
      } else {
        return {
          ok: false,
          errors: [
            {
              path: [],
              message: "Not a string"
            }
          ]
        };
      }
    });
  }
});

// src/core/schemas/builders/primitives/unknown.ts
var unknown;
var init_unknown = __esm({
  "src/core/schemas/builders/primitives/unknown.ts"() {
    "use strict";
    init_Schema();
    init_createIdentitySchemaCreator();
    unknown = createIdentitySchemaCreator(SchemaType.UNKNOWN, (value) => ({ ok: true, value }));
  }
});

// src/core/schemas/builders/primitives/index.ts
var init_primitives = __esm({
  "src/core/schemas/builders/primitives/index.ts"() {
    "use strict";
    init_any();
    init_boolean();
    init_number();
    init_string();
    init_unknown();
  }
});

// src/core/schemas/builders/record/record.ts
function record(keySchema, valueSchema) {
  const baseSchema = {
    parse: async (raw, opts) => {
      return validateAndTransformRecord({
        value: raw,
        isKeyNumeric: await keySchema.getType() === SchemaType.NUMBER,
        transformKey: (key) => keySchema.parse(key, opts),
        transformValue: (value) => valueSchema.parse(value, opts)
      });
    },
    json: async (parsed, opts) => {
      return validateAndTransformRecord({
        value: parsed,
        isKeyNumeric: await keySchema.getType() === SchemaType.NUMBER,
        transformKey: (key) => keySchema.json(key, opts),
        transformValue: (value) => valueSchema.json(value, opts)
      });
    },
    getType: () => SchemaType.RECORD
  };
  return {
    ...baseSchema,
    ...getSchemaUtils(baseSchema)
  };
}
async function validateAndTransformRecord({
  value,
  isKeyNumeric,
  transformKey,
  transformValue
}) {
  if (!isPlainObject(value)) {
    return {
      ok: false,
      errors: [
        {
          path: [],
          message: NOT_AN_OBJECT_ERROR_MESSAGE
        }
      ]
    };
  }
  return entries(value).reduce(
    async (accPromise, [stringKey, value2]) => {
      if (value2 == null) {
        return accPromise;
      }
      const acc = await accPromise;
      let key = stringKey;
      if (isKeyNumeric) {
        const numberKey = stringKey.length > 0 ? Number(stringKey) : NaN;
        if (!isNaN(numberKey)) {
          key = numberKey;
        }
      }
      const transformedKey = await transformKey(key);
      const transformedValue = await transformValue(value2);
      if (acc.ok && transformedKey.ok && transformedValue.ok) {
        return {
          ok: true,
          value: {
            ...acc.value,
            [transformedKey.value]: transformedValue.value
          }
        };
      }
      const errors = [];
      if (!acc.ok) {
        errors.push(...acc.errors);
      }
      if (!transformedKey.ok) {
        errors.push(
          ...transformedKey.errors.map((error) => ({
            path: [`${key} (key)`, ...error.path],
            message: error.message
          }))
        );
      }
      if (!transformedValue.ok) {
        errors.push(
          ...transformedValue.errors.map((error) => ({
            path: [stringKey, ...error.path],
            message: error.message
          }))
        );
      }
      return {
        ok: false,
        errors
      };
    },
    Promise.resolve({ ok: true, value: {} })
  );
}
var init_record = __esm({
  "src/core/schemas/builders/record/record.ts"() {
    "use strict";
    init_Schema();
    init_entries();
    init_isPlainObject();
    init_schema_utils();
  }
});

// src/core/schemas/builders/record/index.ts
var init_record2 = __esm({
  "src/core/schemas/builders/record/index.ts"() {
    "use strict";
    init_record();
  }
});

// src/core/schemas/builders/set/set.ts
function set(schema) {
  const listSchema = list(schema);
  const baseSchema = {
    parse: async (raw, opts) => {
      const parsedList = await listSchema.parse(raw, opts);
      if (parsedList.ok) {
        return {
          ok: true,
          value: new Set(parsedList.value)
        };
      } else {
        return parsedList;
      }
    },
    json: async (parsed, opts) => {
      if (!(parsed instanceof Set)) {
        return {
          ok: false,
          errors: [
            {
              path: [],
              message: "Not a Set"
            }
          ]
        };
      }
      const jsonList = await listSchema.json([...parsed], opts);
      return jsonList;
    },
    getType: () => SchemaType.SET
  };
  return {
    ...baseSchema,
    ...getSchemaUtils(baseSchema)
  };
}
var init_set = __esm({
  "src/core/schemas/builders/set/set.ts"() {
    "use strict";
    init_Schema();
    init_list2();
    init_schema_utils();
  }
});

// src/core/schemas/builders/set/index.ts
var init_set2 = __esm({
  "src/core/schemas/builders/set/index.ts"() {
    "use strict";
    init_set();
  }
});

// src/core/schemas/builders/undiscriminated-union/undiscriminatedUnion.ts
function undiscriminatedUnion(schemas) {
  const baseSchema = {
    parse: async (raw, opts) => {
      return validateAndTransformUndiscriminatedUnion(
        (schema) => schema.parse(raw, opts),
        schemas
      );
    },
    json: async (parsed, opts) => {
      return validateAndTransformUndiscriminatedUnion(
        (schema) => schema.json(parsed, opts),
        schemas
      );
    },
    getType: () => SchemaType.UNDISCRIMINATED_UNION
  };
  return {
    ...baseSchema,
    ...getSchemaUtils(baseSchema)
  };
}
async function validateAndTransformUndiscriminatedUnion(transform2, schemas) {
  const errors = [];
  for (const schema of schemas) {
    const transformed = await transform2(schema);
    if (transformed.ok) {
      return transformed;
    } else if (errors.length === 0) {
      errors.push(...transformed.errors);
    }
  }
  return {
    ok: false,
    errors
  };
}
var init_undiscriminatedUnion = __esm({
  "src/core/schemas/builders/undiscriminated-union/undiscriminatedUnion.ts"() {
    "use strict";
    init_Schema();
    init_schema_utils();
  }
});

// src/core/schemas/builders/undiscriminated-union/index.ts
var init_undiscriminated_union = __esm({
  "src/core/schemas/builders/undiscriminated-union/index.ts"() {
    "use strict";
    init_undiscriminatedUnion();
  }
});

// src/core/schemas/builders/union/discriminant.ts
function discriminant(parsedDiscriminant, rawDiscriminant) {
  return {
    parsedDiscriminant,
    rawDiscriminant
  };
}
var init_discriminant = __esm({
  "src/core/schemas/builders/union/discriminant.ts"() {
    "use strict";
  }
});

// src/core/schemas/builders/union/union.ts
function union(discriminant2, union2) {
  const rawDiscriminant = typeof discriminant2 === "string" ? discriminant2 : discriminant2.rawDiscriminant;
  const parsedDiscriminant = typeof discriminant2 === "string" ? discriminant2 : discriminant2.parsedDiscriminant;
  const discriminantValueSchema = enum_(keys(union2));
  const baseSchema = {
    parse: async (raw, opts) => {
      return transformAndValidateUnion({
        value: raw,
        discriminant: rawDiscriminant,
        transformedDiscriminant: parsedDiscriminant,
        transformDiscriminantValue: (discriminantValue) => discriminantValueSchema.parse(discriminantValue, {
          allowUnrecognizedEnumValues: opts == null ? void 0 : opts.allowUnrecognizedUnionMembers
        }),
        getAdditionalPropertiesSchema: (discriminantValue) => union2[discriminantValue],
        allowUnrecognizedUnionMembers: opts == null ? void 0 : opts.allowUnrecognizedUnionMembers,
        transformAdditionalProperties: (additionalProperties, additionalPropertiesSchema) => additionalPropertiesSchema.parse(additionalProperties, opts)
      });
    },
    json: async (parsed, opts) => {
      return transformAndValidateUnion({
        value: parsed,
        discriminant: parsedDiscriminant,
        transformedDiscriminant: rawDiscriminant,
        transformDiscriminantValue: (discriminantValue) => discriminantValueSchema.json(discriminantValue, {
          allowUnrecognizedEnumValues: opts == null ? void 0 : opts.allowUnrecognizedUnionMembers
        }),
        getAdditionalPropertiesSchema: (discriminantValue) => union2[discriminantValue],
        allowUnrecognizedUnionMembers: opts == null ? void 0 : opts.allowUnrecognizedUnionMembers,
        transformAdditionalProperties: (additionalProperties, additionalPropertiesSchema) => additionalPropertiesSchema.json(additionalProperties, opts)
      });
    },
    getType: () => SchemaType.UNION
  };
  return {
    ...baseSchema,
    ...getSchemaUtils(baseSchema),
    ...getObjectLikeUtils(baseSchema)
  };
}
async function transformAndValidateUnion({
  value,
  discriminant: discriminant2,
  transformedDiscriminant,
  transformDiscriminantValue,
  getAdditionalPropertiesSchema,
  allowUnrecognizedUnionMembers = false,
  transformAdditionalProperties
}) {
  if (!isPlainObject(value)) {
    return {
      ok: false,
      errors: [
        {
          path: [],
          message: NOT_AN_OBJECT_ERROR_MESSAGE
        }
      ]
    };
  }
  const { [discriminant2]: discriminantValue, ...additionalProperties } = value;
  if (discriminantValue == null) {
    return {
      ok: false,
      errors: [
        {
          path: [],
          message: `Missing discriminant ("${discriminant2}")`
        }
      ]
    };
  }
  const transformedDiscriminantValue = await transformDiscriminantValue(discriminantValue);
  if (!transformedDiscriminantValue.ok) {
    return {
      ok: false,
      errors: transformedDiscriminantValue.errors.map((error) => ({
        path: [discriminant2, ...error.path],
        message: error.message
      }))
    };
  }
  const additionalPropertiesSchema = getAdditionalPropertiesSchema(transformedDiscriminantValue.value);
  if (additionalPropertiesSchema == null) {
    if (allowUnrecognizedUnionMembers) {
      return {
        ok: true,
        value: {
          [transformedDiscriminant]: transformedDiscriminantValue.value,
          ...additionalProperties
        }
      };
    } else {
      return {
        ok: false,
        errors: [
          {
            path: [discriminant2],
            message: "Unrecognized discriminant value"
          }
        ]
      };
    }
  }
  const transformedAdditionalProperties = await transformAdditionalProperties(
    additionalProperties,
    additionalPropertiesSchema
  );
  if (!transformedAdditionalProperties.ok) {
    return transformedAdditionalProperties;
  }
  return {
    ok: true,
    value: {
      [transformedDiscriminant]: discriminantValue,
      ...transformedAdditionalProperties.value
    }
  };
}
var init_union = __esm({
  "src/core/schemas/builders/union/union.ts"() {
    "use strict";
    init_Schema();
    init_isPlainObject();
    init_keys();
    init_enum2();
    init_object_like();
    init_schema_utils();
  }
});

// src/core/schemas/builders/union/index.ts
var init_union2 = __esm({
  "src/core/schemas/builders/union/index.ts"() {
    "use strict";
    init_discriminant();
    init_union();
  }
});

// src/core/schemas/builders/index.ts
var init_builders = __esm({
  "src/core/schemas/builders/index.ts"() {
    "use strict";
    init_date2();
    init_enum2();
    init_lazy2();
    init_list2();
    init_literals();
    init_object2();
    init_object_like();
    init_primitives();
    init_record2();
    init_schema_utils();
    init_set2();
    init_undiscriminated_union();
    init_union2();
  }
});

// src/core/schemas/index.ts
var schemas_exports = {};
__export(schemas_exports, {
  JsonError: () => JsonError,
  ParseError: () => ParseError,
  any: () => any,
  boolean: () => boolean,
  date: () => date,
  discriminant: () => discriminant,
  enum_: () => enum_,
  getObjectLikeUtils: () => getObjectLikeUtils,
  getObjectUtils: () => getObjectUtils,
  getSchemaUtils: () => getSchemaUtils,
  isProperty: () => isProperty,
  lazy: () => lazy,
  lazyObject: () => lazyObject,
  list: () => list,
  number: () => number,
  object: () => object,
  optional: () => optional,
  property: () => property,
  record: () => record,
  set: () => set,
  string: () => string,
  stringLiteral: () => stringLiteral,
  transform: () => transform,
  undiscriminatedUnion: () => undiscriminatedUnion,
  union: () => union,
  unknown: () => unknown,
  withParsedProperties: () => withParsedProperties
});
var init_schemas = __esm({
  "src/core/schemas/index.ts"() {
    "use strict";
    init_builders();
    init_Schema();
  }
});

// node_modules/js-base64/base64.mjs
var _TD, _TE, b64ch, b64chs, b64tab, _fromCC, _U8Afrom;
var init_base64 = __esm({
  "node_modules/js-base64/base64.mjs"() {
    _TD = typeof TextDecoder === "function" ? new TextDecoder() : void 0;
    _TE = typeof TextEncoder === "function" ? new TextEncoder() : void 0;
    b64ch = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
    b64chs = Array.prototype.slice.call(b64ch);
    b64tab = ((a) => {
      let tab = {};
      a.forEach((c, i) => tab[c] = i);
      return tab;
    })(b64chs);
    _fromCC = String.fromCharCode.bind(String);
    _U8Afrom = typeof Uint8Array.from === "function" ? Uint8Array.from.bind(Uint8Array) : (it, fn = (x) => x) => new Uint8Array(Array.prototype.slice.call(it, 0).map(fn));
  }
});

// src/core/auth/BasicAuth.ts
var init_BasicAuth = __esm({
  "src/core/auth/BasicAuth.ts"() {
    "use strict";
    init_base64();
  }
});

// src/core/auth/BearerToken.ts
var init_BearerToken = __esm({
  "src/core/auth/BearerToken.ts"() {
    "use strict";
  }
});

// src/core/auth/index.ts
var init_auth = __esm({
  "src/core/auth/index.ts"() {
    "use strict";
    init_BasicAuth();
    init_BearerToken();
  }
});

// node_modules/axios/lib/helpers/bind.js
var require_bind = __commonJS({
  "node_modules/axios/lib/helpers/bind.js"(exports, module2) {
    "use strict";
    module2.exports = function bind(fn, thisArg) {
      return function wrap() {
        var args = new Array(arguments.length);
        for (var i = 0; i < args.length; i++) {
          args[i] = arguments[i];
        }
        return fn.apply(thisArg, args);
      };
    };
  }
});

// node_modules/axios/lib/utils.js
var require_utils = __commonJS({
  "node_modules/axios/lib/utils.js"(exports, module2) {
    "use strict";
    var bind = require_bind();
    var toString = Object.prototype.toString;
    var kindOf = function(cache) {
      return function(thing) {
        var str = toString.call(thing);
        return cache[str] || (cache[str] = str.slice(8, -1).toLowerCase());
      };
    }(/* @__PURE__ */ Object.create(null));
    function kindOfTest(type) {
      type = type.toLowerCase();
      return function isKindOf(thing) {
        return kindOf(thing) === type;
      };
    }
    function isArray(val) {
      return Array.isArray(val);
    }
    function isUndefined(val) {
      return typeof val === "undefined";
    }
    function isBuffer(val) {
      return val !== null && !isUndefined(val) && val.constructor !== null && !isUndefined(val.constructor) && typeof val.constructor.isBuffer === "function" && val.constructor.isBuffer(val);
    }
    var isArrayBuffer = kindOfTest("ArrayBuffer");
    function isArrayBufferView(val) {
      var result;
      if (typeof ArrayBuffer !== "undefined" && ArrayBuffer.isView) {
        result = ArrayBuffer.isView(val);
      } else {
        result = val && val.buffer && isArrayBuffer(val.buffer);
      }
      return result;
    }
    function isString(val) {
      return typeof val === "string";
    }
    function isNumber(val) {
      return typeof val === "number";
    }
    function isObject(val) {
      return val !== null && typeof val === "object";
    }
    function isPlainObject2(val) {
      if (kindOf(val) !== "object") {
        return false;
      }
      var prototype = Object.getPrototypeOf(val);
      return prototype === null || prototype === Object.prototype;
    }
    var isDate = kindOfTest("Date");
    var isFile = kindOfTest("File");
    var isBlob = kindOfTest("Blob");
    var isFileList = kindOfTest("FileList");
    function isFunction(val) {
      return toString.call(val) === "[object Function]";
    }
    function isStream(val) {
      return isObject(val) && isFunction(val.pipe);
    }
    function isFormData(thing) {
      var pattern = "[object FormData]";
      return thing && (typeof FormData === "function" && thing instanceof FormData || toString.call(thing) === pattern || isFunction(thing.toString) && thing.toString() === pattern);
    }
    var isURLSearchParams = kindOfTest("URLSearchParams");
    function trim(str) {
      return str.trim ? str.trim() : str.replace(/^\s+|\s+$/g, "");
    }
    function isStandardBrowserEnv() {
      if (typeof navigator !== "undefined" && (navigator.product === "ReactNative" || navigator.product === "NativeScript" || navigator.product === "NS")) {
        return false;
      }
      return typeof window !== "undefined" && typeof document !== "undefined";
    }
    function forEach(obj, fn) {
      if (obj === null || typeof obj === "undefined") {
        return;
      }
      if (typeof obj !== "object") {
        obj = [obj];
      }
      if (isArray(obj)) {
        for (var i = 0, l = obj.length; i < l; i++) {
          fn.call(null, obj[i], i, obj);
        }
      } else {
        for (var key in obj) {
          if (Object.prototype.hasOwnProperty.call(obj, key)) {
            fn.call(null, obj[key], key, obj);
          }
        }
      }
    }
    function merge() {
      var result = {};
      function assignValue(val, key) {
        if (isPlainObject2(result[key]) && isPlainObject2(val)) {
          result[key] = merge(result[key], val);
        } else if (isPlainObject2(val)) {
          result[key] = merge({}, val);
        } else if (isArray(val)) {
          result[key] = val.slice();
        } else {
          result[key] = val;
        }
      }
      for (var i = 0, l = arguments.length; i < l; i++) {
        forEach(arguments[i], assignValue);
      }
      return result;
    }
    function extend(a, b, thisArg) {
      forEach(b, function assignValue(val, key) {
        if (thisArg && typeof val === "function") {
          a[key] = bind(val, thisArg);
        } else {
          a[key] = val;
        }
      });
      return a;
    }
    function stripBOM(content) {
      if (content.charCodeAt(0) === 65279) {
        content = content.slice(1);
      }
      return content;
    }
    function inherits(constructor, superConstructor, props, descriptors) {
      constructor.prototype = Object.create(superConstructor.prototype, descriptors);
      constructor.prototype.constructor = constructor;
      props && Object.assign(constructor.prototype, props);
    }
    function toFlatObject(sourceObj, destObj, filter) {
      var props;
      var i;
      var prop;
      var merged = {};
      destObj = destObj || {};
      do {
        props = Object.getOwnPropertyNames(sourceObj);
        i = props.length;
        while (i-- > 0) {
          prop = props[i];
          if (!merged[prop]) {
            destObj[prop] = sourceObj[prop];
            merged[prop] = true;
          }
        }
        sourceObj = Object.getPrototypeOf(sourceObj);
      } while (sourceObj && (!filter || filter(sourceObj, destObj)) && sourceObj !== Object.prototype);
      return destObj;
    }
    function endsWith(str, searchString, position) {
      str = String(str);
      if (position === void 0 || position > str.length) {
        position = str.length;
      }
      position -= searchString.length;
      var lastIndex = str.indexOf(searchString, position);
      return lastIndex !== -1 && lastIndex === position;
    }
    function toArray(thing) {
      if (!thing)
        return null;
      var i = thing.length;
      if (isUndefined(i))
        return null;
      var arr = new Array(i);
      while (i-- > 0) {
        arr[i] = thing[i];
      }
      return arr;
    }
    var isTypedArray = function(TypedArray) {
      return function(thing) {
        return TypedArray && thing instanceof TypedArray;
      };
    }(typeof Uint8Array !== "undefined" && Object.getPrototypeOf(Uint8Array));
    module2.exports = {
      isArray,
      isArrayBuffer,
      isBuffer,
      isFormData,
      isArrayBufferView,
      isString,
      isNumber,
      isObject,
      isPlainObject: isPlainObject2,
      isUndefined,
      isDate,
      isFile,
      isBlob,
      isFunction,
      isStream,
      isURLSearchParams,
      isStandardBrowserEnv,
      forEach,
      merge,
      extend,
      trim,
      stripBOM,
      inherits,
      toFlatObject,
      kindOf,
      kindOfTest,
      endsWith,
      toArray,
      isTypedArray,
      isFileList
    };
  }
});

// node_modules/axios/lib/helpers/buildURL.js
var require_buildURL = __commonJS({
  "node_modules/axios/lib/helpers/buildURL.js"(exports, module2) {
    "use strict";
    var utils = require_utils();
    function encode(val) {
      return encodeURIComponent(val).replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%20/g, "+").replace(/%5B/gi, "[").replace(/%5D/gi, "]");
    }
    module2.exports = function buildURL(url, params, paramsSerializer) {
      if (!params) {
        return url;
      }
      var serializedParams;
      if (paramsSerializer) {
        serializedParams = paramsSerializer(params);
      } else if (utils.isURLSearchParams(params)) {
        serializedParams = params.toString();
      } else {
        var parts = [];
        utils.forEach(params, function serialize(val, key) {
          if (val === null || typeof val === "undefined") {
            return;
          }
          if (utils.isArray(val)) {
            key = key + "[]";
          } else {
            val = [val];
          }
          utils.forEach(val, function parseValue(v) {
            if (utils.isDate(v)) {
              v = v.toISOString();
            } else if (utils.isObject(v)) {
              v = JSON.stringify(v);
            }
            parts.push(encode(key) + "=" + encode(v));
          });
        });
        serializedParams = parts.join("&");
      }
      if (serializedParams) {
        var hashmarkIndex = url.indexOf("#");
        if (hashmarkIndex !== -1) {
          url = url.slice(0, hashmarkIndex);
        }
        url += (url.indexOf("?") === -1 ? "?" : "&") + serializedParams;
      }
      return url;
    };
  }
});

// node_modules/axios/lib/core/InterceptorManager.js
var require_InterceptorManager = __commonJS({
  "node_modules/axios/lib/core/InterceptorManager.js"(exports, module2) {
    "use strict";
    var utils = require_utils();
    function InterceptorManager() {
      this.handlers = [];
    }
    InterceptorManager.prototype.use = function use(fulfilled, rejected, options) {
      this.handlers.push({
        fulfilled,
        rejected,
        synchronous: options ? options.synchronous : false,
        runWhen: options ? options.runWhen : null
      });
      return this.handlers.length - 1;
    };
    InterceptorManager.prototype.eject = function eject(id) {
      if (this.handlers[id]) {
        this.handlers[id] = null;
      }
    };
    InterceptorManager.prototype.forEach = function forEach(fn) {
      utils.forEach(this.handlers, function forEachHandler(h) {
        if (h !== null) {
          fn(h);
        }
      });
    };
    module2.exports = InterceptorManager;
  }
});

// node_modules/axios/lib/helpers/normalizeHeaderName.js
var require_normalizeHeaderName = __commonJS({
  "node_modules/axios/lib/helpers/normalizeHeaderName.js"(exports, module2) {
    "use strict";
    var utils = require_utils();
    module2.exports = function normalizeHeaderName(headers, normalizedName) {
      utils.forEach(headers, function processHeader(value, name) {
        if (name !== normalizedName && name.toUpperCase() === normalizedName.toUpperCase()) {
          headers[normalizedName] = value;
          delete headers[name];
        }
      });
    };
  }
});

// node_modules/axios/lib/core/AxiosError.js
var require_AxiosError = __commonJS({
  "node_modules/axios/lib/core/AxiosError.js"(exports, module2) {
    "use strict";
    var utils = require_utils();
    function AxiosError2(message, code, config, request, response) {
      Error.call(this);
      this.message = message;
      this.name = "AxiosError";
      code && (this.code = code);
      config && (this.config = config);
      request && (this.request = request);
      response && (this.response = response);
    }
    utils.inherits(AxiosError2, Error, {
      toJSON: function toJSON() {
        return {
          // Standard
          message: this.message,
          name: this.name,
          // Microsoft
          description: this.description,
          number: this.number,
          // Mozilla
          fileName: this.fileName,
          lineNumber: this.lineNumber,
          columnNumber: this.columnNumber,
          stack: this.stack,
          // Axios
          config: this.config,
          code: this.code,
          status: this.response && this.response.status ? this.response.status : null
        };
      }
    });
    var prototype = AxiosError2.prototype;
    var descriptors = {};
    [
      "ERR_BAD_OPTION_VALUE",
      "ERR_BAD_OPTION",
      "ECONNABORTED",
      "ETIMEDOUT",
      "ERR_NETWORK",
      "ERR_FR_TOO_MANY_REDIRECTS",
      "ERR_DEPRECATED",
      "ERR_BAD_RESPONSE",
      "ERR_BAD_REQUEST",
      "ERR_CANCELED"
      // eslint-disable-next-line func-names
    ].forEach(function(code) {
      descriptors[code] = { value: code };
    });
    Object.defineProperties(AxiosError2, descriptors);
    Object.defineProperty(prototype, "isAxiosError", { value: true });
    AxiosError2.from = function(error, code, config, request, response, customProps) {
      var axiosError = Object.create(prototype);
      utils.toFlatObject(error, axiosError, function filter(obj) {
        return obj !== Error.prototype;
      });
      AxiosError2.call(axiosError, error.message, code, config, request, response);
      axiosError.name = error.name;
      customProps && Object.assign(axiosError, customProps);
      return axiosError;
    };
    module2.exports = AxiosError2;
  }
});

// node_modules/axios/lib/defaults/transitional.js
var require_transitional = __commonJS({
  "node_modules/axios/lib/defaults/transitional.js"(exports, module2) {
    "use strict";
    module2.exports = {
      silentJSONParsing: true,
      forcedJSONParsing: true,
      clarifyTimeoutError: false
    };
  }
});

// node_modules/axios/lib/helpers/toFormData.js
var require_toFormData = __commonJS({
  "node_modules/axios/lib/helpers/toFormData.js"(exports, module2) {
    "use strict";
    var utils = require_utils();
    function toFormData(obj, formData) {
      formData = formData || new FormData();
      var stack = [];
      function convertValue(value) {
        if (value === null)
          return "";
        if (utils.isDate(value)) {
          return value.toISOString();
        }
        if (utils.isArrayBuffer(value) || utils.isTypedArray(value)) {
          return typeof Blob === "function" ? new Blob([value]) : Buffer.from(value);
        }
        return value;
      }
      function build(data, parentKey) {
        if (utils.isPlainObject(data) || utils.isArray(data)) {
          if (stack.indexOf(data) !== -1) {
            throw Error("Circular reference detected in " + parentKey);
          }
          stack.push(data);
          utils.forEach(data, function each(value, key) {
            if (utils.isUndefined(value))
              return;
            var fullKey = parentKey ? parentKey + "." + key : key;
            var arr;
            if (value && !parentKey && typeof value === "object") {
              if (utils.endsWith(key, "{}")) {
                value = JSON.stringify(value);
              } else if (utils.endsWith(key, "[]") && (arr = utils.toArray(value))) {
                arr.forEach(function(el) {
                  !utils.isUndefined(el) && formData.append(fullKey, convertValue(el));
                });
                return;
              }
            }
            build(value, fullKey);
          });
          stack.pop();
        } else {
          formData.append(parentKey, convertValue(data));
        }
      }
      build(obj);
      return formData;
    }
    module2.exports = toFormData;
  }
});

// node_modules/axios/lib/core/settle.js
var require_settle = __commonJS({
  "node_modules/axios/lib/core/settle.js"(exports, module2) {
    "use strict";
    var AxiosError2 = require_AxiosError();
    module2.exports = function settle(resolve, reject, response) {
      var validateStatus = response.config.validateStatus;
      if (!response.status || !validateStatus || validateStatus(response.status)) {
        resolve(response);
      } else {
        reject(new AxiosError2(
          "Request failed with status code " + response.status,
          [AxiosError2.ERR_BAD_REQUEST, AxiosError2.ERR_BAD_RESPONSE][Math.floor(response.status / 100) - 4],
          response.config,
          response.request,
          response
        ));
      }
    };
  }
});

// node_modules/axios/lib/helpers/cookies.js
var require_cookies = __commonJS({
  "node_modules/axios/lib/helpers/cookies.js"(exports, module2) {
    "use strict";
    var utils = require_utils();
    module2.exports = utils.isStandardBrowserEnv() ? function standardBrowserEnv() {
      return {
        write: function write(name, value, expires, path, domain, secure) {
          var cookie = [];
          cookie.push(name + "=" + encodeURIComponent(value));
          if (utils.isNumber(expires)) {
            cookie.push("expires=" + new Date(expires).toGMTString());
          }
          if (utils.isString(path)) {
            cookie.push("path=" + path);
          }
          if (utils.isString(domain)) {
            cookie.push("domain=" + domain);
          }
          if (secure === true) {
            cookie.push("secure");
          }
          document.cookie = cookie.join("; ");
        },
        read: function read(name) {
          var match = document.cookie.match(new RegExp("(^|;\\s*)(" + name + ")=([^;]*)"));
          return match ? decodeURIComponent(match[3]) : null;
        },
        remove: function remove(name) {
          this.write(name, "", Date.now() - 864e5);
        }
      };
    }() : function nonStandardBrowserEnv() {
      return {
        write: function write() {
        },
        read: function read() {
          return null;
        },
        remove: function remove() {
        }
      };
    }();
  }
});

// node_modules/axios/lib/helpers/isAbsoluteURL.js
var require_isAbsoluteURL = __commonJS({
  "node_modules/axios/lib/helpers/isAbsoluteURL.js"(exports, module2) {
    "use strict";
    module2.exports = function isAbsoluteURL(url) {
      return /^([a-z][a-z\d+\-.]*:)?\/\//i.test(url);
    };
  }
});

// node_modules/axios/lib/helpers/combineURLs.js
var require_combineURLs = __commonJS({
  "node_modules/axios/lib/helpers/combineURLs.js"(exports, module2) {
    "use strict";
    module2.exports = function combineURLs(baseURL, relativeURL) {
      return relativeURL ? baseURL.replace(/\/+$/, "") + "/" + relativeURL.replace(/^\/+/, "") : baseURL;
    };
  }
});

// node_modules/axios/lib/core/buildFullPath.js
var require_buildFullPath = __commonJS({
  "node_modules/axios/lib/core/buildFullPath.js"(exports, module2) {
    "use strict";
    var isAbsoluteURL = require_isAbsoluteURL();
    var combineURLs = require_combineURLs();
    module2.exports = function buildFullPath(baseURL, requestedURL) {
      if (baseURL && !isAbsoluteURL(requestedURL)) {
        return combineURLs(baseURL, requestedURL);
      }
      return requestedURL;
    };
  }
});

// node_modules/axios/lib/helpers/parseHeaders.js
var require_parseHeaders = __commonJS({
  "node_modules/axios/lib/helpers/parseHeaders.js"(exports, module2) {
    "use strict";
    var utils = require_utils();
    var ignoreDuplicateOf = [
      "age",
      "authorization",
      "content-length",
      "content-type",
      "etag",
      "expires",
      "from",
      "host",
      "if-modified-since",
      "if-unmodified-since",
      "last-modified",
      "location",
      "max-forwards",
      "proxy-authorization",
      "referer",
      "retry-after",
      "user-agent"
    ];
    module2.exports = function parseHeaders(headers) {
      var parsed = {};
      var key;
      var val;
      var i;
      if (!headers) {
        return parsed;
      }
      utils.forEach(headers.split("\n"), function parser(line) {
        i = line.indexOf(":");
        key = utils.trim(line.substr(0, i)).toLowerCase();
        val = utils.trim(line.substr(i + 1));
        if (key) {
          if (parsed[key] && ignoreDuplicateOf.indexOf(key) >= 0) {
            return;
          }
          if (key === "set-cookie") {
            parsed[key] = (parsed[key] ? parsed[key] : []).concat([val]);
          } else {
            parsed[key] = parsed[key] ? parsed[key] + ", " + val : val;
          }
        }
      });
      return parsed;
    };
  }
});

// node_modules/axios/lib/helpers/isURLSameOrigin.js
var require_isURLSameOrigin = __commonJS({
  "node_modules/axios/lib/helpers/isURLSameOrigin.js"(exports, module2) {
    "use strict";
    var utils = require_utils();
    module2.exports = utils.isStandardBrowserEnv() ? function standardBrowserEnv() {
      var msie = /(msie|trident)/i.test(navigator.userAgent);
      var urlParsingNode = document.createElement("a");
      var originURL;
      function resolveURL(url) {
        var href = url;
        if (msie) {
          urlParsingNode.setAttribute("href", href);
          href = urlParsingNode.href;
        }
        urlParsingNode.setAttribute("href", href);
        return {
          href: urlParsingNode.href,
          protocol: urlParsingNode.protocol ? urlParsingNode.protocol.replace(/:$/, "") : "",
          host: urlParsingNode.host,
          search: urlParsingNode.search ? urlParsingNode.search.replace(/^\?/, "") : "",
          hash: urlParsingNode.hash ? urlParsingNode.hash.replace(/^#/, "") : "",
          hostname: urlParsingNode.hostname,
          port: urlParsingNode.port,
          pathname: urlParsingNode.pathname.charAt(0) === "/" ? urlParsingNode.pathname : "/" + urlParsingNode.pathname
        };
      }
      originURL = resolveURL(window.location.href);
      return function isURLSameOrigin(requestURL) {
        var parsed = utils.isString(requestURL) ? resolveURL(requestURL) : requestURL;
        return parsed.protocol === originURL.protocol && parsed.host === originURL.host;
      };
    }() : function nonStandardBrowserEnv() {
      return function isURLSameOrigin() {
        return true;
      };
    }();
  }
});

// node_modules/axios/lib/cancel/CanceledError.js
var require_CanceledError = __commonJS({
  "node_modules/axios/lib/cancel/CanceledError.js"(exports, module2) {
    "use strict";
    var AxiosError2 = require_AxiosError();
    var utils = require_utils();
    function CanceledError(message) {
      AxiosError2.call(this, message == null ? "canceled" : message, AxiosError2.ERR_CANCELED);
      this.name = "CanceledError";
    }
    utils.inherits(CanceledError, AxiosError2, {
      __CANCEL__: true
    });
    module2.exports = CanceledError;
  }
});

// node_modules/axios/lib/helpers/parseProtocol.js
var require_parseProtocol = __commonJS({
  "node_modules/axios/lib/helpers/parseProtocol.js"(exports, module2) {
    "use strict";
    module2.exports = function parseProtocol(url) {
      var match = /^([-+\w]{1,25})(:?\/\/|:)/.exec(url);
      return match && match[1] || "";
    };
  }
});

// node_modules/axios/lib/adapters/xhr.js
var require_xhr = __commonJS({
  "node_modules/axios/lib/adapters/xhr.js"(exports, module2) {
    "use strict";
    var utils = require_utils();
    var settle = require_settle();
    var cookies = require_cookies();
    var buildURL = require_buildURL();
    var buildFullPath = require_buildFullPath();
    var parseHeaders = require_parseHeaders();
    var isURLSameOrigin = require_isURLSameOrigin();
    var transitionalDefaults = require_transitional();
    var AxiosError2 = require_AxiosError();
    var CanceledError = require_CanceledError();
    var parseProtocol = require_parseProtocol();
    module2.exports = function xhrAdapter(config) {
      return new Promise(function dispatchXhrRequest(resolve, reject) {
        var requestData = config.data;
        var requestHeaders = config.headers;
        var responseType = config.responseType;
        var onCanceled;
        function done() {
          if (config.cancelToken) {
            config.cancelToken.unsubscribe(onCanceled);
          }
          if (config.signal) {
            config.signal.removeEventListener("abort", onCanceled);
          }
        }
        if (utils.isFormData(requestData) && utils.isStandardBrowserEnv()) {
          delete requestHeaders["Content-Type"];
        }
        var request = new XMLHttpRequest();
        if (config.auth) {
          var username = config.auth.username || "";
          var password = config.auth.password ? unescape(encodeURIComponent(config.auth.password)) : "";
          requestHeaders.Authorization = "Basic " + btoa(username + ":" + password);
        }
        var fullPath = buildFullPath(config.baseURL, config.url);
        request.open(config.method.toUpperCase(), buildURL(fullPath, config.params, config.paramsSerializer), true);
        request.timeout = config.timeout;
        function onloadend() {
          if (!request) {
            return;
          }
          var responseHeaders = "getAllResponseHeaders" in request ? parseHeaders(request.getAllResponseHeaders()) : null;
          var responseData = !responseType || responseType === "text" || responseType === "json" ? request.responseText : request.response;
          var response = {
            data: responseData,
            status: request.status,
            statusText: request.statusText,
            headers: responseHeaders,
            config,
            request
          };
          settle(function _resolve(value) {
            resolve(value);
            done();
          }, function _reject(err) {
            reject(err);
            done();
          }, response);
          request = null;
        }
        if ("onloadend" in request) {
          request.onloadend = onloadend;
        } else {
          request.onreadystatechange = function handleLoad() {
            if (!request || request.readyState !== 4) {
              return;
            }
            if (request.status === 0 && !(request.responseURL && request.responseURL.indexOf("file:") === 0)) {
              return;
            }
            setTimeout(onloadend);
          };
        }
        request.onabort = function handleAbort() {
          if (!request) {
            return;
          }
          reject(new AxiosError2("Request aborted", AxiosError2.ECONNABORTED, config, request));
          request = null;
        };
        request.onerror = function handleError() {
          reject(new AxiosError2("Network Error", AxiosError2.ERR_NETWORK, config, request, request));
          request = null;
        };
        request.ontimeout = function handleTimeout() {
          var timeoutErrorMessage = config.timeout ? "timeout of " + config.timeout + "ms exceeded" : "timeout exceeded";
          var transitional = config.transitional || transitionalDefaults;
          if (config.timeoutErrorMessage) {
            timeoutErrorMessage = config.timeoutErrorMessage;
          }
          reject(new AxiosError2(
            timeoutErrorMessage,
            transitional.clarifyTimeoutError ? AxiosError2.ETIMEDOUT : AxiosError2.ECONNABORTED,
            config,
            request
          ));
          request = null;
        };
        if (utils.isStandardBrowserEnv()) {
          var xsrfValue = (config.withCredentials || isURLSameOrigin(fullPath)) && config.xsrfCookieName ? cookies.read(config.xsrfCookieName) : void 0;
          if (xsrfValue) {
            requestHeaders[config.xsrfHeaderName] = xsrfValue;
          }
        }
        if ("setRequestHeader" in request) {
          utils.forEach(requestHeaders, function setRequestHeader(val, key) {
            if (typeof requestData === "undefined" && key.toLowerCase() === "content-type") {
              delete requestHeaders[key];
            } else {
              request.setRequestHeader(key, val);
            }
          });
        }
        if (!utils.isUndefined(config.withCredentials)) {
          request.withCredentials = !!config.withCredentials;
        }
        if (responseType && responseType !== "json") {
          request.responseType = config.responseType;
        }
        if (typeof config.onDownloadProgress === "function") {
          request.addEventListener("progress", config.onDownloadProgress);
        }
        if (typeof config.onUploadProgress === "function" && request.upload) {
          request.upload.addEventListener("progress", config.onUploadProgress);
        }
        if (config.cancelToken || config.signal) {
          onCanceled = function(cancel) {
            if (!request) {
              return;
            }
            reject(!cancel || cancel && cancel.type ? new CanceledError() : cancel);
            request.abort();
            request = null;
          };
          config.cancelToken && config.cancelToken.subscribe(onCanceled);
          if (config.signal) {
            config.signal.aborted ? onCanceled() : config.signal.addEventListener("abort", onCanceled);
          }
        }
        if (!requestData) {
          requestData = null;
        }
        var protocol = parseProtocol(fullPath);
        if (protocol && ["http", "https", "file"].indexOf(protocol) === -1) {
          reject(new AxiosError2("Unsupported protocol " + protocol + ":", AxiosError2.ERR_BAD_REQUEST, config));
          return;
        }
        request.send(requestData);
      });
    };
  }
});

// node_modules/follow-redirects/debug.js
var require_debug = __commonJS({
  "node_modules/follow-redirects/debug.js"(exports, module2) {
    var debug;
    module2.exports = function() {
      if (!debug) {
        try {
          debug = require("debug")("follow-redirects");
        } catch (error) {
        }
        if (typeof debug !== "function") {
          debug = function() {
          };
        }
      }
      debug.apply(null, arguments);
    };
  }
});

// node_modules/follow-redirects/index.js
var require_follow_redirects = __commonJS({
  "node_modules/follow-redirects/index.js"(exports, module2) {
    var url = require("url");
    var URL = url.URL;
    var http = require("http");
    var https = require("https");
    var Writable = require("stream").Writable;
    var assert = require("assert");
    var debug = require_debug();
    var events = ["abort", "aborted", "connect", "error", "socket", "timeout"];
    var eventHandlers = /* @__PURE__ */ Object.create(null);
    events.forEach(function(event) {
      eventHandlers[event] = function(arg1, arg2, arg3) {
        this._redirectable.emit(event, arg1, arg2, arg3);
      };
    });
    var InvalidUrlError = createErrorType(
      "ERR_INVALID_URL",
      "Invalid URL",
      TypeError
    );
    var RedirectionError = createErrorType(
      "ERR_FR_REDIRECTION_FAILURE",
      "Redirected request failed"
    );
    var TooManyRedirectsError = createErrorType(
      "ERR_FR_TOO_MANY_REDIRECTS",
      "Maximum number of redirects exceeded"
    );
    var MaxBodyLengthExceededError = createErrorType(
      "ERR_FR_MAX_BODY_LENGTH_EXCEEDED",
      "Request body larger than maxBodyLength limit"
    );
    var WriteAfterEndError = createErrorType(
      "ERR_STREAM_WRITE_AFTER_END",
      "write after end"
    );
    var destroy = Writable.prototype.destroy || noop;
    function RedirectableRequest(options, responseCallback) {
      Writable.call(this);
      this._sanitizeOptions(options);
      this._options = options;
      this._ended = false;
      this._ending = false;
      this._redirectCount = 0;
      this._redirects = [];
      this._requestBodyLength = 0;
      this._requestBodyBuffers = [];
      if (responseCallback) {
        this.on("response", responseCallback);
      }
      var self = this;
      this._onNativeResponse = function(response) {
        self._processResponse(response);
      };
      this._performRequest();
    }
    RedirectableRequest.prototype = Object.create(Writable.prototype);
    RedirectableRequest.prototype.abort = function() {
      destroyRequest(this._currentRequest);
      this._currentRequest.abort();
      this.emit("abort");
    };
    RedirectableRequest.prototype.destroy = function(error) {
      destroyRequest(this._currentRequest, error);
      destroy.call(this, error);
      return this;
    };
    RedirectableRequest.prototype.write = function(data, encoding, callback) {
      if (this._ending) {
        throw new WriteAfterEndError();
      }
      if (!isString(data) && !isBuffer(data)) {
        throw new TypeError("data should be a string, Buffer or Uint8Array");
      }
      if (isFunction(encoding)) {
        callback = encoding;
        encoding = null;
      }
      if (data.length === 0) {
        if (callback) {
          callback();
        }
        return;
      }
      if (this._requestBodyLength + data.length <= this._options.maxBodyLength) {
        this._requestBodyLength += data.length;
        this._requestBodyBuffers.push({ data, encoding });
        this._currentRequest.write(data, encoding, callback);
      } else {
        this.emit("error", new MaxBodyLengthExceededError());
        this.abort();
      }
    };
    RedirectableRequest.prototype.end = function(data, encoding, callback) {
      if (isFunction(data)) {
        callback = data;
        data = encoding = null;
      } else if (isFunction(encoding)) {
        callback = encoding;
        encoding = null;
      }
      if (!data) {
        this._ended = this._ending = true;
        this._currentRequest.end(null, null, callback);
      } else {
        var self = this;
        var currentRequest = this._currentRequest;
        this.write(data, encoding, function() {
          self._ended = true;
          currentRequest.end(null, null, callback);
        });
        this._ending = true;
      }
    };
    RedirectableRequest.prototype.setHeader = function(name, value) {
      this._options.headers[name] = value;
      this._currentRequest.setHeader(name, value);
    };
    RedirectableRequest.prototype.removeHeader = function(name) {
      delete this._options.headers[name];
      this._currentRequest.removeHeader(name);
    };
    RedirectableRequest.prototype.setTimeout = function(msecs, callback) {
      var self = this;
      function destroyOnTimeout(socket) {
        socket.setTimeout(msecs);
        socket.removeListener("timeout", socket.destroy);
        socket.addListener("timeout", socket.destroy);
      }
      function startTimer(socket) {
        if (self._timeout) {
          clearTimeout(self._timeout);
        }
        self._timeout = setTimeout(function() {
          self.emit("timeout");
          clearTimer();
        }, msecs);
        destroyOnTimeout(socket);
      }
      function clearTimer() {
        if (self._timeout) {
          clearTimeout(self._timeout);
          self._timeout = null;
        }
        self.removeListener("abort", clearTimer);
        self.removeListener("error", clearTimer);
        self.removeListener("response", clearTimer);
        self.removeListener("close", clearTimer);
        if (callback) {
          self.removeListener("timeout", callback);
        }
        if (!self.socket) {
          self._currentRequest.removeListener("socket", startTimer);
        }
      }
      if (callback) {
        this.on("timeout", callback);
      }
      if (this.socket) {
        startTimer(this.socket);
      } else {
        this._currentRequest.once("socket", startTimer);
      }
      this.on("socket", destroyOnTimeout);
      this.on("abort", clearTimer);
      this.on("error", clearTimer);
      this.on("response", clearTimer);
      this.on("close", clearTimer);
      return this;
    };
    [
      "flushHeaders",
      "getHeader",
      "setNoDelay",
      "setSocketKeepAlive"
    ].forEach(function(method) {
      RedirectableRequest.prototype[method] = function(a, b) {
        return this._currentRequest[method](a, b);
      };
    });
    ["aborted", "connection", "socket"].forEach(function(property2) {
      Object.defineProperty(RedirectableRequest.prototype, property2, {
        get: function() {
          return this._currentRequest[property2];
        }
      });
    });
    RedirectableRequest.prototype._sanitizeOptions = function(options) {
      if (!options.headers) {
        options.headers = {};
      }
      if (options.host) {
        if (!options.hostname) {
          options.hostname = options.host;
        }
        delete options.host;
      }
      if (!options.pathname && options.path) {
        var searchPos = options.path.indexOf("?");
        if (searchPos < 0) {
          options.pathname = options.path;
        } else {
          options.pathname = options.path.substring(0, searchPos);
          options.search = options.path.substring(searchPos);
        }
      }
    };
    RedirectableRequest.prototype._performRequest = function() {
      var protocol = this._options.protocol;
      var nativeProtocol = this._options.nativeProtocols[protocol];
      if (!nativeProtocol) {
        this.emit("error", new TypeError("Unsupported protocol " + protocol));
        return;
      }
      if (this._options.agents) {
        var scheme = protocol.slice(0, -1);
        this._options.agent = this._options.agents[scheme];
      }
      var request = this._currentRequest = nativeProtocol.request(this._options, this._onNativeResponse);
      request._redirectable = this;
      for (var event of events) {
        request.on(event, eventHandlers[event]);
      }
      this._currentUrl = /^\//.test(this._options.path) ? url.format(this._options) : (
        // When making a request to a proxy, […]
        // a client MUST send the target URI in absolute-form […].
        this._options.path
      );
      if (this._isRedirect) {
        var i = 0;
        var self = this;
        var buffers = this._requestBodyBuffers;
        (function writeNext(error) {
          if (request === self._currentRequest) {
            if (error) {
              self.emit("error", error);
            } else if (i < buffers.length) {
              var buffer = buffers[i++];
              if (!request.finished) {
                request.write(buffer.data, buffer.encoding, writeNext);
              }
            } else if (self._ended) {
              request.end();
            }
          }
        })();
      }
    };
    RedirectableRequest.prototype._processResponse = function(response) {
      var statusCode = response.statusCode;
      if (this._options.trackRedirects) {
        this._redirects.push({
          url: this._currentUrl,
          headers: response.headers,
          statusCode
        });
      }
      var location = response.headers.location;
      if (!location || this._options.followRedirects === false || statusCode < 300 || statusCode >= 400) {
        response.responseUrl = this._currentUrl;
        response.redirects = this._redirects;
        this.emit("response", response);
        this._requestBodyBuffers = [];
        return;
      }
      destroyRequest(this._currentRequest);
      response.destroy();
      if (++this._redirectCount > this._options.maxRedirects) {
        this.emit("error", new TooManyRedirectsError());
        return;
      }
      var requestHeaders;
      var beforeRedirect = this._options.beforeRedirect;
      if (beforeRedirect) {
        requestHeaders = Object.assign({
          // The Host header was set by nativeProtocol.request
          Host: response.req.getHeader("host")
        }, this._options.headers);
      }
      var method = this._options.method;
      if ((statusCode === 301 || statusCode === 302) && this._options.method === "POST" || statusCode === 303 && !/^(?:GET|HEAD)$/.test(this._options.method)) {
        this._options.method = "GET";
        this._requestBodyBuffers = [];
        removeMatchingHeaders(/^content-/i, this._options.headers);
      }
      var currentHostHeader = removeMatchingHeaders(/^host$/i, this._options.headers);
      var currentUrlParts = url.parse(this._currentUrl);
      var currentHost = currentHostHeader || currentUrlParts.host;
      var currentUrl = /^\w+:/.test(location) ? this._currentUrl : url.format(Object.assign(currentUrlParts, { host: currentHost }));
      var redirectUrl;
      try {
        redirectUrl = url.resolve(currentUrl, location);
      } catch (cause) {
        this.emit("error", new RedirectionError({ cause }));
        return;
      }
      debug("redirecting to", redirectUrl);
      this._isRedirect = true;
      var redirectUrlParts = url.parse(redirectUrl);
      Object.assign(this._options, redirectUrlParts);
      if (redirectUrlParts.protocol !== currentUrlParts.protocol && redirectUrlParts.protocol !== "https:" || redirectUrlParts.host !== currentHost && !isSubdomain(redirectUrlParts.host, currentHost)) {
        removeMatchingHeaders(/^(?:authorization|cookie)$/i, this._options.headers);
      }
      if (isFunction(beforeRedirect)) {
        var responseDetails = {
          headers: response.headers,
          statusCode
        };
        var requestDetails = {
          url: currentUrl,
          method,
          headers: requestHeaders
        };
        try {
          beforeRedirect(this._options, responseDetails, requestDetails);
        } catch (err) {
          this.emit("error", err);
          return;
        }
        this._sanitizeOptions(this._options);
      }
      try {
        this._performRequest();
      } catch (cause) {
        this.emit("error", new RedirectionError({ cause }));
      }
    };
    function wrap(protocols) {
      var exports2 = {
        maxRedirects: 21,
        maxBodyLength: 10 * 1024 * 1024
      };
      var nativeProtocols = {};
      Object.keys(protocols).forEach(function(scheme) {
        var protocol = scheme + ":";
        var nativeProtocol = nativeProtocols[protocol] = protocols[scheme];
        var wrappedProtocol = exports2[scheme] = Object.create(nativeProtocol);
        function request(input, options, callback) {
          if (isString(input)) {
            var parsed;
            try {
              parsed = urlToOptions(new URL(input));
            } catch (err) {
              parsed = url.parse(input);
            }
            if (!isString(parsed.protocol)) {
              throw new InvalidUrlError({ input });
            }
            input = parsed;
          } else if (URL && input instanceof URL) {
            input = urlToOptions(input);
          } else {
            callback = options;
            options = input;
            input = { protocol };
          }
          if (isFunction(options)) {
            callback = options;
            options = null;
          }
          options = Object.assign({
            maxRedirects: exports2.maxRedirects,
            maxBodyLength: exports2.maxBodyLength
          }, input, options);
          options.nativeProtocols = nativeProtocols;
          if (!isString(options.host) && !isString(options.hostname)) {
            options.hostname = "::1";
          }
          assert.equal(options.protocol, protocol, "protocol mismatch");
          debug("options", options);
          return new RedirectableRequest(options, callback);
        }
        function get(input, options, callback) {
          var wrappedRequest = wrappedProtocol.request(input, options, callback);
          wrappedRequest.end();
          return wrappedRequest;
        }
        Object.defineProperties(wrappedProtocol, {
          request: { value: request, configurable: true, enumerable: true, writable: true },
          get: { value: get, configurable: true, enumerable: true, writable: true }
        });
      });
      return exports2;
    }
    function noop() {
    }
    function urlToOptions(urlObject) {
      var options = {
        protocol: urlObject.protocol,
        hostname: urlObject.hostname.startsWith("[") ? (
          /* istanbul ignore next */
          urlObject.hostname.slice(1, -1)
        ) : urlObject.hostname,
        hash: urlObject.hash,
        search: urlObject.search,
        pathname: urlObject.pathname,
        path: urlObject.pathname + urlObject.search,
        href: urlObject.href
      };
      if (urlObject.port !== "") {
        options.port = Number(urlObject.port);
      }
      return options;
    }
    function removeMatchingHeaders(regex, headers) {
      var lastValue;
      for (var header in headers) {
        if (regex.test(header)) {
          lastValue = headers[header];
          delete headers[header];
        }
      }
      return lastValue === null || typeof lastValue === "undefined" ? void 0 : String(lastValue).trim();
    }
    function createErrorType(code, message, baseClass) {
      function CustomError(properties) {
        Error.captureStackTrace(this, this.constructor);
        Object.assign(this, properties || {});
        this.code = code;
        this.message = this.cause ? message + ": " + this.cause.message : message;
      }
      CustomError.prototype = new (baseClass || Error)();
      CustomError.prototype.constructor = CustomError;
      CustomError.prototype.name = "Error [" + code + "]";
      return CustomError;
    }
    function destroyRequest(request, error) {
      for (var event of events) {
        request.removeListener(event, eventHandlers[event]);
      }
      request.on("error", noop);
      request.destroy(error);
    }
    function isSubdomain(subdomain, domain) {
      assert(isString(subdomain) && isString(domain));
      var dot = subdomain.length - domain.length - 1;
      return dot > 0 && subdomain[dot] === "." && subdomain.endsWith(domain);
    }
    function isString(value) {
      return typeof value === "string" || value instanceof String;
    }
    function isFunction(value) {
      return typeof value === "function";
    }
    function isBuffer(value) {
      return typeof value === "object" && "length" in value;
    }
    module2.exports = wrap({ http, https });
    module2.exports.wrap = wrap;
  }
});

// node_modules/axios/lib/env/data.js
var require_data = __commonJS({
  "node_modules/axios/lib/env/data.js"(exports, module2) {
    module2.exports = {
      "version": "0.27.2"
    };
  }
});

// node_modules/axios/lib/adapters/http.js
var require_http = __commonJS({
  "node_modules/axios/lib/adapters/http.js"(exports, module2) {
    "use strict";
    var utils = require_utils();
    var settle = require_settle();
    var buildFullPath = require_buildFullPath();
    var buildURL = require_buildURL();
    var http = require("http");
    var https = require("https");
    var httpFollow = require_follow_redirects().http;
    var httpsFollow = require_follow_redirects().https;
    var url = require("url");
    var zlib = require("zlib");
    var VERSION = require_data().version;
    var transitionalDefaults = require_transitional();
    var AxiosError2 = require_AxiosError();
    var CanceledError = require_CanceledError();
    var isHttps = /https:?/;
    var supportedProtocols = ["http:", "https:", "file:"];
    function setProxy(options, proxy, location) {
      options.hostname = proxy.host;
      options.host = proxy.host;
      options.port = proxy.port;
      options.path = location;
      if (proxy.auth) {
        var base64 = Buffer.from(proxy.auth.username + ":" + proxy.auth.password, "utf8").toString("base64");
        options.headers["Proxy-Authorization"] = "Basic " + base64;
      }
      options.beforeRedirect = function beforeRedirect(redirection) {
        redirection.headers.host = redirection.host;
        setProxy(redirection, proxy, redirection.href);
      };
    }
    module2.exports = function httpAdapter(config) {
      return new Promise(function dispatchHttpRequest(resolvePromise, rejectPromise) {
        var onCanceled;
        function done() {
          if (config.cancelToken) {
            config.cancelToken.unsubscribe(onCanceled);
          }
          if (config.signal) {
            config.signal.removeEventListener("abort", onCanceled);
          }
        }
        var resolve = function resolve2(value) {
          done();
          resolvePromise(value);
        };
        var rejected = false;
        var reject = function reject2(value) {
          done();
          rejected = true;
          rejectPromise(value);
        };
        var data = config.data;
        var headers = config.headers;
        var headerNames = {};
        Object.keys(headers).forEach(function storeLowerName(name) {
          headerNames[name.toLowerCase()] = name;
        });
        if ("user-agent" in headerNames) {
          if (!headers[headerNames["user-agent"]]) {
            delete headers[headerNames["user-agent"]];
          }
        } else {
          headers["User-Agent"] = "axios/" + VERSION;
        }
        if (utils.isFormData(data) && utils.isFunction(data.getHeaders)) {
          Object.assign(headers, data.getHeaders());
        } else if (data && !utils.isStream(data)) {
          if (Buffer.isBuffer(data)) {
          } else if (utils.isArrayBuffer(data)) {
            data = Buffer.from(new Uint8Array(data));
          } else if (utils.isString(data)) {
            data = Buffer.from(data, "utf-8");
          } else {
            return reject(new AxiosError2(
              "Data after transformation must be a string, an ArrayBuffer, a Buffer, or a Stream",
              AxiosError2.ERR_BAD_REQUEST,
              config
            ));
          }
          if (config.maxBodyLength > -1 && data.length > config.maxBodyLength) {
            return reject(new AxiosError2(
              "Request body larger than maxBodyLength limit",
              AxiosError2.ERR_BAD_REQUEST,
              config
            ));
          }
          if (!headerNames["content-length"]) {
            headers["Content-Length"] = data.length;
          }
        }
        var auth = void 0;
        if (config.auth) {
          var username = config.auth.username || "";
          var password = config.auth.password || "";
          auth = username + ":" + password;
        }
        var fullPath = buildFullPath(config.baseURL, config.url);
        var parsed = url.parse(fullPath);
        var protocol = parsed.protocol || supportedProtocols[0];
        if (supportedProtocols.indexOf(protocol) === -1) {
          return reject(new AxiosError2(
            "Unsupported protocol " + protocol,
            AxiosError2.ERR_BAD_REQUEST,
            config
          ));
        }
        if (!auth && parsed.auth) {
          var urlAuth = parsed.auth.split(":");
          var urlUsername = urlAuth[0] || "";
          var urlPassword = urlAuth[1] || "";
          auth = urlUsername + ":" + urlPassword;
        }
        if (auth && headerNames.authorization) {
          delete headers[headerNames.authorization];
        }
        var isHttpsRequest = isHttps.test(protocol);
        var agent = isHttpsRequest ? config.httpsAgent : config.httpAgent;
        try {
          buildURL(parsed.path, config.params, config.paramsSerializer).replace(/^\?/, "");
        } catch (err) {
          var customErr = new Error(err.message);
          customErr.config = config;
          customErr.url = config.url;
          customErr.exists = true;
          reject(customErr);
        }
        var options = {
          path: buildURL(parsed.path, config.params, config.paramsSerializer).replace(/^\?/, ""),
          method: config.method.toUpperCase(),
          headers,
          agent,
          agents: { http: config.httpAgent, https: config.httpsAgent },
          auth
        };
        if (config.socketPath) {
          options.socketPath = config.socketPath;
        } else {
          options.hostname = parsed.hostname;
          options.port = parsed.port;
        }
        var proxy = config.proxy;
        if (!proxy && proxy !== false) {
          var proxyEnv = protocol.slice(0, -1) + "_proxy";
          var proxyUrl = process.env[proxyEnv] || process.env[proxyEnv.toUpperCase()];
          if (proxyUrl) {
            var parsedProxyUrl = url.parse(proxyUrl);
            var noProxyEnv = process.env.no_proxy || process.env.NO_PROXY;
            var shouldProxy = true;
            if (noProxyEnv) {
              var noProxy = noProxyEnv.split(",").map(function trim(s) {
                return s.trim();
              });
              shouldProxy = !noProxy.some(function proxyMatch(proxyElement) {
                if (!proxyElement) {
                  return false;
                }
                if (proxyElement === "*") {
                  return true;
                }
                if (proxyElement[0] === "." && parsed.hostname.substr(parsed.hostname.length - proxyElement.length) === proxyElement) {
                  return true;
                }
                return parsed.hostname === proxyElement;
              });
            }
            if (shouldProxy) {
              proxy = {
                host: parsedProxyUrl.hostname,
                port: parsedProxyUrl.port,
                protocol: parsedProxyUrl.protocol
              };
              if (parsedProxyUrl.auth) {
                var proxyUrlAuth = parsedProxyUrl.auth.split(":");
                proxy.auth = {
                  username: proxyUrlAuth[0],
                  password: proxyUrlAuth[1]
                };
              }
            }
          }
        }
        if (proxy) {
          options.headers.host = parsed.hostname + (parsed.port ? ":" + parsed.port : "");
          setProxy(options, proxy, protocol + "//" + parsed.hostname + (parsed.port ? ":" + parsed.port : "") + options.path);
        }
        var transport;
        var isHttpsProxy = isHttpsRequest && (proxy ? isHttps.test(proxy.protocol) : true);
        if (config.transport) {
          transport = config.transport;
        } else if (config.maxRedirects === 0) {
          transport = isHttpsProxy ? https : http;
        } else {
          if (config.maxRedirects) {
            options.maxRedirects = config.maxRedirects;
          }
          if (config.beforeRedirect) {
            options.beforeRedirect = config.beforeRedirect;
          }
          transport = isHttpsProxy ? httpsFollow : httpFollow;
        }
        if (config.maxBodyLength > -1) {
          options.maxBodyLength = config.maxBodyLength;
        }
        if (config.insecureHTTPParser) {
          options.insecureHTTPParser = config.insecureHTTPParser;
        }
        var req = transport.request(options, function handleResponse(res) {
          if (req.aborted)
            return;
          var stream = res;
          var lastRequest = res.req || req;
          if (res.statusCode !== 204 && lastRequest.method !== "HEAD" && config.decompress !== false) {
            switch (res.headers["content-encoding"]) {
              case "gzip":
              case "compress":
              case "deflate":
                stream = stream.pipe(zlib.createUnzip());
                delete res.headers["content-encoding"];
                break;
            }
          }
          var response = {
            status: res.statusCode,
            statusText: res.statusMessage,
            headers: res.headers,
            config,
            request: lastRequest
          };
          if (config.responseType === "stream") {
            response.data = stream;
            settle(resolve, reject, response);
          } else {
            var responseBuffer = [];
            var totalResponseBytes = 0;
            stream.on("data", function handleStreamData(chunk) {
              responseBuffer.push(chunk);
              totalResponseBytes += chunk.length;
              if (config.maxContentLength > -1 && totalResponseBytes > config.maxContentLength) {
                rejected = true;
                stream.destroy();
                reject(new AxiosError2(
                  "maxContentLength size of " + config.maxContentLength + " exceeded",
                  AxiosError2.ERR_BAD_RESPONSE,
                  config,
                  lastRequest
                ));
              }
            });
            stream.on("aborted", function handlerStreamAborted() {
              if (rejected) {
                return;
              }
              stream.destroy();
              reject(new AxiosError2(
                "maxContentLength size of " + config.maxContentLength + " exceeded",
                AxiosError2.ERR_BAD_RESPONSE,
                config,
                lastRequest
              ));
            });
            stream.on("error", function handleStreamError(err) {
              if (req.aborted)
                return;
              reject(AxiosError2.from(err, null, config, lastRequest));
            });
            stream.on("end", function handleStreamEnd() {
              try {
                var responseData = responseBuffer.length === 1 ? responseBuffer[0] : Buffer.concat(responseBuffer);
                if (config.responseType !== "arraybuffer") {
                  responseData = responseData.toString(config.responseEncoding);
                  if (!config.responseEncoding || config.responseEncoding === "utf8") {
                    responseData = utils.stripBOM(responseData);
                  }
                }
                response.data = responseData;
              } catch (err) {
                reject(AxiosError2.from(err, null, config, response.request, response));
              }
              settle(resolve, reject, response);
            });
          }
        });
        req.on("error", function handleRequestError(err) {
          reject(AxiosError2.from(err, null, config, req));
        });
        req.on("socket", function handleRequestSocket(socket) {
          socket.setKeepAlive(true, 1e3 * 60);
        });
        if (config.timeout) {
          var timeout = parseInt(config.timeout, 10);
          if (isNaN(timeout)) {
            reject(new AxiosError2(
              "error trying to parse `config.timeout` to int",
              AxiosError2.ERR_BAD_OPTION_VALUE,
              config,
              req
            ));
            return;
          }
          req.setTimeout(timeout, function handleRequestTimeout() {
            req.abort();
            var transitional = config.transitional || transitionalDefaults;
            reject(new AxiosError2(
              "timeout of " + timeout + "ms exceeded",
              transitional.clarifyTimeoutError ? AxiosError2.ETIMEDOUT : AxiosError2.ECONNABORTED,
              config,
              req
            ));
          });
        }
        if (config.cancelToken || config.signal) {
          onCanceled = function(cancel) {
            if (req.aborted)
              return;
            req.abort();
            reject(!cancel || cancel && cancel.type ? new CanceledError() : cancel);
          };
          config.cancelToken && config.cancelToken.subscribe(onCanceled);
          if (config.signal) {
            config.signal.aborted ? onCanceled() : config.signal.addEventListener("abort", onCanceled);
          }
        }
        if (utils.isStream(data)) {
          data.on("error", function handleStreamError(err) {
            reject(AxiosError2.from(err, config, null, req));
          }).pipe(req);
        } else {
          req.end(data);
        }
      });
    };
  }
});

// node_modules/delayed-stream/lib/delayed_stream.js
var require_delayed_stream = __commonJS({
  "node_modules/delayed-stream/lib/delayed_stream.js"(exports, module2) {
    var Stream = require("stream").Stream;
    var util = require("util");
    module2.exports = DelayedStream;
    function DelayedStream() {
      this.source = null;
      this.dataSize = 0;
      this.maxDataSize = 1024 * 1024;
      this.pauseStream = true;
      this._maxDataSizeExceeded = false;
      this._released = false;
      this._bufferedEvents = [];
    }
    util.inherits(DelayedStream, Stream);
    DelayedStream.create = function(source, options) {
      var delayedStream = new this();
      options = options || {};
      for (var option in options) {
        delayedStream[option] = options[option];
      }
      delayedStream.source = source;
      var realEmit = source.emit;
      source.emit = function() {
        delayedStream._handleEmit(arguments);
        return realEmit.apply(source, arguments);
      };
      source.on("error", function() {
      });
      if (delayedStream.pauseStream) {
        source.pause();
      }
      return delayedStream;
    };
    Object.defineProperty(DelayedStream.prototype, "readable", {
      configurable: true,
      enumerable: true,
      get: function() {
        return this.source.readable;
      }
    });
    DelayedStream.prototype.setEncoding = function() {
      return this.source.setEncoding.apply(this.source, arguments);
    };
    DelayedStream.prototype.resume = function() {
      if (!this._released) {
        this.release();
      }
      this.source.resume();
    };
    DelayedStream.prototype.pause = function() {
      this.source.pause();
    };
    DelayedStream.prototype.release = function() {
      this._released = true;
      this._bufferedEvents.forEach(function(args) {
        this.emit.apply(this, args);
      }.bind(this));
      this._bufferedEvents = [];
    };
    DelayedStream.prototype.pipe = function() {
      var r = Stream.prototype.pipe.apply(this, arguments);
      this.resume();
      return r;
    };
    DelayedStream.prototype._handleEmit = function(args) {
      if (this._released) {
        this.emit.apply(this, args);
        return;
      }
      if (args[0] === "data") {
        this.dataSize += args[1].length;
        this._checkIfMaxDataSizeExceeded();
      }
      this._bufferedEvents.push(args);
    };
    DelayedStream.prototype._checkIfMaxDataSizeExceeded = function() {
      if (this._maxDataSizeExceeded) {
        return;
      }
      if (this.dataSize <= this.maxDataSize) {
        return;
      }
      this._maxDataSizeExceeded = true;
      var message = "DelayedStream#maxDataSize of " + this.maxDataSize + " bytes exceeded.";
      this.emit("error", new Error(message));
    };
  }
});

// node_modules/combined-stream/lib/combined_stream.js
var require_combined_stream = __commonJS({
  "node_modules/combined-stream/lib/combined_stream.js"(exports, module2) {
    var util = require("util");
    var Stream = require("stream").Stream;
    var DelayedStream = require_delayed_stream();
    module2.exports = CombinedStream;
    function CombinedStream() {
      this.writable = false;
      this.readable = true;
      this.dataSize = 0;
      this.maxDataSize = 2 * 1024 * 1024;
      this.pauseStreams = true;
      this._released = false;
      this._streams = [];
      this._currentStream = null;
      this._insideLoop = false;
      this._pendingNext = false;
    }
    util.inherits(CombinedStream, Stream);
    CombinedStream.create = function(options) {
      var combinedStream = new this();
      options = options || {};
      for (var option in options) {
        combinedStream[option] = options[option];
      }
      return combinedStream;
    };
    CombinedStream.isStreamLike = function(stream) {
      return typeof stream !== "function" && typeof stream !== "string" && typeof stream !== "boolean" && typeof stream !== "number" && !Buffer.isBuffer(stream);
    };
    CombinedStream.prototype.append = function(stream) {
      var isStreamLike = CombinedStream.isStreamLike(stream);
      if (isStreamLike) {
        if (!(stream instanceof DelayedStream)) {
          var newStream = DelayedStream.create(stream, {
            maxDataSize: Infinity,
            pauseStream: this.pauseStreams
          });
          stream.on("data", this._checkDataSize.bind(this));
          stream = newStream;
        }
        this._handleErrors(stream);
        if (this.pauseStreams) {
          stream.pause();
        }
      }
      this._streams.push(stream);
      return this;
    };
    CombinedStream.prototype.pipe = function(dest, options) {
      Stream.prototype.pipe.call(this, dest, options);
      this.resume();
      return dest;
    };
    CombinedStream.prototype._getNext = function() {
      this._currentStream = null;
      if (this._insideLoop) {
        this._pendingNext = true;
        return;
      }
      this._insideLoop = true;
      try {
        do {
          this._pendingNext = false;
          this._realGetNext();
        } while (this._pendingNext);
      } finally {
        this._insideLoop = false;
      }
    };
    CombinedStream.prototype._realGetNext = function() {
      var stream = this._streams.shift();
      if (typeof stream == "undefined") {
        this.end();
        return;
      }
      if (typeof stream !== "function") {
        this._pipeNext(stream);
        return;
      }
      var getStream = stream;
      getStream(function(stream2) {
        var isStreamLike = CombinedStream.isStreamLike(stream2);
        if (isStreamLike) {
          stream2.on("data", this._checkDataSize.bind(this));
          this._handleErrors(stream2);
        }
        this._pipeNext(stream2);
      }.bind(this));
    };
    CombinedStream.prototype._pipeNext = function(stream) {
      this._currentStream = stream;
      var isStreamLike = CombinedStream.isStreamLike(stream);
      if (isStreamLike) {
        stream.on("end", this._getNext.bind(this));
        stream.pipe(this, { end: false });
        return;
      }
      var value = stream;
      this.write(value);
      this._getNext();
    };
    CombinedStream.prototype._handleErrors = function(stream) {
      var self = this;
      stream.on("error", function(err) {
        self._emitError(err);
      });
    };
    CombinedStream.prototype.write = function(data) {
      this.emit("data", data);
    };
    CombinedStream.prototype.pause = function() {
      if (!this.pauseStreams) {
        return;
      }
      if (this.pauseStreams && this._currentStream && typeof this._currentStream.pause == "function")
        this._currentStream.pause();
      this.emit("pause");
    };
    CombinedStream.prototype.resume = function() {
      if (!this._released) {
        this._released = true;
        this.writable = true;
        this._getNext();
      }
      if (this.pauseStreams && this._currentStream && typeof this._currentStream.resume == "function")
        this._currentStream.resume();
      this.emit("resume");
    };
    CombinedStream.prototype.end = function() {
      this._reset();
      this.emit("end");
    };
    CombinedStream.prototype.destroy = function() {
      this._reset();
      this.emit("close");
    };
    CombinedStream.prototype._reset = function() {
      this.writable = false;
      this._streams = [];
      this._currentStream = null;
    };
    CombinedStream.prototype._checkDataSize = function() {
      this._updateDataSize();
      if (this.dataSize <= this.maxDataSize) {
        return;
      }
      var message = "DelayedStream#maxDataSize of " + this.maxDataSize + " bytes exceeded.";
      this._emitError(new Error(message));
    };
    CombinedStream.prototype._updateDataSize = function() {
      this.dataSize = 0;
      var self = this;
      this._streams.forEach(function(stream) {
        if (!stream.dataSize) {
          return;
        }
        self.dataSize += stream.dataSize;
      });
      if (this._currentStream && this._currentStream.dataSize) {
        this.dataSize += this._currentStream.dataSize;
      }
    };
    CombinedStream.prototype._emitError = function(err) {
      this._reset();
      this.emit("error", err);
    };
  }
});

// node_modules/mime-db/db.json
var require_db = __commonJS({
  "node_modules/mime-db/db.json"(exports, module2) {
    module2.exports = {
      "application/1d-interleaved-parityfec": {
        source: "iana"
      },
      "application/3gpdash-qoe-report+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/3gpp-ims+xml": {
        source: "iana",
        compressible: true
      },
      "application/3gpphal+json": {
        source: "iana",
        compressible: true
      },
      "application/3gpphalforms+json": {
        source: "iana",
        compressible: true
      },
      "application/a2l": {
        source: "iana"
      },
      "application/ace+cbor": {
        source: "iana"
      },
      "application/activemessage": {
        source: "iana"
      },
      "application/activity+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-costmap+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-costmapfilter+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-directory+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-endpointcost+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-endpointcostparams+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-endpointprop+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-endpointpropparams+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-error+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-networkmap+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-networkmapfilter+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-updatestreamcontrol+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-updatestreamparams+json": {
        source: "iana",
        compressible: true
      },
      "application/aml": {
        source: "iana"
      },
      "application/andrew-inset": {
        source: "iana",
        extensions: ["ez"]
      },
      "application/applefile": {
        source: "iana"
      },
      "application/applixware": {
        source: "apache",
        extensions: ["aw"]
      },
      "application/at+jwt": {
        source: "iana"
      },
      "application/atf": {
        source: "iana"
      },
      "application/atfx": {
        source: "iana"
      },
      "application/atom+xml": {
        source: "iana",
        compressible: true,
        extensions: ["atom"]
      },
      "application/atomcat+xml": {
        source: "iana",
        compressible: true,
        extensions: ["atomcat"]
      },
      "application/atomdeleted+xml": {
        source: "iana",
        compressible: true,
        extensions: ["atomdeleted"]
      },
      "application/atomicmail": {
        source: "iana"
      },
      "application/atomsvc+xml": {
        source: "iana",
        compressible: true,
        extensions: ["atomsvc"]
      },
      "application/atsc-dwd+xml": {
        source: "iana",
        compressible: true,
        extensions: ["dwd"]
      },
      "application/atsc-dynamic-event-message": {
        source: "iana"
      },
      "application/atsc-held+xml": {
        source: "iana",
        compressible: true,
        extensions: ["held"]
      },
      "application/atsc-rdt+json": {
        source: "iana",
        compressible: true
      },
      "application/atsc-rsat+xml": {
        source: "iana",
        compressible: true,
        extensions: ["rsat"]
      },
      "application/atxml": {
        source: "iana"
      },
      "application/auth-policy+xml": {
        source: "iana",
        compressible: true
      },
      "application/bacnet-xdd+zip": {
        source: "iana",
        compressible: false
      },
      "application/batch-smtp": {
        source: "iana"
      },
      "application/bdoc": {
        compressible: false,
        extensions: ["bdoc"]
      },
      "application/beep+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/calendar+json": {
        source: "iana",
        compressible: true
      },
      "application/calendar+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xcs"]
      },
      "application/call-completion": {
        source: "iana"
      },
      "application/cals-1840": {
        source: "iana"
      },
      "application/captive+json": {
        source: "iana",
        compressible: true
      },
      "application/cbor": {
        source: "iana"
      },
      "application/cbor-seq": {
        source: "iana"
      },
      "application/cccex": {
        source: "iana"
      },
      "application/ccmp+xml": {
        source: "iana",
        compressible: true
      },
      "application/ccxml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["ccxml"]
      },
      "application/cdfx+xml": {
        source: "iana",
        compressible: true,
        extensions: ["cdfx"]
      },
      "application/cdmi-capability": {
        source: "iana",
        extensions: ["cdmia"]
      },
      "application/cdmi-container": {
        source: "iana",
        extensions: ["cdmic"]
      },
      "application/cdmi-domain": {
        source: "iana",
        extensions: ["cdmid"]
      },
      "application/cdmi-object": {
        source: "iana",
        extensions: ["cdmio"]
      },
      "application/cdmi-queue": {
        source: "iana",
        extensions: ["cdmiq"]
      },
      "application/cdni": {
        source: "iana"
      },
      "application/cea": {
        source: "iana"
      },
      "application/cea-2018+xml": {
        source: "iana",
        compressible: true
      },
      "application/cellml+xml": {
        source: "iana",
        compressible: true
      },
      "application/cfw": {
        source: "iana"
      },
      "application/city+json": {
        source: "iana",
        compressible: true
      },
      "application/clr": {
        source: "iana"
      },
      "application/clue+xml": {
        source: "iana",
        compressible: true
      },
      "application/clue_info+xml": {
        source: "iana",
        compressible: true
      },
      "application/cms": {
        source: "iana"
      },
      "application/cnrp+xml": {
        source: "iana",
        compressible: true
      },
      "application/coap-group+json": {
        source: "iana",
        compressible: true
      },
      "application/coap-payload": {
        source: "iana"
      },
      "application/commonground": {
        source: "iana"
      },
      "application/conference-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/cose": {
        source: "iana"
      },
      "application/cose-key": {
        source: "iana"
      },
      "application/cose-key-set": {
        source: "iana"
      },
      "application/cpl+xml": {
        source: "iana",
        compressible: true,
        extensions: ["cpl"]
      },
      "application/csrattrs": {
        source: "iana"
      },
      "application/csta+xml": {
        source: "iana",
        compressible: true
      },
      "application/cstadata+xml": {
        source: "iana",
        compressible: true
      },
      "application/csvm+json": {
        source: "iana",
        compressible: true
      },
      "application/cu-seeme": {
        source: "apache",
        extensions: ["cu"]
      },
      "application/cwt": {
        source: "iana"
      },
      "application/cybercash": {
        source: "iana"
      },
      "application/dart": {
        compressible: true
      },
      "application/dash+xml": {
        source: "iana",
        compressible: true,
        extensions: ["mpd"]
      },
      "application/dash-patch+xml": {
        source: "iana",
        compressible: true,
        extensions: ["mpp"]
      },
      "application/dashdelta": {
        source: "iana"
      },
      "application/davmount+xml": {
        source: "iana",
        compressible: true,
        extensions: ["davmount"]
      },
      "application/dca-rft": {
        source: "iana"
      },
      "application/dcd": {
        source: "iana"
      },
      "application/dec-dx": {
        source: "iana"
      },
      "application/dialog-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/dicom": {
        source: "iana"
      },
      "application/dicom+json": {
        source: "iana",
        compressible: true
      },
      "application/dicom+xml": {
        source: "iana",
        compressible: true
      },
      "application/dii": {
        source: "iana"
      },
      "application/dit": {
        source: "iana"
      },
      "application/dns": {
        source: "iana"
      },
      "application/dns+json": {
        source: "iana",
        compressible: true
      },
      "application/dns-message": {
        source: "iana"
      },
      "application/docbook+xml": {
        source: "apache",
        compressible: true,
        extensions: ["dbk"]
      },
      "application/dots+cbor": {
        source: "iana"
      },
      "application/dskpp+xml": {
        source: "iana",
        compressible: true
      },
      "application/dssc+der": {
        source: "iana",
        extensions: ["dssc"]
      },
      "application/dssc+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xdssc"]
      },
      "application/dvcs": {
        source: "iana"
      },
      "application/ecmascript": {
        source: "iana",
        compressible: true,
        extensions: ["es", "ecma"]
      },
      "application/edi-consent": {
        source: "iana"
      },
      "application/edi-x12": {
        source: "iana",
        compressible: false
      },
      "application/edifact": {
        source: "iana",
        compressible: false
      },
      "application/efi": {
        source: "iana"
      },
      "application/elm+json": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/elm+xml": {
        source: "iana",
        compressible: true
      },
      "application/emergencycalldata.cap+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/emergencycalldata.comment+xml": {
        source: "iana",
        compressible: true
      },
      "application/emergencycalldata.control+xml": {
        source: "iana",
        compressible: true
      },
      "application/emergencycalldata.deviceinfo+xml": {
        source: "iana",
        compressible: true
      },
      "application/emergencycalldata.ecall.msd": {
        source: "iana"
      },
      "application/emergencycalldata.providerinfo+xml": {
        source: "iana",
        compressible: true
      },
      "application/emergencycalldata.serviceinfo+xml": {
        source: "iana",
        compressible: true
      },
      "application/emergencycalldata.subscriberinfo+xml": {
        source: "iana",
        compressible: true
      },
      "application/emergencycalldata.veds+xml": {
        source: "iana",
        compressible: true
      },
      "application/emma+xml": {
        source: "iana",
        compressible: true,
        extensions: ["emma"]
      },
      "application/emotionml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["emotionml"]
      },
      "application/encaprtp": {
        source: "iana"
      },
      "application/epp+xml": {
        source: "iana",
        compressible: true
      },
      "application/epub+zip": {
        source: "iana",
        compressible: false,
        extensions: ["epub"]
      },
      "application/eshop": {
        source: "iana"
      },
      "application/exi": {
        source: "iana",
        extensions: ["exi"]
      },
      "application/expect-ct-report+json": {
        source: "iana",
        compressible: true
      },
      "application/express": {
        source: "iana",
        extensions: ["exp"]
      },
      "application/fastinfoset": {
        source: "iana"
      },
      "application/fastsoap": {
        source: "iana"
      },
      "application/fdt+xml": {
        source: "iana",
        compressible: true,
        extensions: ["fdt"]
      },
      "application/fhir+json": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/fhir+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/fido.trusted-apps+json": {
        compressible: true
      },
      "application/fits": {
        source: "iana"
      },
      "application/flexfec": {
        source: "iana"
      },
      "application/font-sfnt": {
        source: "iana"
      },
      "application/font-tdpfr": {
        source: "iana",
        extensions: ["pfr"]
      },
      "application/font-woff": {
        source: "iana",
        compressible: false
      },
      "application/framework-attributes+xml": {
        source: "iana",
        compressible: true
      },
      "application/geo+json": {
        source: "iana",
        compressible: true,
        extensions: ["geojson"]
      },
      "application/geo+json-seq": {
        source: "iana"
      },
      "application/geopackage+sqlite3": {
        source: "iana"
      },
      "application/geoxacml+xml": {
        source: "iana",
        compressible: true
      },
      "application/gltf-buffer": {
        source: "iana"
      },
      "application/gml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["gml"]
      },
      "application/gpx+xml": {
        source: "apache",
        compressible: true,
        extensions: ["gpx"]
      },
      "application/gxf": {
        source: "apache",
        extensions: ["gxf"]
      },
      "application/gzip": {
        source: "iana",
        compressible: false,
        extensions: ["gz"]
      },
      "application/h224": {
        source: "iana"
      },
      "application/held+xml": {
        source: "iana",
        compressible: true
      },
      "application/hjson": {
        extensions: ["hjson"]
      },
      "application/http": {
        source: "iana"
      },
      "application/hyperstudio": {
        source: "iana",
        extensions: ["stk"]
      },
      "application/ibe-key-request+xml": {
        source: "iana",
        compressible: true
      },
      "application/ibe-pkg-reply+xml": {
        source: "iana",
        compressible: true
      },
      "application/ibe-pp-data": {
        source: "iana"
      },
      "application/iges": {
        source: "iana"
      },
      "application/im-iscomposing+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/index": {
        source: "iana"
      },
      "application/index.cmd": {
        source: "iana"
      },
      "application/index.obj": {
        source: "iana"
      },
      "application/index.response": {
        source: "iana"
      },
      "application/index.vnd": {
        source: "iana"
      },
      "application/inkml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["ink", "inkml"]
      },
      "application/iotp": {
        source: "iana"
      },
      "application/ipfix": {
        source: "iana",
        extensions: ["ipfix"]
      },
      "application/ipp": {
        source: "iana"
      },
      "application/isup": {
        source: "iana"
      },
      "application/its+xml": {
        source: "iana",
        compressible: true,
        extensions: ["its"]
      },
      "application/java-archive": {
        source: "apache",
        compressible: false,
        extensions: ["jar", "war", "ear"]
      },
      "application/java-serialized-object": {
        source: "apache",
        compressible: false,
        extensions: ["ser"]
      },
      "application/java-vm": {
        source: "apache",
        compressible: false,
        extensions: ["class"]
      },
      "application/javascript": {
        source: "iana",
        charset: "UTF-8",
        compressible: true,
        extensions: ["js", "mjs"]
      },
      "application/jf2feed+json": {
        source: "iana",
        compressible: true
      },
      "application/jose": {
        source: "iana"
      },
      "application/jose+json": {
        source: "iana",
        compressible: true
      },
      "application/jrd+json": {
        source: "iana",
        compressible: true
      },
      "application/jscalendar+json": {
        source: "iana",
        compressible: true
      },
      "application/json": {
        source: "iana",
        charset: "UTF-8",
        compressible: true,
        extensions: ["json", "map"]
      },
      "application/json-patch+json": {
        source: "iana",
        compressible: true
      },
      "application/json-seq": {
        source: "iana"
      },
      "application/json5": {
        extensions: ["json5"]
      },
      "application/jsonml+json": {
        source: "apache",
        compressible: true,
        extensions: ["jsonml"]
      },
      "application/jwk+json": {
        source: "iana",
        compressible: true
      },
      "application/jwk-set+json": {
        source: "iana",
        compressible: true
      },
      "application/jwt": {
        source: "iana"
      },
      "application/kpml-request+xml": {
        source: "iana",
        compressible: true
      },
      "application/kpml-response+xml": {
        source: "iana",
        compressible: true
      },
      "application/ld+json": {
        source: "iana",
        compressible: true,
        extensions: ["jsonld"]
      },
      "application/lgr+xml": {
        source: "iana",
        compressible: true,
        extensions: ["lgr"]
      },
      "application/link-format": {
        source: "iana"
      },
      "application/load-control+xml": {
        source: "iana",
        compressible: true
      },
      "application/lost+xml": {
        source: "iana",
        compressible: true,
        extensions: ["lostxml"]
      },
      "application/lostsync+xml": {
        source: "iana",
        compressible: true
      },
      "application/lpf+zip": {
        source: "iana",
        compressible: false
      },
      "application/lxf": {
        source: "iana"
      },
      "application/mac-binhex40": {
        source: "iana",
        extensions: ["hqx"]
      },
      "application/mac-compactpro": {
        source: "apache",
        extensions: ["cpt"]
      },
      "application/macwriteii": {
        source: "iana"
      },
      "application/mads+xml": {
        source: "iana",
        compressible: true,
        extensions: ["mads"]
      },
      "application/manifest+json": {
        source: "iana",
        charset: "UTF-8",
        compressible: true,
        extensions: ["webmanifest"]
      },
      "application/marc": {
        source: "iana",
        extensions: ["mrc"]
      },
      "application/marcxml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["mrcx"]
      },
      "application/mathematica": {
        source: "iana",
        extensions: ["ma", "nb", "mb"]
      },
      "application/mathml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["mathml"]
      },
      "application/mathml-content+xml": {
        source: "iana",
        compressible: true
      },
      "application/mathml-presentation+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-associated-procedure-description+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-deregister+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-envelope+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-msk+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-msk-response+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-protection-description+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-reception-report+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-register+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-register-response+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-schedule+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-user-service-description+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbox": {
        source: "iana",
        extensions: ["mbox"]
      },
      "application/media-policy-dataset+xml": {
        source: "iana",
        compressible: true,
        extensions: ["mpf"]
      },
      "application/media_control+xml": {
        source: "iana",
        compressible: true
      },
      "application/mediaservercontrol+xml": {
        source: "iana",
        compressible: true,
        extensions: ["mscml"]
      },
      "application/merge-patch+json": {
        source: "iana",
        compressible: true
      },
      "application/metalink+xml": {
        source: "apache",
        compressible: true,
        extensions: ["metalink"]
      },
      "application/metalink4+xml": {
        source: "iana",
        compressible: true,
        extensions: ["meta4"]
      },
      "application/mets+xml": {
        source: "iana",
        compressible: true,
        extensions: ["mets"]
      },
      "application/mf4": {
        source: "iana"
      },
      "application/mikey": {
        source: "iana"
      },
      "application/mipc": {
        source: "iana"
      },
      "application/missing-blocks+cbor-seq": {
        source: "iana"
      },
      "application/mmt-aei+xml": {
        source: "iana",
        compressible: true,
        extensions: ["maei"]
      },
      "application/mmt-usd+xml": {
        source: "iana",
        compressible: true,
        extensions: ["musd"]
      },
      "application/mods+xml": {
        source: "iana",
        compressible: true,
        extensions: ["mods"]
      },
      "application/moss-keys": {
        source: "iana"
      },
      "application/moss-signature": {
        source: "iana"
      },
      "application/mosskey-data": {
        source: "iana"
      },
      "application/mosskey-request": {
        source: "iana"
      },
      "application/mp21": {
        source: "iana",
        extensions: ["m21", "mp21"]
      },
      "application/mp4": {
        source: "iana",
        extensions: ["mp4s", "m4p"]
      },
      "application/mpeg4-generic": {
        source: "iana"
      },
      "application/mpeg4-iod": {
        source: "iana"
      },
      "application/mpeg4-iod-xmt": {
        source: "iana"
      },
      "application/mrb-consumer+xml": {
        source: "iana",
        compressible: true
      },
      "application/mrb-publish+xml": {
        source: "iana",
        compressible: true
      },
      "application/msc-ivr+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/msc-mixer+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/msword": {
        source: "iana",
        compressible: false,
        extensions: ["doc", "dot"]
      },
      "application/mud+json": {
        source: "iana",
        compressible: true
      },
      "application/multipart-core": {
        source: "iana"
      },
      "application/mxf": {
        source: "iana",
        extensions: ["mxf"]
      },
      "application/n-quads": {
        source: "iana",
        extensions: ["nq"]
      },
      "application/n-triples": {
        source: "iana",
        extensions: ["nt"]
      },
      "application/nasdata": {
        source: "iana"
      },
      "application/news-checkgroups": {
        source: "iana",
        charset: "US-ASCII"
      },
      "application/news-groupinfo": {
        source: "iana",
        charset: "US-ASCII"
      },
      "application/news-transmission": {
        source: "iana"
      },
      "application/nlsml+xml": {
        source: "iana",
        compressible: true
      },
      "application/node": {
        source: "iana",
        extensions: ["cjs"]
      },
      "application/nss": {
        source: "iana"
      },
      "application/oauth-authz-req+jwt": {
        source: "iana"
      },
      "application/oblivious-dns-message": {
        source: "iana"
      },
      "application/ocsp-request": {
        source: "iana"
      },
      "application/ocsp-response": {
        source: "iana"
      },
      "application/octet-stream": {
        source: "iana",
        compressible: false,
        extensions: ["bin", "dms", "lrf", "mar", "so", "dist", "distz", "pkg", "bpk", "dump", "elc", "deploy", "exe", "dll", "deb", "dmg", "iso", "img", "msi", "msp", "msm", "buffer"]
      },
      "application/oda": {
        source: "iana",
        extensions: ["oda"]
      },
      "application/odm+xml": {
        source: "iana",
        compressible: true
      },
      "application/odx": {
        source: "iana"
      },
      "application/oebps-package+xml": {
        source: "iana",
        compressible: true,
        extensions: ["opf"]
      },
      "application/ogg": {
        source: "iana",
        compressible: false,
        extensions: ["ogx"]
      },
      "application/omdoc+xml": {
        source: "apache",
        compressible: true,
        extensions: ["omdoc"]
      },
      "application/onenote": {
        source: "apache",
        extensions: ["onetoc", "onetoc2", "onetmp", "onepkg"]
      },
      "application/opc-nodeset+xml": {
        source: "iana",
        compressible: true
      },
      "application/oscore": {
        source: "iana"
      },
      "application/oxps": {
        source: "iana",
        extensions: ["oxps"]
      },
      "application/p21": {
        source: "iana"
      },
      "application/p21+zip": {
        source: "iana",
        compressible: false
      },
      "application/p2p-overlay+xml": {
        source: "iana",
        compressible: true,
        extensions: ["relo"]
      },
      "application/parityfec": {
        source: "iana"
      },
      "application/passport": {
        source: "iana"
      },
      "application/patch-ops-error+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xer"]
      },
      "application/pdf": {
        source: "iana",
        compressible: false,
        extensions: ["pdf"]
      },
      "application/pdx": {
        source: "iana"
      },
      "application/pem-certificate-chain": {
        source: "iana"
      },
      "application/pgp-encrypted": {
        source: "iana",
        compressible: false,
        extensions: ["pgp"]
      },
      "application/pgp-keys": {
        source: "iana",
        extensions: ["asc"]
      },
      "application/pgp-signature": {
        source: "iana",
        extensions: ["asc", "sig"]
      },
      "application/pics-rules": {
        source: "apache",
        extensions: ["prf"]
      },
      "application/pidf+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/pidf-diff+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/pkcs10": {
        source: "iana",
        extensions: ["p10"]
      },
      "application/pkcs12": {
        source: "iana"
      },
      "application/pkcs7-mime": {
        source: "iana",
        extensions: ["p7m", "p7c"]
      },
      "application/pkcs7-signature": {
        source: "iana",
        extensions: ["p7s"]
      },
      "application/pkcs8": {
        source: "iana",
        extensions: ["p8"]
      },
      "application/pkcs8-encrypted": {
        source: "iana"
      },
      "application/pkix-attr-cert": {
        source: "iana",
        extensions: ["ac"]
      },
      "application/pkix-cert": {
        source: "iana",
        extensions: ["cer"]
      },
      "application/pkix-crl": {
        source: "iana",
        extensions: ["crl"]
      },
      "application/pkix-pkipath": {
        source: "iana",
        extensions: ["pkipath"]
      },
      "application/pkixcmp": {
        source: "iana",
        extensions: ["pki"]
      },
      "application/pls+xml": {
        source: "iana",
        compressible: true,
        extensions: ["pls"]
      },
      "application/poc-settings+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/postscript": {
        source: "iana",
        compressible: true,
        extensions: ["ai", "eps", "ps"]
      },
      "application/ppsp-tracker+json": {
        source: "iana",
        compressible: true
      },
      "application/problem+json": {
        source: "iana",
        compressible: true
      },
      "application/problem+xml": {
        source: "iana",
        compressible: true
      },
      "application/provenance+xml": {
        source: "iana",
        compressible: true,
        extensions: ["provx"]
      },
      "application/prs.alvestrand.titrax-sheet": {
        source: "iana"
      },
      "application/prs.cww": {
        source: "iana",
        extensions: ["cww"]
      },
      "application/prs.cyn": {
        source: "iana",
        charset: "7-BIT"
      },
      "application/prs.hpub+zip": {
        source: "iana",
        compressible: false
      },
      "application/prs.nprend": {
        source: "iana"
      },
      "application/prs.plucker": {
        source: "iana"
      },
      "application/prs.rdf-xml-crypt": {
        source: "iana"
      },
      "application/prs.xsf+xml": {
        source: "iana",
        compressible: true
      },
      "application/pskc+xml": {
        source: "iana",
        compressible: true,
        extensions: ["pskcxml"]
      },
      "application/pvd+json": {
        source: "iana",
        compressible: true
      },
      "application/qsig": {
        source: "iana"
      },
      "application/raml+yaml": {
        compressible: true,
        extensions: ["raml"]
      },
      "application/raptorfec": {
        source: "iana"
      },
      "application/rdap+json": {
        source: "iana",
        compressible: true
      },
      "application/rdf+xml": {
        source: "iana",
        compressible: true,
        extensions: ["rdf", "owl"]
      },
      "application/reginfo+xml": {
        source: "iana",
        compressible: true,
        extensions: ["rif"]
      },
      "application/relax-ng-compact-syntax": {
        source: "iana",
        extensions: ["rnc"]
      },
      "application/remote-printing": {
        source: "iana"
      },
      "application/reputon+json": {
        source: "iana",
        compressible: true
      },
      "application/resource-lists+xml": {
        source: "iana",
        compressible: true,
        extensions: ["rl"]
      },
      "application/resource-lists-diff+xml": {
        source: "iana",
        compressible: true,
        extensions: ["rld"]
      },
      "application/rfc+xml": {
        source: "iana",
        compressible: true
      },
      "application/riscos": {
        source: "iana"
      },
      "application/rlmi+xml": {
        source: "iana",
        compressible: true
      },
      "application/rls-services+xml": {
        source: "iana",
        compressible: true,
        extensions: ["rs"]
      },
      "application/route-apd+xml": {
        source: "iana",
        compressible: true,
        extensions: ["rapd"]
      },
      "application/route-s-tsid+xml": {
        source: "iana",
        compressible: true,
        extensions: ["sls"]
      },
      "application/route-usd+xml": {
        source: "iana",
        compressible: true,
        extensions: ["rusd"]
      },
      "application/rpki-ghostbusters": {
        source: "iana",
        extensions: ["gbr"]
      },
      "application/rpki-manifest": {
        source: "iana",
        extensions: ["mft"]
      },
      "application/rpki-publication": {
        source: "iana"
      },
      "application/rpki-roa": {
        source: "iana",
        extensions: ["roa"]
      },
      "application/rpki-updown": {
        source: "iana"
      },
      "application/rsd+xml": {
        source: "apache",
        compressible: true,
        extensions: ["rsd"]
      },
      "application/rss+xml": {
        source: "apache",
        compressible: true,
        extensions: ["rss"]
      },
      "application/rtf": {
        source: "iana",
        compressible: true,
        extensions: ["rtf"]
      },
      "application/rtploopback": {
        source: "iana"
      },
      "application/rtx": {
        source: "iana"
      },
      "application/samlassertion+xml": {
        source: "iana",
        compressible: true
      },
      "application/samlmetadata+xml": {
        source: "iana",
        compressible: true
      },
      "application/sarif+json": {
        source: "iana",
        compressible: true
      },
      "application/sarif-external-properties+json": {
        source: "iana",
        compressible: true
      },
      "application/sbe": {
        source: "iana"
      },
      "application/sbml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["sbml"]
      },
      "application/scaip+xml": {
        source: "iana",
        compressible: true
      },
      "application/scim+json": {
        source: "iana",
        compressible: true
      },
      "application/scvp-cv-request": {
        source: "iana",
        extensions: ["scq"]
      },
      "application/scvp-cv-response": {
        source: "iana",
        extensions: ["scs"]
      },
      "application/scvp-vp-request": {
        source: "iana",
        extensions: ["spq"]
      },
      "application/scvp-vp-response": {
        source: "iana",
        extensions: ["spp"]
      },
      "application/sdp": {
        source: "iana",
        extensions: ["sdp"]
      },
      "application/secevent+jwt": {
        source: "iana"
      },
      "application/senml+cbor": {
        source: "iana"
      },
      "application/senml+json": {
        source: "iana",
        compressible: true
      },
      "application/senml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["senmlx"]
      },
      "application/senml-etch+cbor": {
        source: "iana"
      },
      "application/senml-etch+json": {
        source: "iana",
        compressible: true
      },
      "application/senml-exi": {
        source: "iana"
      },
      "application/sensml+cbor": {
        source: "iana"
      },
      "application/sensml+json": {
        source: "iana",
        compressible: true
      },
      "application/sensml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["sensmlx"]
      },
      "application/sensml-exi": {
        source: "iana"
      },
      "application/sep+xml": {
        source: "iana",
        compressible: true
      },
      "application/sep-exi": {
        source: "iana"
      },
      "application/session-info": {
        source: "iana"
      },
      "application/set-payment": {
        source: "iana"
      },
      "application/set-payment-initiation": {
        source: "iana",
        extensions: ["setpay"]
      },
      "application/set-registration": {
        source: "iana"
      },
      "application/set-registration-initiation": {
        source: "iana",
        extensions: ["setreg"]
      },
      "application/sgml": {
        source: "iana"
      },
      "application/sgml-open-catalog": {
        source: "iana"
      },
      "application/shf+xml": {
        source: "iana",
        compressible: true,
        extensions: ["shf"]
      },
      "application/sieve": {
        source: "iana",
        extensions: ["siv", "sieve"]
      },
      "application/simple-filter+xml": {
        source: "iana",
        compressible: true
      },
      "application/simple-message-summary": {
        source: "iana"
      },
      "application/simplesymbolcontainer": {
        source: "iana"
      },
      "application/sipc": {
        source: "iana"
      },
      "application/slate": {
        source: "iana"
      },
      "application/smil": {
        source: "iana"
      },
      "application/smil+xml": {
        source: "iana",
        compressible: true,
        extensions: ["smi", "smil"]
      },
      "application/smpte336m": {
        source: "iana"
      },
      "application/soap+fastinfoset": {
        source: "iana"
      },
      "application/soap+xml": {
        source: "iana",
        compressible: true
      },
      "application/sparql-query": {
        source: "iana",
        extensions: ["rq"]
      },
      "application/sparql-results+xml": {
        source: "iana",
        compressible: true,
        extensions: ["srx"]
      },
      "application/spdx+json": {
        source: "iana",
        compressible: true
      },
      "application/spirits-event+xml": {
        source: "iana",
        compressible: true
      },
      "application/sql": {
        source: "iana"
      },
      "application/srgs": {
        source: "iana",
        extensions: ["gram"]
      },
      "application/srgs+xml": {
        source: "iana",
        compressible: true,
        extensions: ["grxml"]
      },
      "application/sru+xml": {
        source: "iana",
        compressible: true,
        extensions: ["sru"]
      },
      "application/ssdl+xml": {
        source: "apache",
        compressible: true,
        extensions: ["ssdl"]
      },
      "application/ssml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["ssml"]
      },
      "application/stix+json": {
        source: "iana",
        compressible: true
      },
      "application/swid+xml": {
        source: "iana",
        compressible: true,
        extensions: ["swidtag"]
      },
      "application/tamp-apex-update": {
        source: "iana"
      },
      "application/tamp-apex-update-confirm": {
        source: "iana"
      },
      "application/tamp-community-update": {
        source: "iana"
      },
      "application/tamp-community-update-confirm": {
        source: "iana"
      },
      "application/tamp-error": {
        source: "iana"
      },
      "application/tamp-sequence-adjust": {
        source: "iana"
      },
      "application/tamp-sequence-adjust-confirm": {
        source: "iana"
      },
      "application/tamp-status-query": {
        source: "iana"
      },
      "application/tamp-status-response": {
        source: "iana"
      },
      "application/tamp-update": {
        source: "iana"
      },
      "application/tamp-update-confirm": {
        source: "iana"
      },
      "application/tar": {
        compressible: true
      },
      "application/taxii+json": {
        source: "iana",
        compressible: true
      },
      "application/td+json": {
        source: "iana",
        compressible: true
      },
      "application/tei+xml": {
        source: "iana",
        compressible: true,
        extensions: ["tei", "teicorpus"]
      },
      "application/tetra_isi": {
        source: "iana"
      },
      "application/thraud+xml": {
        source: "iana",
        compressible: true,
        extensions: ["tfi"]
      },
      "application/timestamp-query": {
        source: "iana"
      },
      "application/timestamp-reply": {
        source: "iana"
      },
      "application/timestamped-data": {
        source: "iana",
        extensions: ["tsd"]
      },
      "application/tlsrpt+gzip": {
        source: "iana"
      },
      "application/tlsrpt+json": {
        source: "iana",
        compressible: true
      },
      "application/tnauthlist": {
        source: "iana"
      },
      "application/token-introspection+jwt": {
        source: "iana"
      },
      "application/toml": {
        compressible: true,
        extensions: ["toml"]
      },
      "application/trickle-ice-sdpfrag": {
        source: "iana"
      },
      "application/trig": {
        source: "iana",
        extensions: ["trig"]
      },
      "application/ttml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["ttml"]
      },
      "application/tve-trigger": {
        source: "iana"
      },
      "application/tzif": {
        source: "iana"
      },
      "application/tzif-leap": {
        source: "iana"
      },
      "application/ubjson": {
        compressible: false,
        extensions: ["ubj"]
      },
      "application/ulpfec": {
        source: "iana"
      },
      "application/urc-grpsheet+xml": {
        source: "iana",
        compressible: true
      },
      "application/urc-ressheet+xml": {
        source: "iana",
        compressible: true,
        extensions: ["rsheet"]
      },
      "application/urc-targetdesc+xml": {
        source: "iana",
        compressible: true,
        extensions: ["td"]
      },
      "application/urc-uisocketdesc+xml": {
        source: "iana",
        compressible: true
      },
      "application/vcard+json": {
        source: "iana",
        compressible: true
      },
      "application/vcard+xml": {
        source: "iana",
        compressible: true
      },
      "application/vemmi": {
        source: "iana"
      },
      "application/vividence.scriptfile": {
        source: "apache"
      },
      "application/vnd.1000minds.decision-model+xml": {
        source: "iana",
        compressible: true,
        extensions: ["1km"]
      },
      "application/vnd.3gpp-prose+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp-prose-pc3ch+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp-v2x-local-service-information": {
        source: "iana"
      },
      "application/vnd.3gpp.5gnas": {
        source: "iana"
      },
      "application/vnd.3gpp.access-transfer-events+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.bsf+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.gmop+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.gtpc": {
        source: "iana"
      },
      "application/vnd.3gpp.interworking-data": {
        source: "iana"
      },
      "application/vnd.3gpp.lpp": {
        source: "iana"
      },
      "application/vnd.3gpp.mc-signalling-ear": {
        source: "iana"
      },
      "application/vnd.3gpp.mcdata-affiliation-command+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcdata-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcdata-payload": {
        source: "iana"
      },
      "application/vnd.3gpp.mcdata-service-config+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcdata-signalling": {
        source: "iana"
      },
      "application/vnd.3gpp.mcdata-ue-config+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcdata-user-profile+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcptt-affiliation-command+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcptt-floor-request+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcptt-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcptt-location-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcptt-mbms-usage-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcptt-service-config+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcptt-signed+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcptt-ue-config+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcptt-ue-init-config+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcptt-user-profile+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcvideo-affiliation-command+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcvideo-affiliation-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcvideo-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcvideo-location-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcvideo-mbms-usage-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcvideo-service-config+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcvideo-transmission-request+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcvideo-ue-config+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcvideo-user-profile+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mid-call+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.ngap": {
        source: "iana"
      },
      "application/vnd.3gpp.pfcp": {
        source: "iana"
      },
      "application/vnd.3gpp.pic-bw-large": {
        source: "iana",
        extensions: ["plb"]
      },
      "application/vnd.3gpp.pic-bw-small": {
        source: "iana",
        extensions: ["psb"]
      },
      "application/vnd.3gpp.pic-bw-var": {
        source: "iana",
        extensions: ["pvb"]
      },
      "application/vnd.3gpp.s1ap": {
        source: "iana"
      },
      "application/vnd.3gpp.sms": {
        source: "iana"
      },
      "application/vnd.3gpp.sms+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.srvcc-ext+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.srvcc-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.state-and-event-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.ussd+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp2.bcmcsinfo+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp2.sms": {
        source: "iana"
      },
      "application/vnd.3gpp2.tcap": {
        source: "iana",
        extensions: ["tcap"]
      },
      "application/vnd.3lightssoftware.imagescal": {
        source: "iana"
      },
      "application/vnd.3m.post-it-notes": {
        source: "iana",
        extensions: ["pwn"]
      },
      "application/vnd.accpac.simply.aso": {
        source: "iana",
        extensions: ["aso"]
      },
      "application/vnd.accpac.simply.imp": {
        source: "iana",
        extensions: ["imp"]
      },
      "application/vnd.acucobol": {
        source: "iana",
        extensions: ["acu"]
      },
      "application/vnd.acucorp": {
        source: "iana",
        extensions: ["atc", "acutc"]
      },
      "application/vnd.adobe.air-application-installer-package+zip": {
        source: "apache",
        compressible: false,
        extensions: ["air"]
      },
      "application/vnd.adobe.flash.movie": {
        source: "iana"
      },
      "application/vnd.adobe.formscentral.fcdt": {
        source: "iana",
        extensions: ["fcdt"]
      },
      "application/vnd.adobe.fxp": {
        source: "iana",
        extensions: ["fxp", "fxpl"]
      },
      "application/vnd.adobe.partial-upload": {
        source: "iana"
      },
      "application/vnd.adobe.xdp+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xdp"]
      },
      "application/vnd.adobe.xfdf": {
        source: "iana",
        extensions: ["xfdf"]
      },
      "application/vnd.aether.imp": {
        source: "iana"
      },
      "application/vnd.afpc.afplinedata": {
        source: "iana"
      },
      "application/vnd.afpc.afplinedata-pagedef": {
        source: "iana"
      },
      "application/vnd.afpc.cmoca-cmresource": {
        source: "iana"
      },
      "application/vnd.afpc.foca-charset": {
        source: "iana"
      },
      "application/vnd.afpc.foca-codedfont": {
        source: "iana"
      },
      "application/vnd.afpc.foca-codepage": {
        source: "iana"
      },
      "application/vnd.afpc.modca": {
        source: "iana"
      },
      "application/vnd.afpc.modca-cmtable": {
        source: "iana"
      },
      "application/vnd.afpc.modca-formdef": {
        source: "iana"
      },
      "application/vnd.afpc.modca-mediummap": {
        source: "iana"
      },
      "application/vnd.afpc.modca-objectcontainer": {
        source: "iana"
      },
      "application/vnd.afpc.modca-overlay": {
        source: "iana"
      },
      "application/vnd.afpc.modca-pagesegment": {
        source: "iana"
      },
      "application/vnd.age": {
        source: "iana",
        extensions: ["age"]
      },
      "application/vnd.ah-barcode": {
        source: "iana"
      },
      "application/vnd.ahead.space": {
        source: "iana",
        extensions: ["ahead"]
      },
      "application/vnd.airzip.filesecure.azf": {
        source: "iana",
        extensions: ["azf"]
      },
      "application/vnd.airzip.filesecure.azs": {
        source: "iana",
        extensions: ["azs"]
      },
      "application/vnd.amadeus+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.amazon.ebook": {
        source: "apache",
        extensions: ["azw"]
      },
      "application/vnd.amazon.mobi8-ebook": {
        source: "iana"
      },
      "application/vnd.americandynamics.acc": {
        source: "iana",
        extensions: ["acc"]
      },
      "application/vnd.amiga.ami": {
        source: "iana",
        extensions: ["ami"]
      },
      "application/vnd.amundsen.maze+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.android.ota": {
        source: "iana"
      },
      "application/vnd.android.package-archive": {
        source: "apache",
        compressible: false,
        extensions: ["apk"]
      },
      "application/vnd.anki": {
        source: "iana"
      },
      "application/vnd.anser-web-certificate-issue-initiation": {
        source: "iana",
        extensions: ["cii"]
      },
      "application/vnd.anser-web-funds-transfer-initiation": {
        source: "apache",
        extensions: ["fti"]
      },
      "application/vnd.antix.game-component": {
        source: "iana",
        extensions: ["atx"]
      },
      "application/vnd.apache.arrow.file": {
        source: "iana"
      },
      "application/vnd.apache.arrow.stream": {
        source: "iana"
      },
      "application/vnd.apache.thrift.binary": {
        source: "iana"
      },
      "application/vnd.apache.thrift.compact": {
        source: "iana"
      },
      "application/vnd.apache.thrift.json": {
        source: "iana"
      },
      "application/vnd.api+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.aplextor.warrp+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.apothekende.reservation+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.apple.installer+xml": {
        source: "iana",
        compressible: true,
        extensions: ["mpkg"]
      },
      "application/vnd.apple.keynote": {
        source: "iana",
        extensions: ["key"]
      },
      "application/vnd.apple.mpegurl": {
        source: "iana",
        extensions: ["m3u8"]
      },
      "application/vnd.apple.numbers": {
        source: "iana",
        extensions: ["numbers"]
      },
      "application/vnd.apple.pages": {
        source: "iana",
        extensions: ["pages"]
      },
      "application/vnd.apple.pkpass": {
        compressible: false,
        extensions: ["pkpass"]
      },
      "application/vnd.arastra.swi": {
        source: "iana"
      },
      "application/vnd.aristanetworks.swi": {
        source: "iana",
        extensions: ["swi"]
      },
      "application/vnd.artisan+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.artsquare": {
        source: "iana"
      },
      "application/vnd.astraea-software.iota": {
        source: "iana",
        extensions: ["iota"]
      },
      "application/vnd.audiograph": {
        source: "iana",
        extensions: ["aep"]
      },
      "application/vnd.autopackage": {
        source: "iana"
      },
      "application/vnd.avalon+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.avistar+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.balsamiq.bmml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["bmml"]
      },
      "application/vnd.balsamiq.bmpr": {
        source: "iana"
      },
      "application/vnd.banana-accounting": {
        source: "iana"
      },
      "application/vnd.bbf.usp.error": {
        source: "iana"
      },
      "application/vnd.bbf.usp.msg": {
        source: "iana"
      },
      "application/vnd.bbf.usp.msg+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.bekitzur-stech+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.bint.med-content": {
        source: "iana"
      },
      "application/vnd.biopax.rdf+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.blink-idb-value-wrapper": {
        source: "iana"
      },
      "application/vnd.blueice.multipass": {
        source: "iana",
        extensions: ["mpm"]
      },
      "application/vnd.bluetooth.ep.oob": {
        source: "iana"
      },
      "application/vnd.bluetooth.le.oob": {
        source: "iana"
      },
      "application/vnd.bmi": {
        source: "iana",
        extensions: ["bmi"]
      },
      "application/vnd.bpf": {
        source: "iana"
      },
      "application/vnd.bpf3": {
        source: "iana"
      },
      "application/vnd.businessobjects": {
        source: "iana",
        extensions: ["rep"]
      },
      "application/vnd.byu.uapi+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.cab-jscript": {
        source: "iana"
      },
      "application/vnd.canon-cpdl": {
        source: "iana"
      },
      "application/vnd.canon-lips": {
        source: "iana"
      },
      "application/vnd.capasystems-pg+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.cendio.thinlinc.clientconf": {
        source: "iana"
      },
      "application/vnd.century-systems.tcp_stream": {
        source: "iana"
      },
      "application/vnd.chemdraw+xml": {
        source: "iana",
        compressible: true,
        extensions: ["cdxml"]
      },
      "application/vnd.chess-pgn": {
        source: "iana"
      },
      "application/vnd.chipnuts.karaoke-mmd": {
        source: "iana",
        extensions: ["mmd"]
      },
      "application/vnd.ciedi": {
        source: "iana"
      },
      "application/vnd.cinderella": {
        source: "iana",
        extensions: ["cdy"]
      },
      "application/vnd.cirpack.isdn-ext": {
        source: "iana"
      },
      "application/vnd.citationstyles.style+xml": {
        source: "iana",
        compressible: true,
        extensions: ["csl"]
      },
      "application/vnd.claymore": {
        source: "iana",
        extensions: ["cla"]
      },
      "application/vnd.cloanto.rp9": {
        source: "iana",
        extensions: ["rp9"]
      },
      "application/vnd.clonk.c4group": {
        source: "iana",
        extensions: ["c4g", "c4d", "c4f", "c4p", "c4u"]
      },
      "application/vnd.cluetrust.cartomobile-config": {
        source: "iana",
        extensions: ["c11amc"]
      },
      "application/vnd.cluetrust.cartomobile-config-pkg": {
        source: "iana",
        extensions: ["c11amz"]
      },
      "application/vnd.coffeescript": {
        source: "iana"
      },
      "application/vnd.collabio.xodocuments.document": {
        source: "iana"
      },
      "application/vnd.collabio.xodocuments.document-template": {
        source: "iana"
      },
      "application/vnd.collabio.xodocuments.presentation": {
        source: "iana"
      },
      "application/vnd.collabio.xodocuments.presentation-template": {
        source: "iana"
      },
      "application/vnd.collabio.xodocuments.spreadsheet": {
        source: "iana"
      },
      "application/vnd.collabio.xodocuments.spreadsheet-template": {
        source: "iana"
      },
      "application/vnd.collection+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.collection.doc+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.collection.next+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.comicbook+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.comicbook-rar": {
        source: "iana"
      },
      "application/vnd.commerce-battelle": {
        source: "iana"
      },
      "application/vnd.commonspace": {
        source: "iana",
        extensions: ["csp"]
      },
      "application/vnd.contact.cmsg": {
        source: "iana",
        extensions: ["cdbcmsg"]
      },
      "application/vnd.coreos.ignition+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.cosmocaller": {
        source: "iana",
        extensions: ["cmc"]
      },
      "application/vnd.crick.clicker": {
        source: "iana",
        extensions: ["clkx"]
      },
      "application/vnd.crick.clicker.keyboard": {
        source: "iana",
        extensions: ["clkk"]
      },
      "application/vnd.crick.clicker.palette": {
        source: "iana",
        extensions: ["clkp"]
      },
      "application/vnd.crick.clicker.template": {
        source: "iana",
        extensions: ["clkt"]
      },
      "application/vnd.crick.clicker.wordbank": {
        source: "iana",
        extensions: ["clkw"]
      },
      "application/vnd.criticaltools.wbs+xml": {
        source: "iana",
        compressible: true,
        extensions: ["wbs"]
      },
      "application/vnd.cryptii.pipe+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.crypto-shade-file": {
        source: "iana"
      },
      "application/vnd.cryptomator.encrypted": {
        source: "iana"
      },
      "application/vnd.cryptomator.vault": {
        source: "iana"
      },
      "application/vnd.ctc-posml": {
        source: "iana",
        extensions: ["pml"]
      },
      "application/vnd.ctct.ws+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.cups-pdf": {
        source: "iana"
      },
      "application/vnd.cups-postscript": {
        source: "iana"
      },
      "application/vnd.cups-ppd": {
        source: "iana",
        extensions: ["ppd"]
      },
      "application/vnd.cups-raster": {
        source: "iana"
      },
      "application/vnd.cups-raw": {
        source: "iana"
      },
      "application/vnd.curl": {
        source: "iana"
      },
      "application/vnd.curl.car": {
        source: "apache",
        extensions: ["car"]
      },
      "application/vnd.curl.pcurl": {
        source: "apache",
        extensions: ["pcurl"]
      },
      "application/vnd.cyan.dean.root+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.cybank": {
        source: "iana"
      },
      "application/vnd.cyclonedx+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.cyclonedx+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.d2l.coursepackage1p0+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.d3m-dataset": {
        source: "iana"
      },
      "application/vnd.d3m-problem": {
        source: "iana"
      },
      "application/vnd.dart": {
        source: "iana",
        compressible: true,
        extensions: ["dart"]
      },
      "application/vnd.data-vision.rdz": {
        source: "iana",
        extensions: ["rdz"]
      },
      "application/vnd.datapackage+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dataresource+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dbf": {
        source: "iana",
        extensions: ["dbf"]
      },
      "application/vnd.debian.binary-package": {
        source: "iana"
      },
      "application/vnd.dece.data": {
        source: "iana",
        extensions: ["uvf", "uvvf", "uvd", "uvvd"]
      },
      "application/vnd.dece.ttml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["uvt", "uvvt"]
      },
      "application/vnd.dece.unspecified": {
        source: "iana",
        extensions: ["uvx", "uvvx"]
      },
      "application/vnd.dece.zip": {
        source: "iana",
        extensions: ["uvz", "uvvz"]
      },
      "application/vnd.denovo.fcselayout-link": {
        source: "iana",
        extensions: ["fe_launch"]
      },
      "application/vnd.desmume.movie": {
        source: "iana"
      },
      "application/vnd.dir-bi.plate-dl-nosuffix": {
        source: "iana"
      },
      "application/vnd.dm.delegation+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dna": {
        source: "iana",
        extensions: ["dna"]
      },
      "application/vnd.document+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dolby.mlp": {
        source: "apache",
        extensions: ["mlp"]
      },
      "application/vnd.dolby.mobile.1": {
        source: "iana"
      },
      "application/vnd.dolby.mobile.2": {
        source: "iana"
      },
      "application/vnd.doremir.scorecloud-binary-document": {
        source: "iana"
      },
      "application/vnd.dpgraph": {
        source: "iana",
        extensions: ["dpg"]
      },
      "application/vnd.dreamfactory": {
        source: "iana",
        extensions: ["dfac"]
      },
      "application/vnd.drive+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ds-keypoint": {
        source: "apache",
        extensions: ["kpxx"]
      },
      "application/vnd.dtg.local": {
        source: "iana"
      },
      "application/vnd.dtg.local.flash": {
        source: "iana"
      },
      "application/vnd.dtg.local.html": {
        source: "iana"
      },
      "application/vnd.dvb.ait": {
        source: "iana",
        extensions: ["ait"]
      },
      "application/vnd.dvb.dvbisl+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dvb.dvbj": {
        source: "iana"
      },
      "application/vnd.dvb.esgcontainer": {
        source: "iana"
      },
      "application/vnd.dvb.ipdcdftnotifaccess": {
        source: "iana"
      },
      "application/vnd.dvb.ipdcesgaccess": {
        source: "iana"
      },
      "application/vnd.dvb.ipdcesgaccess2": {
        source: "iana"
      },
      "application/vnd.dvb.ipdcesgpdd": {
        source: "iana"
      },
      "application/vnd.dvb.ipdcroaming": {
        source: "iana"
      },
      "application/vnd.dvb.iptv.alfec-base": {
        source: "iana"
      },
      "application/vnd.dvb.iptv.alfec-enhancement": {
        source: "iana"
      },
      "application/vnd.dvb.notif-aggregate-root+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dvb.notif-container+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dvb.notif-generic+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dvb.notif-ia-msglist+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dvb.notif-ia-registration-request+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dvb.notif-ia-registration-response+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dvb.notif-init+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dvb.pfr": {
        source: "iana"
      },
      "application/vnd.dvb.service": {
        source: "iana",
        extensions: ["svc"]
      },
      "application/vnd.dxr": {
        source: "iana"
      },
      "application/vnd.dynageo": {
        source: "iana",
        extensions: ["geo"]
      },
      "application/vnd.dzr": {
        source: "iana"
      },
      "application/vnd.easykaraoke.cdgdownload": {
        source: "iana"
      },
      "application/vnd.ecdis-update": {
        source: "iana"
      },
      "application/vnd.ecip.rlp": {
        source: "iana"
      },
      "application/vnd.eclipse.ditto+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ecowin.chart": {
        source: "iana",
        extensions: ["mag"]
      },
      "application/vnd.ecowin.filerequest": {
        source: "iana"
      },
      "application/vnd.ecowin.fileupdate": {
        source: "iana"
      },
      "application/vnd.ecowin.series": {
        source: "iana"
      },
      "application/vnd.ecowin.seriesrequest": {
        source: "iana"
      },
      "application/vnd.ecowin.seriesupdate": {
        source: "iana"
      },
      "application/vnd.efi.img": {
        source: "iana"
      },
      "application/vnd.efi.iso": {
        source: "iana"
      },
      "application/vnd.emclient.accessrequest+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.enliven": {
        source: "iana",
        extensions: ["nml"]
      },
      "application/vnd.enphase.envoy": {
        source: "iana"
      },
      "application/vnd.eprints.data+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.epson.esf": {
        source: "iana",
        extensions: ["esf"]
      },
      "application/vnd.epson.msf": {
        source: "iana",
        extensions: ["msf"]
      },
      "application/vnd.epson.quickanime": {
        source: "iana",
        extensions: ["qam"]
      },
      "application/vnd.epson.salt": {
        source: "iana",
        extensions: ["slt"]
      },
      "application/vnd.epson.ssf": {
        source: "iana",
        extensions: ["ssf"]
      },
      "application/vnd.ericsson.quickcall": {
        source: "iana"
      },
      "application/vnd.espass-espass+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.eszigno3+xml": {
        source: "iana",
        compressible: true,
        extensions: ["es3", "et3"]
      },
      "application/vnd.etsi.aoc+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.asic-e+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.etsi.asic-s+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.etsi.cug+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.iptvcommand+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.iptvdiscovery+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.iptvprofile+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.iptvsad-bc+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.iptvsad-cod+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.iptvsad-npvr+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.iptvservice+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.iptvsync+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.iptvueprofile+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.mcid+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.mheg5": {
        source: "iana"
      },
      "application/vnd.etsi.overload-control-policy-dataset+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.pstn+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.sci+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.simservs+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.timestamp-token": {
        source: "iana"
      },
      "application/vnd.etsi.tsl+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.tsl.der": {
        source: "iana"
      },
      "application/vnd.eu.kasparian.car+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.eudora.data": {
        source: "iana"
      },
      "application/vnd.evolv.ecig.profile": {
        source: "iana"
      },
      "application/vnd.evolv.ecig.settings": {
        source: "iana"
      },
      "application/vnd.evolv.ecig.theme": {
        source: "iana"
      },
      "application/vnd.exstream-empower+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.exstream-package": {
        source: "iana"
      },
      "application/vnd.ezpix-album": {
        source: "iana",
        extensions: ["ez2"]
      },
      "application/vnd.ezpix-package": {
        source: "iana",
        extensions: ["ez3"]
      },
      "application/vnd.f-secure.mobile": {
        source: "iana"
      },
      "application/vnd.familysearch.gedcom+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.fastcopy-disk-image": {
        source: "iana"
      },
      "application/vnd.fdf": {
        source: "iana",
        extensions: ["fdf"]
      },
      "application/vnd.fdsn.mseed": {
        source: "iana",
        extensions: ["mseed"]
      },
      "application/vnd.fdsn.seed": {
        source: "iana",
        extensions: ["seed", "dataless"]
      },
      "application/vnd.ffsns": {
        source: "iana"
      },
      "application/vnd.ficlab.flb+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.filmit.zfc": {
        source: "iana"
      },
      "application/vnd.fints": {
        source: "iana"
      },
      "application/vnd.firemonkeys.cloudcell": {
        source: "iana"
      },
      "application/vnd.flographit": {
        source: "iana",
        extensions: ["gph"]
      },
      "application/vnd.fluxtime.clip": {
        source: "iana",
        extensions: ["ftc"]
      },
      "application/vnd.font-fontforge-sfd": {
        source: "iana"
      },
      "application/vnd.framemaker": {
        source: "iana",
        extensions: ["fm", "frame", "maker", "book"]
      },
      "application/vnd.frogans.fnc": {
        source: "iana",
        extensions: ["fnc"]
      },
      "application/vnd.frogans.ltf": {
        source: "iana",
        extensions: ["ltf"]
      },
      "application/vnd.fsc.weblaunch": {
        source: "iana",
        extensions: ["fsc"]
      },
      "application/vnd.fujifilm.fb.docuworks": {
        source: "iana"
      },
      "application/vnd.fujifilm.fb.docuworks.binder": {
        source: "iana"
      },
      "application/vnd.fujifilm.fb.docuworks.container": {
        source: "iana"
      },
      "application/vnd.fujifilm.fb.jfi+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.fujitsu.oasys": {
        source: "iana",
        extensions: ["oas"]
      },
      "application/vnd.fujitsu.oasys2": {
        source: "iana",
        extensions: ["oa2"]
      },
      "application/vnd.fujitsu.oasys3": {
        source: "iana",
        extensions: ["oa3"]
      },
      "application/vnd.fujitsu.oasysgp": {
        source: "iana",
        extensions: ["fg5"]
      },
      "application/vnd.fujitsu.oasysprs": {
        source: "iana",
        extensions: ["bh2"]
      },
      "application/vnd.fujixerox.art-ex": {
        source: "iana"
      },
      "application/vnd.fujixerox.art4": {
        source: "iana"
      },
      "application/vnd.fujixerox.ddd": {
        source: "iana",
        extensions: ["ddd"]
      },
      "application/vnd.fujixerox.docuworks": {
        source: "iana",
        extensions: ["xdw"]
      },
      "application/vnd.fujixerox.docuworks.binder": {
        source: "iana",
        extensions: ["xbd"]
      },
      "application/vnd.fujixerox.docuworks.container": {
        source: "iana"
      },
      "application/vnd.fujixerox.hbpl": {
        source: "iana"
      },
      "application/vnd.fut-misnet": {
        source: "iana"
      },
      "application/vnd.futoin+cbor": {
        source: "iana"
      },
      "application/vnd.futoin+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.fuzzysheet": {
        source: "iana",
        extensions: ["fzs"]
      },
      "application/vnd.genomatix.tuxedo": {
        source: "iana",
        extensions: ["txd"]
      },
      "application/vnd.gentics.grd+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.geo+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.geocube+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.geogebra.file": {
        source: "iana",
        extensions: ["ggb"]
      },
      "application/vnd.geogebra.slides": {
        source: "iana"
      },
      "application/vnd.geogebra.tool": {
        source: "iana",
        extensions: ["ggt"]
      },
      "application/vnd.geometry-explorer": {
        source: "iana",
        extensions: ["gex", "gre"]
      },
      "application/vnd.geonext": {
        source: "iana",
        extensions: ["gxt"]
      },
      "application/vnd.geoplan": {
        source: "iana",
        extensions: ["g2w"]
      },
      "application/vnd.geospace": {
        source: "iana",
        extensions: ["g3w"]
      },
      "application/vnd.gerber": {
        source: "iana"
      },
      "application/vnd.globalplatform.card-content-mgt": {
        source: "iana"
      },
      "application/vnd.globalplatform.card-content-mgt-response": {
        source: "iana"
      },
      "application/vnd.gmx": {
        source: "iana",
        extensions: ["gmx"]
      },
      "application/vnd.google-apps.document": {
        compressible: false,
        extensions: ["gdoc"]
      },
      "application/vnd.google-apps.presentation": {
        compressible: false,
        extensions: ["gslides"]
      },
      "application/vnd.google-apps.spreadsheet": {
        compressible: false,
        extensions: ["gsheet"]
      },
      "application/vnd.google-earth.kml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["kml"]
      },
      "application/vnd.google-earth.kmz": {
        source: "iana",
        compressible: false,
        extensions: ["kmz"]
      },
      "application/vnd.gov.sk.e-form+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.gov.sk.e-form+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.gov.sk.xmldatacontainer+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.grafeq": {
        source: "iana",
        extensions: ["gqf", "gqs"]
      },
      "application/vnd.gridmp": {
        source: "iana"
      },
      "application/vnd.groove-account": {
        source: "iana",
        extensions: ["gac"]
      },
      "application/vnd.groove-help": {
        source: "iana",
        extensions: ["ghf"]
      },
      "application/vnd.groove-identity-message": {
        source: "iana",
        extensions: ["gim"]
      },
      "application/vnd.groove-injector": {
        source: "iana",
        extensions: ["grv"]
      },
      "application/vnd.groove-tool-message": {
        source: "iana",
        extensions: ["gtm"]
      },
      "application/vnd.groove-tool-template": {
        source: "iana",
        extensions: ["tpl"]
      },
      "application/vnd.groove-vcard": {
        source: "iana",
        extensions: ["vcg"]
      },
      "application/vnd.hal+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.hal+xml": {
        source: "iana",
        compressible: true,
        extensions: ["hal"]
      },
      "application/vnd.handheld-entertainment+xml": {
        source: "iana",
        compressible: true,
        extensions: ["zmm"]
      },
      "application/vnd.hbci": {
        source: "iana",
        extensions: ["hbci"]
      },
      "application/vnd.hc+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.hcl-bireports": {
        source: "iana"
      },
      "application/vnd.hdt": {
        source: "iana"
      },
      "application/vnd.heroku+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.hhe.lesson-player": {
        source: "iana",
        extensions: ["les"]
      },
      "application/vnd.hl7cda+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/vnd.hl7v2+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/vnd.hp-hpgl": {
        source: "iana",
        extensions: ["hpgl"]
      },
      "application/vnd.hp-hpid": {
        source: "iana",
        extensions: ["hpid"]
      },
      "application/vnd.hp-hps": {
        source: "iana",
        extensions: ["hps"]
      },
      "application/vnd.hp-jlyt": {
        source: "iana",
        extensions: ["jlt"]
      },
      "application/vnd.hp-pcl": {
        source: "iana",
        extensions: ["pcl"]
      },
      "application/vnd.hp-pclxl": {
        source: "iana",
        extensions: ["pclxl"]
      },
      "application/vnd.httphone": {
        source: "iana"
      },
      "application/vnd.hydrostatix.sof-data": {
        source: "iana",
        extensions: ["sfd-hdstx"]
      },
      "application/vnd.hyper+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.hyper-item+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.hyperdrive+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.hzn-3d-crossword": {
        source: "iana"
      },
      "application/vnd.ibm.afplinedata": {
        source: "iana"
      },
      "application/vnd.ibm.electronic-media": {
        source: "iana"
      },
      "application/vnd.ibm.minipay": {
        source: "iana",
        extensions: ["mpy"]
      },
      "application/vnd.ibm.modcap": {
        source: "iana",
        extensions: ["afp", "listafp", "list3820"]
      },
      "application/vnd.ibm.rights-management": {
        source: "iana",
        extensions: ["irm"]
      },
      "application/vnd.ibm.secure-container": {
        source: "iana",
        extensions: ["sc"]
      },
      "application/vnd.iccprofile": {
        source: "iana",
        extensions: ["icc", "icm"]
      },
      "application/vnd.ieee.1905": {
        source: "iana"
      },
      "application/vnd.igloader": {
        source: "iana",
        extensions: ["igl"]
      },
      "application/vnd.imagemeter.folder+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.imagemeter.image+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.immervision-ivp": {
        source: "iana",
        extensions: ["ivp"]
      },
      "application/vnd.immervision-ivu": {
        source: "iana",
        extensions: ["ivu"]
      },
      "application/vnd.ims.imsccv1p1": {
        source: "iana"
      },
      "application/vnd.ims.imsccv1p2": {
        source: "iana"
      },
      "application/vnd.ims.imsccv1p3": {
        source: "iana"
      },
      "application/vnd.ims.lis.v2.result+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ims.lti.v2.toolconsumerprofile+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ims.lti.v2.toolproxy+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ims.lti.v2.toolproxy.id+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ims.lti.v2.toolsettings+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ims.lti.v2.toolsettings.simple+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.informedcontrol.rms+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.informix-visionary": {
        source: "iana"
      },
      "application/vnd.infotech.project": {
        source: "iana"
      },
      "application/vnd.infotech.project+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.innopath.wamp.notification": {
        source: "iana"
      },
      "application/vnd.insors.igm": {
        source: "iana",
        extensions: ["igm"]
      },
      "application/vnd.intercon.formnet": {
        source: "iana",
        extensions: ["xpw", "xpx"]
      },
      "application/vnd.intergeo": {
        source: "iana",
        extensions: ["i2g"]
      },
      "application/vnd.intertrust.digibox": {
        source: "iana"
      },
      "application/vnd.intertrust.nncp": {
        source: "iana"
      },
      "application/vnd.intu.qbo": {
        source: "iana",
        extensions: ["qbo"]
      },
      "application/vnd.intu.qfx": {
        source: "iana",
        extensions: ["qfx"]
      },
      "application/vnd.iptc.g2.catalogitem+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.iptc.g2.conceptitem+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.iptc.g2.knowledgeitem+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.iptc.g2.newsitem+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.iptc.g2.newsmessage+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.iptc.g2.packageitem+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.iptc.g2.planningitem+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ipunplugged.rcprofile": {
        source: "iana",
        extensions: ["rcprofile"]
      },
      "application/vnd.irepository.package+xml": {
        source: "iana",
        compressible: true,
        extensions: ["irp"]
      },
      "application/vnd.is-xpr": {
        source: "iana",
        extensions: ["xpr"]
      },
      "application/vnd.isac.fcs": {
        source: "iana",
        extensions: ["fcs"]
      },
      "application/vnd.iso11783-10+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.jam": {
        source: "iana",
        extensions: ["jam"]
      },
      "application/vnd.japannet-directory-service": {
        source: "iana"
      },
      "application/vnd.japannet-jpnstore-wakeup": {
        source: "iana"
      },
      "application/vnd.japannet-payment-wakeup": {
        source: "iana"
      },
      "application/vnd.japannet-registration": {
        source: "iana"
      },
      "application/vnd.japannet-registration-wakeup": {
        source: "iana"
      },
      "application/vnd.japannet-setstore-wakeup": {
        source: "iana"
      },
      "application/vnd.japannet-verification": {
        source: "iana"
      },
      "application/vnd.japannet-verification-wakeup": {
        source: "iana"
      },
      "application/vnd.jcp.javame.midlet-rms": {
        source: "iana",
        extensions: ["rms"]
      },
      "application/vnd.jisp": {
        source: "iana",
        extensions: ["jisp"]
      },
      "application/vnd.joost.joda-archive": {
        source: "iana",
        extensions: ["joda"]
      },
      "application/vnd.jsk.isdn-ngn": {
        source: "iana"
      },
      "application/vnd.kahootz": {
        source: "iana",
        extensions: ["ktz", "ktr"]
      },
      "application/vnd.kde.karbon": {
        source: "iana",
        extensions: ["karbon"]
      },
      "application/vnd.kde.kchart": {
        source: "iana",
        extensions: ["chrt"]
      },
      "application/vnd.kde.kformula": {
        source: "iana",
        extensions: ["kfo"]
      },
      "application/vnd.kde.kivio": {
        source: "iana",
        extensions: ["flw"]
      },
      "application/vnd.kde.kontour": {
        source: "iana",
        extensions: ["kon"]
      },
      "application/vnd.kde.kpresenter": {
        source: "iana",
        extensions: ["kpr", "kpt"]
      },
      "application/vnd.kde.kspread": {
        source: "iana",
        extensions: ["ksp"]
      },
      "application/vnd.kde.kword": {
        source: "iana",
        extensions: ["kwd", "kwt"]
      },
      "application/vnd.kenameaapp": {
        source: "iana",
        extensions: ["htke"]
      },
      "application/vnd.kidspiration": {
        source: "iana",
        extensions: ["kia"]
      },
      "application/vnd.kinar": {
        source: "iana",
        extensions: ["kne", "knp"]
      },
      "application/vnd.koan": {
        source: "iana",
        extensions: ["skp", "skd", "skt", "skm"]
      },
      "application/vnd.kodak-descriptor": {
        source: "iana",
        extensions: ["sse"]
      },
      "application/vnd.las": {
        source: "iana"
      },
      "application/vnd.las.las+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.las.las+xml": {
        source: "iana",
        compressible: true,
        extensions: ["lasxml"]
      },
      "application/vnd.laszip": {
        source: "iana"
      },
      "application/vnd.leap+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.liberty-request+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.llamagraphics.life-balance.desktop": {
        source: "iana",
        extensions: ["lbd"]
      },
      "application/vnd.llamagraphics.life-balance.exchange+xml": {
        source: "iana",
        compressible: true,
        extensions: ["lbe"]
      },
      "application/vnd.logipipe.circuit+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.loom": {
        source: "iana"
      },
      "application/vnd.lotus-1-2-3": {
        source: "iana",
        extensions: ["123"]
      },
      "application/vnd.lotus-approach": {
        source: "iana",
        extensions: ["apr"]
      },
      "application/vnd.lotus-freelance": {
        source: "iana",
        extensions: ["pre"]
      },
      "application/vnd.lotus-notes": {
        source: "iana",
        extensions: ["nsf"]
      },
      "application/vnd.lotus-organizer": {
        source: "iana",
        extensions: ["org"]
      },
      "application/vnd.lotus-screencam": {
        source: "iana",
        extensions: ["scm"]
      },
      "application/vnd.lotus-wordpro": {
        source: "iana",
        extensions: ["lwp"]
      },
      "application/vnd.macports.portpkg": {
        source: "iana",
        extensions: ["portpkg"]
      },
      "application/vnd.mapbox-vector-tile": {
        source: "iana",
        extensions: ["mvt"]
      },
      "application/vnd.marlin.drm.actiontoken+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.marlin.drm.conftoken+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.marlin.drm.license+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.marlin.drm.mdcf": {
        source: "iana"
      },
      "application/vnd.mason+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.maxar.archive.3tz+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.maxmind.maxmind-db": {
        source: "iana"
      },
      "application/vnd.mcd": {
        source: "iana",
        extensions: ["mcd"]
      },
      "application/vnd.medcalcdata": {
        source: "iana",
        extensions: ["mc1"]
      },
      "application/vnd.mediastation.cdkey": {
        source: "iana",
        extensions: ["cdkey"]
      },
      "application/vnd.meridian-slingshot": {
        source: "iana"
      },
      "application/vnd.mfer": {
        source: "iana",
        extensions: ["mwf"]
      },
      "application/vnd.mfmp": {
        source: "iana",
        extensions: ["mfm"]
      },
      "application/vnd.micro+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.micrografx.flo": {
        source: "iana",
        extensions: ["flo"]
      },
      "application/vnd.micrografx.igx": {
        source: "iana",
        extensions: ["igx"]
      },
      "application/vnd.microsoft.portable-executable": {
        source: "iana"
      },
      "application/vnd.microsoft.windows.thumbnail-cache": {
        source: "iana"
      },
      "application/vnd.miele+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.mif": {
        source: "iana",
        extensions: ["mif"]
      },
      "application/vnd.minisoft-hp3000-save": {
        source: "iana"
      },
      "application/vnd.mitsubishi.misty-guard.trustweb": {
        source: "iana"
      },
      "application/vnd.mobius.daf": {
        source: "iana",
        extensions: ["daf"]
      },
      "application/vnd.mobius.dis": {
        source: "iana",
        extensions: ["dis"]
      },
      "application/vnd.mobius.mbk": {
        source: "iana",
        extensions: ["mbk"]
      },
      "application/vnd.mobius.mqy": {
        source: "iana",
        extensions: ["mqy"]
      },
      "application/vnd.mobius.msl": {
        source: "iana",
        extensions: ["msl"]
      },
      "application/vnd.mobius.plc": {
        source: "iana",
        extensions: ["plc"]
      },
      "application/vnd.mobius.txf": {
        source: "iana",
        extensions: ["txf"]
      },
      "application/vnd.mophun.application": {
        source: "iana",
        extensions: ["mpn"]
      },
      "application/vnd.mophun.certificate": {
        source: "iana",
        extensions: ["mpc"]
      },
      "application/vnd.motorola.flexsuite": {
        source: "iana"
      },
      "application/vnd.motorola.flexsuite.adsi": {
        source: "iana"
      },
      "application/vnd.motorola.flexsuite.fis": {
        source: "iana"
      },
      "application/vnd.motorola.flexsuite.gotap": {
        source: "iana"
      },
      "application/vnd.motorola.flexsuite.kmr": {
        source: "iana"
      },
      "application/vnd.motorola.flexsuite.ttc": {
        source: "iana"
      },
      "application/vnd.motorola.flexsuite.wem": {
        source: "iana"
      },
      "application/vnd.motorola.iprm": {
        source: "iana"
      },
      "application/vnd.mozilla.xul+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xul"]
      },
      "application/vnd.ms-3mfdocument": {
        source: "iana"
      },
      "application/vnd.ms-artgalry": {
        source: "iana",
        extensions: ["cil"]
      },
      "application/vnd.ms-asf": {
        source: "iana"
      },
      "application/vnd.ms-cab-compressed": {
        source: "iana",
        extensions: ["cab"]
      },
      "application/vnd.ms-color.iccprofile": {
        source: "apache"
      },
      "application/vnd.ms-excel": {
        source: "iana",
        compressible: false,
        extensions: ["xls", "xlm", "xla", "xlc", "xlt", "xlw"]
      },
      "application/vnd.ms-excel.addin.macroenabled.12": {
        source: "iana",
        extensions: ["xlam"]
      },
      "application/vnd.ms-excel.sheet.binary.macroenabled.12": {
        source: "iana",
        extensions: ["xlsb"]
      },
      "application/vnd.ms-excel.sheet.macroenabled.12": {
        source: "iana",
        extensions: ["xlsm"]
      },
      "application/vnd.ms-excel.template.macroenabled.12": {
        source: "iana",
        extensions: ["xltm"]
      },
      "application/vnd.ms-fontobject": {
        source: "iana",
        compressible: true,
        extensions: ["eot"]
      },
      "application/vnd.ms-htmlhelp": {
        source: "iana",
        extensions: ["chm"]
      },
      "application/vnd.ms-ims": {
        source: "iana",
        extensions: ["ims"]
      },
      "application/vnd.ms-lrm": {
        source: "iana",
        extensions: ["lrm"]
      },
      "application/vnd.ms-office.activex+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ms-officetheme": {
        source: "iana",
        extensions: ["thmx"]
      },
      "application/vnd.ms-opentype": {
        source: "apache",
        compressible: true
      },
      "application/vnd.ms-outlook": {
        compressible: false,
        extensions: ["msg"]
      },
      "application/vnd.ms-package.obfuscated-opentype": {
        source: "apache"
      },
      "application/vnd.ms-pki.seccat": {
        source: "apache",
        extensions: ["cat"]
      },
      "application/vnd.ms-pki.stl": {
        source: "apache",
        extensions: ["stl"]
      },
      "application/vnd.ms-playready.initiator+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ms-powerpoint": {
        source: "iana",
        compressible: false,
        extensions: ["ppt", "pps", "pot"]
      },
      "application/vnd.ms-powerpoint.addin.macroenabled.12": {
        source: "iana",
        extensions: ["ppam"]
      },
      "application/vnd.ms-powerpoint.presentation.macroenabled.12": {
        source: "iana",
        extensions: ["pptm"]
      },
      "application/vnd.ms-powerpoint.slide.macroenabled.12": {
        source: "iana",
        extensions: ["sldm"]
      },
      "application/vnd.ms-powerpoint.slideshow.macroenabled.12": {
        source: "iana",
        extensions: ["ppsm"]
      },
      "application/vnd.ms-powerpoint.template.macroenabled.12": {
        source: "iana",
        extensions: ["potm"]
      },
      "application/vnd.ms-printdevicecapabilities+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ms-printing.printticket+xml": {
        source: "apache",
        compressible: true
      },
      "application/vnd.ms-printschematicket+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ms-project": {
        source: "iana",
        extensions: ["mpp", "mpt"]
      },
      "application/vnd.ms-tnef": {
        source: "iana"
      },
      "application/vnd.ms-windows.devicepairing": {
        source: "iana"
      },
      "application/vnd.ms-windows.nwprinting.oob": {
        source: "iana"
      },
      "application/vnd.ms-windows.printerpairing": {
        source: "iana"
      },
      "application/vnd.ms-windows.wsd.oob": {
        source: "iana"
      },
      "application/vnd.ms-wmdrm.lic-chlg-req": {
        source: "iana"
      },
      "application/vnd.ms-wmdrm.lic-resp": {
        source: "iana"
      },
      "application/vnd.ms-wmdrm.meter-chlg-req": {
        source: "iana"
      },
      "application/vnd.ms-wmdrm.meter-resp": {
        source: "iana"
      },
      "application/vnd.ms-word.document.macroenabled.12": {
        source: "iana",
        extensions: ["docm"]
      },
      "application/vnd.ms-word.template.macroenabled.12": {
        source: "iana",
        extensions: ["dotm"]
      },
      "application/vnd.ms-works": {
        source: "iana",
        extensions: ["wps", "wks", "wcm", "wdb"]
      },
      "application/vnd.ms-wpl": {
        source: "iana",
        extensions: ["wpl"]
      },
      "application/vnd.ms-xpsdocument": {
        source: "iana",
        compressible: false,
        extensions: ["xps"]
      },
      "application/vnd.msa-disk-image": {
        source: "iana"
      },
      "application/vnd.mseq": {
        source: "iana",
        extensions: ["mseq"]
      },
      "application/vnd.msign": {
        source: "iana"
      },
      "application/vnd.multiad.creator": {
        source: "iana"
      },
      "application/vnd.multiad.creator.cif": {
        source: "iana"
      },
      "application/vnd.music-niff": {
        source: "iana"
      },
      "application/vnd.musician": {
        source: "iana",
        extensions: ["mus"]
      },
      "application/vnd.muvee.style": {
        source: "iana",
        extensions: ["msty"]
      },
      "application/vnd.mynfc": {
        source: "iana",
        extensions: ["taglet"]
      },
      "application/vnd.nacamar.ybrid+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ncd.control": {
        source: "iana"
      },
      "application/vnd.ncd.reference": {
        source: "iana"
      },
      "application/vnd.nearst.inv+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.nebumind.line": {
        source: "iana"
      },
      "application/vnd.nervana": {
        source: "iana"
      },
      "application/vnd.netfpx": {
        source: "iana"
      },
      "application/vnd.neurolanguage.nlu": {
        source: "iana",
        extensions: ["nlu"]
      },
      "application/vnd.nimn": {
        source: "iana"
      },
      "application/vnd.nintendo.nitro.rom": {
        source: "iana"
      },
      "application/vnd.nintendo.snes.rom": {
        source: "iana"
      },
      "application/vnd.nitf": {
        source: "iana",
        extensions: ["ntf", "nitf"]
      },
      "application/vnd.noblenet-directory": {
        source: "iana",
        extensions: ["nnd"]
      },
      "application/vnd.noblenet-sealer": {
        source: "iana",
        extensions: ["nns"]
      },
      "application/vnd.noblenet-web": {
        source: "iana",
        extensions: ["nnw"]
      },
      "application/vnd.nokia.catalogs": {
        source: "iana"
      },
      "application/vnd.nokia.conml+wbxml": {
        source: "iana"
      },
      "application/vnd.nokia.conml+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.nokia.iptv.config+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.nokia.isds-radio-presets": {
        source: "iana"
      },
      "application/vnd.nokia.landmark+wbxml": {
        source: "iana"
      },
      "application/vnd.nokia.landmark+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.nokia.landmarkcollection+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.nokia.n-gage.ac+xml": {
        source: "iana",
        compressible: true,
        extensions: ["ac"]
      },
      "application/vnd.nokia.n-gage.data": {
        source: "iana",
        extensions: ["ngdat"]
      },
      "application/vnd.nokia.n-gage.symbian.install": {
        source: "iana",
        extensions: ["n-gage"]
      },
      "application/vnd.nokia.ncd": {
        source: "iana"
      },
      "application/vnd.nokia.pcd+wbxml": {
        source: "iana"
      },
      "application/vnd.nokia.pcd+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.nokia.radio-preset": {
        source: "iana",
        extensions: ["rpst"]
      },
      "application/vnd.nokia.radio-presets": {
        source: "iana",
        extensions: ["rpss"]
      },
      "application/vnd.novadigm.edm": {
        source: "iana",
        extensions: ["edm"]
      },
      "application/vnd.novadigm.edx": {
        source: "iana",
        extensions: ["edx"]
      },
      "application/vnd.novadigm.ext": {
        source: "iana",
        extensions: ["ext"]
      },
      "application/vnd.ntt-local.content-share": {
        source: "iana"
      },
      "application/vnd.ntt-local.file-transfer": {
        source: "iana"
      },
      "application/vnd.ntt-local.ogw_remote-access": {
        source: "iana"
      },
      "application/vnd.ntt-local.sip-ta_remote": {
        source: "iana"
      },
      "application/vnd.ntt-local.sip-ta_tcp_stream": {
        source: "iana"
      },
      "application/vnd.oasis.opendocument.chart": {
        source: "iana",
        extensions: ["odc"]
      },
      "application/vnd.oasis.opendocument.chart-template": {
        source: "iana",
        extensions: ["otc"]
      },
      "application/vnd.oasis.opendocument.database": {
        source: "iana",
        extensions: ["odb"]
      },
      "application/vnd.oasis.opendocument.formula": {
        source: "iana",
        extensions: ["odf"]
      },
      "application/vnd.oasis.opendocument.formula-template": {
        source: "iana",
        extensions: ["odft"]
      },
      "application/vnd.oasis.opendocument.graphics": {
        source: "iana",
        compressible: false,
        extensions: ["odg"]
      },
      "application/vnd.oasis.opendocument.graphics-template": {
        source: "iana",
        extensions: ["otg"]
      },
      "application/vnd.oasis.opendocument.image": {
        source: "iana",
        extensions: ["odi"]
      },
      "application/vnd.oasis.opendocument.image-template": {
        source: "iana",
        extensions: ["oti"]
      },
      "application/vnd.oasis.opendocument.presentation": {
        source: "iana",
        compressible: false,
        extensions: ["odp"]
      },
      "application/vnd.oasis.opendocument.presentation-template": {
        source: "iana",
        extensions: ["otp"]
      },
      "application/vnd.oasis.opendocument.spreadsheet": {
        source: "iana",
        compressible: false,
        extensions: ["ods"]
      },
      "application/vnd.oasis.opendocument.spreadsheet-template": {
        source: "iana",
        extensions: ["ots"]
      },
      "application/vnd.oasis.opendocument.text": {
        source: "iana",
        compressible: false,
        extensions: ["odt"]
      },
      "application/vnd.oasis.opendocument.text-master": {
        source: "iana",
        extensions: ["odm"]
      },
      "application/vnd.oasis.opendocument.text-template": {
        source: "iana",
        extensions: ["ott"]
      },
      "application/vnd.oasis.opendocument.text-web": {
        source: "iana",
        extensions: ["oth"]
      },
      "application/vnd.obn": {
        source: "iana"
      },
      "application/vnd.ocf+cbor": {
        source: "iana"
      },
      "application/vnd.oci.image.manifest.v1+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oftn.l10n+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oipf.contentaccessdownload+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oipf.contentaccessstreaming+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oipf.cspg-hexbinary": {
        source: "iana"
      },
      "application/vnd.oipf.dae.svg+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oipf.dae.xhtml+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oipf.mippvcontrolmessage+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oipf.pae.gem": {
        source: "iana"
      },
      "application/vnd.oipf.spdiscovery+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oipf.spdlist+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oipf.ueprofile+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oipf.userprofile+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.olpc-sugar": {
        source: "iana",
        extensions: ["xo"]
      },
      "application/vnd.oma-scws-config": {
        source: "iana"
      },
      "application/vnd.oma-scws-http-request": {
        source: "iana"
      },
      "application/vnd.oma-scws-http-response": {
        source: "iana"
      },
      "application/vnd.oma.bcast.associated-procedure-parameter+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.bcast.drm-trigger+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.bcast.imd+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.bcast.ltkm": {
        source: "iana"
      },
      "application/vnd.oma.bcast.notification+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.bcast.provisioningtrigger": {
        source: "iana"
      },
      "application/vnd.oma.bcast.sgboot": {
        source: "iana"
      },
      "application/vnd.oma.bcast.sgdd+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.bcast.sgdu": {
        source: "iana"
      },
      "application/vnd.oma.bcast.simple-symbol-container": {
        source: "iana"
      },
      "application/vnd.oma.bcast.smartcard-trigger+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.bcast.sprov+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.bcast.stkm": {
        source: "iana"
      },
      "application/vnd.oma.cab-address-book+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.cab-feature-handler+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.cab-pcc+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.cab-subs-invite+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.cab-user-prefs+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.dcd": {
        source: "iana"
      },
      "application/vnd.oma.dcdc": {
        source: "iana"
      },
      "application/vnd.oma.dd2+xml": {
        source: "iana",
        compressible: true,
        extensions: ["dd2"]
      },
      "application/vnd.oma.drm.risd+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.group-usage-list+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.lwm2m+cbor": {
        source: "iana"
      },
      "application/vnd.oma.lwm2m+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.lwm2m+tlv": {
        source: "iana"
      },
      "application/vnd.oma.pal+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.poc.detailed-progress-report+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.poc.final-report+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.poc.groups+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.poc.invocation-descriptor+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.poc.optimized-progress-report+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.push": {
        source: "iana"
      },
      "application/vnd.oma.scidm.messages+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.xcap-directory+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.omads-email+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/vnd.omads-file+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/vnd.omads-folder+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/vnd.omaloc-supl-init": {
        source: "iana"
      },
      "application/vnd.onepager": {
        source: "iana"
      },
      "application/vnd.onepagertamp": {
        source: "iana"
      },
      "application/vnd.onepagertamx": {
        source: "iana"
      },
      "application/vnd.onepagertat": {
        source: "iana"
      },
      "application/vnd.onepagertatp": {
        source: "iana"
      },
      "application/vnd.onepagertatx": {
        source: "iana"
      },
      "application/vnd.openblox.game+xml": {
        source: "iana",
        compressible: true,
        extensions: ["obgx"]
      },
      "application/vnd.openblox.game-binary": {
        source: "iana"
      },
      "application/vnd.openeye.oeb": {
        source: "iana"
      },
      "application/vnd.openofficeorg.extension": {
        source: "apache",
        extensions: ["oxt"]
      },
      "application/vnd.openstreetmap.data+xml": {
        source: "iana",
        compressible: true,
        extensions: ["osm"]
      },
      "application/vnd.opentimestamps.ots": {
        source: "iana"
      },
      "application/vnd.openxmlformats-officedocument.custom-properties+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.customxmlproperties+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.drawing+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.drawingml.chart+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.drawingml.chartshapes+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.drawingml.diagramcolors+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.drawingml.diagramdata+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.drawingml.diagramlayout+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.drawingml.diagramstyle+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.extended-properties+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.commentauthors+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.comments+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.handoutmaster+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.notesmaster+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.notesslide+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.presentation": {
        source: "iana",
        compressible: false,
        extensions: ["pptx"]
      },
      "application/vnd.openxmlformats-officedocument.presentationml.presentation.main+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.presprops+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.slide": {
        source: "iana",
        extensions: ["sldx"]
      },
      "application/vnd.openxmlformats-officedocument.presentationml.slide+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.slidelayout+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.slidemaster+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.slideshow": {
        source: "iana",
        extensions: ["ppsx"]
      },
      "application/vnd.openxmlformats-officedocument.presentationml.slideshow.main+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.slideupdateinfo+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.tablestyles+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.tags+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.template": {
        source: "iana",
        extensions: ["potx"]
      },
      "application/vnd.openxmlformats-officedocument.presentationml.template.main+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.viewprops+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.calcchain+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.chartsheet+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.comments+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.connections+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.dialogsheet+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.externallink+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.pivotcachedefinition+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.pivotcacherecords+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.pivottable+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.querytable+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.revisionheaders+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.revisionlog+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.sharedstrings+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet": {
        source: "iana",
        compressible: false,
        extensions: ["xlsx"]
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet.main+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.sheetmetadata+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.styles+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.table+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.tablesinglecells+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.template": {
        source: "iana",
        extensions: ["xltx"]
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.template.main+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.usernames+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.volatiledependencies+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.worksheet+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.theme+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.themeoverride+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.vmldrawing": {
        source: "iana"
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.comments+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.document": {
        source: "iana",
        compressible: false,
        extensions: ["docx"]
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.document.glossary+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.document.main+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.endnotes+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.fonttable+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.footer+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.footnotes+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.numbering+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.settings+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.styles+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.template": {
        source: "iana",
        extensions: ["dotx"]
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.template.main+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.websettings+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-package.core-properties+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-package.digital-signature-xmlsignature+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-package.relationships+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oracle.resource+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.orange.indata": {
        source: "iana"
      },
      "application/vnd.osa.netdeploy": {
        source: "iana"
      },
      "application/vnd.osgeo.mapguide.package": {
        source: "iana",
        extensions: ["mgp"]
      },
      "application/vnd.osgi.bundle": {
        source: "iana"
      },
      "application/vnd.osgi.dp": {
        source: "iana",
        extensions: ["dp"]
      },
      "application/vnd.osgi.subsystem": {
        source: "iana",
        extensions: ["esa"]
      },
      "application/vnd.otps.ct-kip+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oxli.countgraph": {
        source: "iana"
      },
      "application/vnd.pagerduty+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.palm": {
        source: "iana",
        extensions: ["pdb", "pqa", "oprc"]
      },
      "application/vnd.panoply": {
        source: "iana"
      },
      "application/vnd.paos.xml": {
        source: "iana"
      },
      "application/vnd.patentdive": {
        source: "iana"
      },
      "application/vnd.patientecommsdoc": {
        source: "iana"
      },
      "application/vnd.pawaafile": {
        source: "iana",
        extensions: ["paw"]
      },
      "application/vnd.pcos": {
        source: "iana"
      },
      "application/vnd.pg.format": {
        source: "iana",
        extensions: ["str"]
      },
      "application/vnd.pg.osasli": {
        source: "iana",
        extensions: ["ei6"]
      },
      "application/vnd.piaccess.application-licence": {
        source: "iana"
      },
      "application/vnd.picsel": {
        source: "iana",
        extensions: ["efif"]
      },
      "application/vnd.pmi.widget": {
        source: "iana",
        extensions: ["wg"]
      },
      "application/vnd.poc.group-advertisement+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.pocketlearn": {
        source: "iana",
        extensions: ["plf"]
      },
      "application/vnd.powerbuilder6": {
        source: "iana",
        extensions: ["pbd"]
      },
      "application/vnd.powerbuilder6-s": {
        source: "iana"
      },
      "application/vnd.powerbuilder7": {
        source: "iana"
      },
      "application/vnd.powerbuilder7-s": {
        source: "iana"
      },
      "application/vnd.powerbuilder75": {
        source: "iana"
      },
      "application/vnd.powerbuilder75-s": {
        source: "iana"
      },
      "application/vnd.preminet": {
        source: "iana"
      },
      "application/vnd.previewsystems.box": {
        source: "iana",
        extensions: ["box"]
      },
      "application/vnd.proteus.magazine": {
        source: "iana",
        extensions: ["mgz"]
      },
      "application/vnd.psfs": {
        source: "iana"
      },
      "application/vnd.publishare-delta-tree": {
        source: "iana",
        extensions: ["qps"]
      },
      "application/vnd.pvi.ptid1": {
        source: "iana",
        extensions: ["ptid"]
      },
      "application/vnd.pwg-multiplexed": {
        source: "iana"
      },
      "application/vnd.pwg-xhtml-print+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.qualcomm.brew-app-res": {
        source: "iana"
      },
      "application/vnd.quarantainenet": {
        source: "iana"
      },
      "application/vnd.quark.quarkxpress": {
        source: "iana",
        extensions: ["qxd", "qxt", "qwd", "qwt", "qxl", "qxb"]
      },
      "application/vnd.quobject-quoxdocument": {
        source: "iana"
      },
      "application/vnd.radisys.moml+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-audit+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-audit-conf+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-audit-conn+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-audit-dialog+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-audit-stream+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-conf+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-dialog+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-dialog-base+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-dialog-fax-detect+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-dialog-fax-sendrecv+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-dialog-group+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-dialog-speech+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-dialog-transform+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.rainstor.data": {
        source: "iana"
      },
      "application/vnd.rapid": {
        source: "iana"
      },
      "application/vnd.rar": {
        source: "iana",
        extensions: ["rar"]
      },
      "application/vnd.realvnc.bed": {
        source: "iana",
        extensions: ["bed"]
      },
      "application/vnd.recordare.musicxml": {
        source: "iana",
        extensions: ["mxl"]
      },
      "application/vnd.recordare.musicxml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["musicxml"]
      },
      "application/vnd.renlearn.rlprint": {
        source: "iana"
      },
      "application/vnd.resilient.logic": {
        source: "iana"
      },
      "application/vnd.restful+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.rig.cryptonote": {
        source: "iana",
        extensions: ["cryptonote"]
      },
      "application/vnd.rim.cod": {
        source: "apache",
        extensions: ["cod"]
      },
      "application/vnd.rn-realmedia": {
        source: "apache",
        extensions: ["rm"]
      },
      "application/vnd.rn-realmedia-vbr": {
        source: "apache",
        extensions: ["rmvb"]
      },
      "application/vnd.route66.link66+xml": {
        source: "iana",
        compressible: true,
        extensions: ["link66"]
      },
      "application/vnd.rs-274x": {
        source: "iana"
      },
      "application/vnd.ruckus.download": {
        source: "iana"
      },
      "application/vnd.s3sms": {
        source: "iana"
      },
      "application/vnd.sailingtracker.track": {
        source: "iana",
        extensions: ["st"]
      },
      "application/vnd.sar": {
        source: "iana"
      },
      "application/vnd.sbm.cid": {
        source: "iana"
      },
      "application/vnd.sbm.mid2": {
        source: "iana"
      },
      "application/vnd.scribus": {
        source: "iana"
      },
      "application/vnd.sealed.3df": {
        source: "iana"
      },
      "application/vnd.sealed.csf": {
        source: "iana"
      },
      "application/vnd.sealed.doc": {
        source: "iana"
      },
      "application/vnd.sealed.eml": {
        source: "iana"
      },
      "application/vnd.sealed.mht": {
        source: "iana"
      },
      "application/vnd.sealed.net": {
        source: "iana"
      },
      "application/vnd.sealed.ppt": {
        source: "iana"
      },
      "application/vnd.sealed.tiff": {
        source: "iana"
      },
      "application/vnd.sealed.xls": {
        source: "iana"
      },
      "application/vnd.sealedmedia.softseal.html": {
        source: "iana"
      },
      "application/vnd.sealedmedia.softseal.pdf": {
        source: "iana"
      },
      "application/vnd.seemail": {
        source: "iana",
        extensions: ["see"]
      },
      "application/vnd.seis+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.sema": {
        source: "iana",
        extensions: ["sema"]
      },
      "application/vnd.semd": {
        source: "iana",
        extensions: ["semd"]
      },
      "application/vnd.semf": {
        source: "iana",
        extensions: ["semf"]
      },
      "application/vnd.shade-save-file": {
        source: "iana"
      },
      "application/vnd.shana.informed.formdata": {
        source: "iana",
        extensions: ["ifm"]
      },
      "application/vnd.shana.informed.formtemplate": {
        source: "iana",
        extensions: ["itp"]
      },
      "application/vnd.shana.informed.interchange": {
        source: "iana",
        extensions: ["iif"]
      },
      "application/vnd.shana.informed.package": {
        source: "iana",
        extensions: ["ipk"]
      },
      "application/vnd.shootproof+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.shopkick+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.shp": {
        source: "iana"
      },
      "application/vnd.shx": {
        source: "iana"
      },
      "application/vnd.sigrok.session": {
        source: "iana"
      },
      "application/vnd.simtech-mindmapper": {
        source: "iana",
        extensions: ["twd", "twds"]
      },
      "application/vnd.siren+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.smaf": {
        source: "iana",
        extensions: ["mmf"]
      },
      "application/vnd.smart.notebook": {
        source: "iana"
      },
      "application/vnd.smart.teacher": {
        source: "iana",
        extensions: ["teacher"]
      },
      "application/vnd.snesdev-page-table": {
        source: "iana"
      },
      "application/vnd.software602.filler.form+xml": {
        source: "iana",
        compressible: true,
        extensions: ["fo"]
      },
      "application/vnd.software602.filler.form-xml-zip": {
        source: "iana"
      },
      "application/vnd.solent.sdkm+xml": {
        source: "iana",
        compressible: true,
        extensions: ["sdkm", "sdkd"]
      },
      "application/vnd.spotfire.dxp": {
        source: "iana",
        extensions: ["dxp"]
      },
      "application/vnd.spotfire.sfs": {
        source: "iana",
        extensions: ["sfs"]
      },
      "application/vnd.sqlite3": {
        source: "iana"
      },
      "application/vnd.sss-cod": {
        source: "iana"
      },
      "application/vnd.sss-dtf": {
        source: "iana"
      },
      "application/vnd.sss-ntf": {
        source: "iana"
      },
      "application/vnd.stardivision.calc": {
        source: "apache",
        extensions: ["sdc"]
      },
      "application/vnd.stardivision.draw": {
        source: "apache",
        extensions: ["sda"]
      },
      "application/vnd.stardivision.impress": {
        source: "apache",
        extensions: ["sdd"]
      },
      "application/vnd.stardivision.math": {
        source: "apache",
        extensions: ["smf"]
      },
      "application/vnd.stardivision.writer": {
        source: "apache",
        extensions: ["sdw", "vor"]
      },
      "application/vnd.stardivision.writer-global": {
        source: "apache",
        extensions: ["sgl"]
      },
      "application/vnd.stepmania.package": {
        source: "iana",
        extensions: ["smzip"]
      },
      "application/vnd.stepmania.stepchart": {
        source: "iana",
        extensions: ["sm"]
      },
      "application/vnd.street-stream": {
        source: "iana"
      },
      "application/vnd.sun.wadl+xml": {
        source: "iana",
        compressible: true,
        extensions: ["wadl"]
      },
      "application/vnd.sun.xml.calc": {
        source: "apache",
        extensions: ["sxc"]
      },
      "application/vnd.sun.xml.calc.template": {
        source: "apache",
        extensions: ["stc"]
      },
      "application/vnd.sun.xml.draw": {
        source: "apache",
        extensions: ["sxd"]
      },
      "application/vnd.sun.xml.draw.template": {
        source: "apache",
        extensions: ["std"]
      },
      "application/vnd.sun.xml.impress": {
        source: "apache",
        extensions: ["sxi"]
      },
      "application/vnd.sun.xml.impress.template": {
        source: "apache",
        extensions: ["sti"]
      },
      "application/vnd.sun.xml.math": {
        source: "apache",
        extensions: ["sxm"]
      },
      "application/vnd.sun.xml.writer": {
        source: "apache",
        extensions: ["sxw"]
      },
      "application/vnd.sun.xml.writer.global": {
        source: "apache",
        extensions: ["sxg"]
      },
      "application/vnd.sun.xml.writer.template": {
        source: "apache",
        extensions: ["stw"]
      },
      "application/vnd.sus-calendar": {
        source: "iana",
        extensions: ["sus", "susp"]
      },
      "application/vnd.svd": {
        source: "iana",
        extensions: ["svd"]
      },
      "application/vnd.swiftview-ics": {
        source: "iana"
      },
      "application/vnd.sycle+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.syft+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.symbian.install": {
        source: "apache",
        extensions: ["sis", "sisx"]
      },
      "application/vnd.syncml+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true,
        extensions: ["xsm"]
      },
      "application/vnd.syncml.dm+wbxml": {
        source: "iana",
        charset: "UTF-8",
        extensions: ["bdm"]
      },
      "application/vnd.syncml.dm+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true,
        extensions: ["xdm"]
      },
      "application/vnd.syncml.dm.notification": {
        source: "iana"
      },
      "application/vnd.syncml.dmddf+wbxml": {
        source: "iana"
      },
      "application/vnd.syncml.dmddf+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true,
        extensions: ["ddf"]
      },
      "application/vnd.syncml.dmtnds+wbxml": {
        source: "iana"
      },
      "application/vnd.syncml.dmtnds+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/vnd.syncml.ds.notification": {
        source: "iana"
      },
      "application/vnd.tableschema+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.tao.intent-module-archive": {
        source: "iana",
        extensions: ["tao"]
      },
      "application/vnd.tcpdump.pcap": {
        source: "iana",
        extensions: ["pcap", "cap", "dmp"]
      },
      "application/vnd.think-cell.ppttc+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.tmd.mediaflex.api+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.tml": {
        source: "iana"
      },
      "application/vnd.tmobile-livetv": {
        source: "iana",
        extensions: ["tmo"]
      },
      "application/vnd.tri.onesource": {
        source: "iana"
      },
      "application/vnd.trid.tpt": {
        source: "iana",
        extensions: ["tpt"]
      },
      "application/vnd.triscape.mxs": {
        source: "iana",
        extensions: ["mxs"]
      },
      "application/vnd.trueapp": {
        source: "iana",
        extensions: ["tra"]
      },
      "application/vnd.truedoc": {
        source: "iana"
      },
      "application/vnd.ubisoft.webplayer": {
        source: "iana"
      },
      "application/vnd.ufdl": {
        source: "iana",
        extensions: ["ufd", "ufdl"]
      },
      "application/vnd.uiq.theme": {
        source: "iana",
        extensions: ["utz"]
      },
      "application/vnd.umajin": {
        source: "iana",
        extensions: ["umj"]
      },
      "application/vnd.unity": {
        source: "iana",
        extensions: ["unityweb"]
      },
      "application/vnd.uoml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["uoml"]
      },
      "application/vnd.uplanet.alert": {
        source: "iana"
      },
      "application/vnd.uplanet.alert-wbxml": {
        source: "iana"
      },
      "application/vnd.uplanet.bearer-choice": {
        source: "iana"
      },
      "application/vnd.uplanet.bearer-choice-wbxml": {
        source: "iana"
      },
      "application/vnd.uplanet.cacheop": {
        source: "iana"
      },
      "application/vnd.uplanet.cacheop-wbxml": {
        source: "iana"
      },
      "application/vnd.uplanet.channel": {
        source: "iana"
      },
      "application/vnd.uplanet.channel-wbxml": {
        source: "iana"
      },
      "application/vnd.uplanet.list": {
        source: "iana"
      },
      "application/vnd.uplanet.list-wbxml": {
        source: "iana"
      },
      "application/vnd.uplanet.listcmd": {
        source: "iana"
      },
      "application/vnd.uplanet.listcmd-wbxml": {
        source: "iana"
      },
      "application/vnd.uplanet.signal": {
        source: "iana"
      },
      "application/vnd.uri-map": {
        source: "iana"
      },
      "application/vnd.valve.source.material": {
        source: "iana"
      },
      "application/vnd.vcx": {
        source: "iana",
        extensions: ["vcx"]
      },
      "application/vnd.vd-study": {
        source: "iana"
      },
      "application/vnd.vectorworks": {
        source: "iana"
      },
      "application/vnd.vel+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.verimatrix.vcas": {
        source: "iana"
      },
      "application/vnd.veritone.aion+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.veryant.thin": {
        source: "iana"
      },
      "application/vnd.ves.encrypted": {
        source: "iana"
      },
      "application/vnd.vidsoft.vidconference": {
        source: "iana"
      },
      "application/vnd.visio": {
        source: "iana",
        extensions: ["vsd", "vst", "vss", "vsw"]
      },
      "application/vnd.visionary": {
        source: "iana",
        extensions: ["vis"]
      },
      "application/vnd.vividence.scriptfile": {
        source: "iana"
      },
      "application/vnd.vsf": {
        source: "iana",
        extensions: ["vsf"]
      },
      "application/vnd.wap.sic": {
        source: "iana"
      },
      "application/vnd.wap.slc": {
        source: "iana"
      },
      "application/vnd.wap.wbxml": {
        source: "iana",
        charset: "UTF-8",
        extensions: ["wbxml"]
      },
      "application/vnd.wap.wmlc": {
        source: "iana",
        extensions: ["wmlc"]
      },
      "application/vnd.wap.wmlscriptc": {
        source: "iana",
        extensions: ["wmlsc"]
      },
      "application/vnd.webturbo": {
        source: "iana",
        extensions: ["wtb"]
      },
      "application/vnd.wfa.dpp": {
        source: "iana"
      },
      "application/vnd.wfa.p2p": {
        source: "iana"
      },
      "application/vnd.wfa.wsc": {
        source: "iana"
      },
      "application/vnd.windows.devicepairing": {
        source: "iana"
      },
      "application/vnd.wmc": {
        source: "iana"
      },
      "application/vnd.wmf.bootstrap": {
        source: "iana"
      },
      "application/vnd.wolfram.mathematica": {
        source: "iana"
      },
      "application/vnd.wolfram.mathematica.package": {
        source: "iana"
      },
      "application/vnd.wolfram.player": {
        source: "iana",
        extensions: ["nbp"]
      },
      "application/vnd.wordperfect": {
        source: "iana",
        extensions: ["wpd"]
      },
      "application/vnd.wqd": {
        source: "iana",
        extensions: ["wqd"]
      },
      "application/vnd.wrq-hp3000-labelled": {
        source: "iana"
      },
      "application/vnd.wt.stf": {
        source: "iana",
        extensions: ["stf"]
      },
      "application/vnd.wv.csp+wbxml": {
        source: "iana"
      },
      "application/vnd.wv.csp+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.wv.ssp+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.xacml+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.xara": {
        source: "iana",
        extensions: ["xar"]
      },
      "application/vnd.xfdl": {
        source: "iana",
        extensions: ["xfdl"]
      },
      "application/vnd.xfdl.webform": {
        source: "iana"
      },
      "application/vnd.xmi+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.xmpie.cpkg": {
        source: "iana"
      },
      "application/vnd.xmpie.dpkg": {
        source: "iana"
      },
      "application/vnd.xmpie.plan": {
        source: "iana"
      },
      "application/vnd.xmpie.ppkg": {
        source: "iana"
      },
      "application/vnd.xmpie.xlim": {
        source: "iana"
      },
      "application/vnd.yamaha.hv-dic": {
        source: "iana",
        extensions: ["hvd"]
      },
      "application/vnd.yamaha.hv-script": {
        source: "iana",
        extensions: ["hvs"]
      },
      "application/vnd.yamaha.hv-voice": {
        source: "iana",
        extensions: ["hvp"]
      },
      "application/vnd.yamaha.openscoreformat": {
        source: "iana",
        extensions: ["osf"]
      },
      "application/vnd.yamaha.openscoreformat.osfpvg+xml": {
        source: "iana",
        compressible: true,
        extensions: ["osfpvg"]
      },
      "application/vnd.yamaha.remote-setup": {
        source: "iana"
      },
      "application/vnd.yamaha.smaf-audio": {
        source: "iana",
        extensions: ["saf"]
      },
      "application/vnd.yamaha.smaf-phrase": {
        source: "iana",
        extensions: ["spf"]
      },
      "application/vnd.yamaha.through-ngn": {
        source: "iana"
      },
      "application/vnd.yamaha.tunnel-udpencap": {
        source: "iana"
      },
      "application/vnd.yaoweme": {
        source: "iana"
      },
      "application/vnd.yellowriver-custom-menu": {
        source: "iana",
        extensions: ["cmp"]
      },
      "application/vnd.youtube.yt": {
        source: "iana"
      },
      "application/vnd.zul": {
        source: "iana",
        extensions: ["zir", "zirz"]
      },
      "application/vnd.zzazz.deck+xml": {
        source: "iana",
        compressible: true,
        extensions: ["zaz"]
      },
      "application/voicexml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["vxml"]
      },
      "application/voucher-cms+json": {
        source: "iana",
        compressible: true
      },
      "application/vq-rtcpxr": {
        source: "iana"
      },
      "application/wasm": {
        source: "iana",
        compressible: true,
        extensions: ["wasm"]
      },
      "application/watcherinfo+xml": {
        source: "iana",
        compressible: true,
        extensions: ["wif"]
      },
      "application/webpush-options+json": {
        source: "iana",
        compressible: true
      },
      "application/whoispp-query": {
        source: "iana"
      },
      "application/whoispp-response": {
        source: "iana"
      },
      "application/widget": {
        source: "iana",
        extensions: ["wgt"]
      },
      "application/winhlp": {
        source: "apache",
        extensions: ["hlp"]
      },
      "application/wita": {
        source: "iana"
      },
      "application/wordperfect5.1": {
        source: "iana"
      },
      "application/wsdl+xml": {
        source: "iana",
        compressible: true,
        extensions: ["wsdl"]
      },
      "application/wspolicy+xml": {
        source: "iana",
        compressible: true,
        extensions: ["wspolicy"]
      },
      "application/x-7z-compressed": {
        source: "apache",
        compressible: false,
        extensions: ["7z"]
      },
      "application/x-abiword": {
        source: "apache",
        extensions: ["abw"]
      },
      "application/x-ace-compressed": {
        source: "apache",
        extensions: ["ace"]
      },
      "application/x-amf": {
        source: "apache"
      },
      "application/x-apple-diskimage": {
        source: "apache",
        extensions: ["dmg"]
      },
      "application/x-arj": {
        compressible: false,
        extensions: ["arj"]
      },
      "application/x-authorware-bin": {
        source: "apache",
        extensions: ["aab", "x32", "u32", "vox"]
      },
      "application/x-authorware-map": {
        source: "apache",
        extensions: ["aam"]
      },
      "application/x-authorware-seg": {
        source: "apache",
        extensions: ["aas"]
      },
      "application/x-bcpio": {
        source: "apache",
        extensions: ["bcpio"]
      },
      "application/x-bdoc": {
        compressible: false,
        extensions: ["bdoc"]
      },
      "application/x-bittorrent": {
        source: "apache",
        extensions: ["torrent"]
      },
      "application/x-blorb": {
        source: "apache",
        extensions: ["blb", "blorb"]
      },
      "application/x-bzip": {
        source: "apache",
        compressible: false,
        extensions: ["bz"]
      },
      "application/x-bzip2": {
        source: "apache",
        compressible: false,
        extensions: ["bz2", "boz"]
      },
      "application/x-cbr": {
        source: "apache",
        extensions: ["cbr", "cba", "cbt", "cbz", "cb7"]
      },
      "application/x-cdlink": {
        source: "apache",
        extensions: ["vcd"]
      },
      "application/x-cfs-compressed": {
        source: "apache",
        extensions: ["cfs"]
      },
      "application/x-chat": {
        source: "apache",
        extensions: ["chat"]
      },
      "application/x-chess-pgn": {
        source: "apache",
        extensions: ["pgn"]
      },
      "application/x-chrome-extension": {
        extensions: ["crx"]
      },
      "application/x-cocoa": {
        source: "nginx",
        extensions: ["cco"]
      },
      "application/x-compress": {
        source: "apache"
      },
      "application/x-conference": {
        source: "apache",
        extensions: ["nsc"]
      },
      "application/x-cpio": {
        source: "apache",
        extensions: ["cpio"]
      },
      "application/x-csh": {
        source: "apache",
        extensions: ["csh"]
      },
      "application/x-deb": {
        compressible: false
      },
      "application/x-debian-package": {
        source: "apache",
        extensions: ["deb", "udeb"]
      },
      "application/x-dgc-compressed": {
        source: "apache",
        extensions: ["dgc"]
      },
      "application/x-director": {
        source: "apache",
        extensions: ["dir", "dcr", "dxr", "cst", "cct", "cxt", "w3d", "fgd", "swa"]
      },
      "application/x-doom": {
        source: "apache",
        extensions: ["wad"]
      },
      "application/x-dtbncx+xml": {
        source: "apache",
        compressible: true,
        extensions: ["ncx"]
      },
      "application/x-dtbook+xml": {
        source: "apache",
        compressible: true,
        extensions: ["dtb"]
      },
      "application/x-dtbresource+xml": {
        source: "apache",
        compressible: true,
        extensions: ["res"]
      },
      "application/x-dvi": {
        source: "apache",
        compressible: false,
        extensions: ["dvi"]
      },
      "application/x-envoy": {
        source: "apache",
        extensions: ["evy"]
      },
      "application/x-eva": {
        source: "apache",
        extensions: ["eva"]
      },
      "application/x-font-bdf": {
        source: "apache",
        extensions: ["bdf"]
      },
      "application/x-font-dos": {
        source: "apache"
      },
      "application/x-font-framemaker": {
        source: "apache"
      },
      "application/x-font-ghostscript": {
        source: "apache",
        extensions: ["gsf"]
      },
      "application/x-font-libgrx": {
        source: "apache"
      },
      "application/x-font-linux-psf": {
        source: "apache",
        extensions: ["psf"]
      },
      "application/x-font-pcf": {
        source: "apache",
        extensions: ["pcf"]
      },
      "application/x-font-snf": {
        source: "apache",
        extensions: ["snf"]
      },
      "application/x-font-speedo": {
        source: "apache"
      },
      "application/x-font-sunos-news": {
        source: "apache"
      },
      "application/x-font-type1": {
        source: "apache",
        extensions: ["pfa", "pfb", "pfm", "afm"]
      },
      "application/x-font-vfont": {
        source: "apache"
      },
      "application/x-freearc": {
        source: "apache",
        extensions: ["arc"]
      },
      "application/x-futuresplash": {
        source: "apache",
        extensions: ["spl"]
      },
      "application/x-gca-compressed": {
        source: "apache",
        extensions: ["gca"]
      },
      "application/x-glulx": {
        source: "apache",
        extensions: ["ulx"]
      },
      "application/x-gnumeric": {
        source: "apache",
        extensions: ["gnumeric"]
      },
      "application/x-gramps-xml": {
        source: "apache",
        extensions: ["gramps"]
      },
      "application/x-gtar": {
        source: "apache",
        extensions: ["gtar"]
      },
      "application/x-gzip": {
        source: "apache"
      },
      "application/x-hdf": {
        source: "apache",
        extensions: ["hdf"]
      },
      "application/x-httpd-php": {
        compressible: true,
        extensions: ["php"]
      },
      "application/x-install-instructions": {
        source: "apache",
        extensions: ["install"]
      },
      "application/x-iso9660-image": {
        source: "apache",
        extensions: ["iso"]
      },
      "application/x-iwork-keynote-sffkey": {
        extensions: ["key"]
      },
      "application/x-iwork-numbers-sffnumbers": {
        extensions: ["numbers"]
      },
      "application/x-iwork-pages-sffpages": {
        extensions: ["pages"]
      },
      "application/x-java-archive-diff": {
        source: "nginx",
        extensions: ["jardiff"]
      },
      "application/x-java-jnlp-file": {
        source: "apache",
        compressible: false,
        extensions: ["jnlp"]
      },
      "application/x-javascript": {
        compressible: true
      },
      "application/x-keepass2": {
        extensions: ["kdbx"]
      },
      "application/x-latex": {
        source: "apache",
        compressible: false,
        extensions: ["latex"]
      },
      "application/x-lua-bytecode": {
        extensions: ["luac"]
      },
      "application/x-lzh-compressed": {
        source: "apache",
        extensions: ["lzh", "lha"]
      },
      "application/x-makeself": {
        source: "nginx",
        extensions: ["run"]
      },
      "application/x-mie": {
        source: "apache",
        extensions: ["mie"]
      },
      "application/x-mobipocket-ebook": {
        source: "apache",
        extensions: ["prc", "mobi"]
      },
      "application/x-mpegurl": {
        compressible: false
      },
      "application/x-ms-application": {
        source: "apache",
        extensions: ["application"]
      },
      "application/x-ms-shortcut": {
        source: "apache",
        extensions: ["lnk"]
      },
      "application/x-ms-wmd": {
        source: "apache",
        extensions: ["wmd"]
      },
      "application/x-ms-wmz": {
        source: "apache",
        extensions: ["wmz"]
      },
      "application/x-ms-xbap": {
        source: "apache",
        extensions: ["xbap"]
      },
      "application/x-msaccess": {
        source: "apache",
        extensions: ["mdb"]
      },
      "application/x-msbinder": {
        source: "apache",
        extensions: ["obd"]
      },
      "application/x-mscardfile": {
        source: "apache",
        extensions: ["crd"]
      },
      "application/x-msclip": {
        source: "apache",
        extensions: ["clp"]
      },
      "application/x-msdos-program": {
        extensions: ["exe"]
      },
      "application/x-msdownload": {
        source: "apache",
        extensions: ["exe", "dll", "com", "bat", "msi"]
      },
      "application/x-msmediaview": {
        source: "apache",
        extensions: ["mvb", "m13", "m14"]
      },
      "application/x-msmetafile": {
        source: "apache",
        extensions: ["wmf", "wmz", "emf", "emz"]
      },
      "application/x-msmoney": {
        source: "apache",
        extensions: ["mny"]
      },
      "application/x-mspublisher": {
        source: "apache",
        extensions: ["pub"]
      },
      "application/x-msschedule": {
        source: "apache",
        extensions: ["scd"]
      },
      "application/x-msterminal": {
        source: "apache",
        extensions: ["trm"]
      },
      "application/x-mswrite": {
        source: "apache",
        extensions: ["wri"]
      },
      "application/x-netcdf": {
        source: "apache",
        extensions: ["nc", "cdf"]
      },
      "application/x-ns-proxy-autoconfig": {
        compressible: true,
        extensions: ["pac"]
      },
      "application/x-nzb": {
        source: "apache",
        extensions: ["nzb"]
      },
      "application/x-perl": {
        source: "nginx",
        extensions: ["pl", "pm"]
      },
      "application/x-pilot": {
        source: "nginx",
        extensions: ["prc", "pdb"]
      },
      "application/x-pkcs12": {
        source: "apache",
        compressible: false,
        extensions: ["p12", "pfx"]
      },
      "application/x-pkcs7-certificates": {
        source: "apache",
        extensions: ["p7b", "spc"]
      },
      "application/x-pkcs7-certreqresp": {
        source: "apache",
        extensions: ["p7r"]
      },
      "application/x-pki-message": {
        source: "iana"
      },
      "application/x-rar-compressed": {
        source: "apache",
        compressible: false,
        extensions: ["rar"]
      },
      "application/x-redhat-package-manager": {
        source: "nginx",
        extensions: ["rpm"]
      },
      "application/x-research-info-systems": {
        source: "apache",
        extensions: ["ris"]
      },
      "application/x-sea": {
        source: "nginx",
        extensions: ["sea"]
      },
      "application/x-sh": {
        source: "apache",
        compressible: true,
        extensions: ["sh"]
      },
      "application/x-shar": {
        source: "apache",
        extensions: ["shar"]
      },
      "application/x-shockwave-flash": {
        source: "apache",
        compressible: false,
        extensions: ["swf"]
      },
      "application/x-silverlight-app": {
        source: "apache",
        extensions: ["xap"]
      },
      "application/x-sql": {
        source: "apache",
        extensions: ["sql"]
      },
      "application/x-stuffit": {
        source: "apache",
        compressible: false,
        extensions: ["sit"]
      },
      "application/x-stuffitx": {
        source: "apache",
        extensions: ["sitx"]
      },
      "application/x-subrip": {
        source: "apache",
        extensions: ["srt"]
      },
      "application/x-sv4cpio": {
        source: "apache",
        extensions: ["sv4cpio"]
      },
      "application/x-sv4crc": {
        source: "apache",
        extensions: ["sv4crc"]
      },
      "application/x-t3vm-image": {
        source: "apache",
        extensions: ["t3"]
      },
      "application/x-tads": {
        source: "apache",
        extensions: ["gam"]
      },
      "application/x-tar": {
        source: "apache",
        compressible: true,
        extensions: ["tar"]
      },
      "application/x-tcl": {
        source: "apache",
        extensions: ["tcl", "tk"]
      },
      "application/x-tex": {
        source: "apache",
        extensions: ["tex"]
      },
      "application/x-tex-tfm": {
        source: "apache",
        extensions: ["tfm"]
      },
      "application/x-texinfo": {
        source: "apache",
        extensions: ["texinfo", "texi"]
      },
      "application/x-tgif": {
        source: "apache",
        extensions: ["obj"]
      },
      "application/x-ustar": {
        source: "apache",
        extensions: ["ustar"]
      },
      "application/x-virtualbox-hdd": {
        compressible: true,
        extensions: ["hdd"]
      },
      "application/x-virtualbox-ova": {
        compressible: true,
        extensions: ["ova"]
      },
      "application/x-virtualbox-ovf": {
        compressible: true,
        extensions: ["ovf"]
      },
      "application/x-virtualbox-vbox": {
        compressible: true,
        extensions: ["vbox"]
      },
      "application/x-virtualbox-vbox-extpack": {
        compressible: false,
        extensions: ["vbox-extpack"]
      },
      "application/x-virtualbox-vdi": {
        compressible: true,
        extensions: ["vdi"]
      },
      "application/x-virtualbox-vhd": {
        compressible: true,
        extensions: ["vhd"]
      },
      "application/x-virtualbox-vmdk": {
        compressible: true,
        extensions: ["vmdk"]
      },
      "application/x-wais-source": {
        source: "apache",
        extensions: ["src"]
      },
      "application/x-web-app-manifest+json": {
        compressible: true,
        extensions: ["webapp"]
      },
      "application/x-www-form-urlencoded": {
        source: "iana",
        compressible: true
      },
      "application/x-x509-ca-cert": {
        source: "iana",
        extensions: ["der", "crt", "pem"]
      },
      "application/x-x509-ca-ra-cert": {
        source: "iana"
      },
      "application/x-x509-next-ca-cert": {
        source: "iana"
      },
      "application/x-xfig": {
        source: "apache",
        extensions: ["fig"]
      },
      "application/x-xliff+xml": {
        source: "apache",
        compressible: true,
        extensions: ["xlf"]
      },
      "application/x-xpinstall": {
        source: "apache",
        compressible: false,
        extensions: ["xpi"]
      },
      "application/x-xz": {
        source: "apache",
        extensions: ["xz"]
      },
      "application/x-zmachine": {
        source: "apache",
        extensions: ["z1", "z2", "z3", "z4", "z5", "z6", "z7", "z8"]
      },
      "application/x400-bp": {
        source: "iana"
      },
      "application/xacml+xml": {
        source: "iana",
        compressible: true
      },
      "application/xaml+xml": {
        source: "apache",
        compressible: true,
        extensions: ["xaml"]
      },
      "application/xcap-att+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xav"]
      },
      "application/xcap-caps+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xca"]
      },
      "application/xcap-diff+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xdf"]
      },
      "application/xcap-el+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xel"]
      },
      "application/xcap-error+xml": {
        source: "iana",
        compressible: true
      },
      "application/xcap-ns+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xns"]
      },
      "application/xcon-conference-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/xcon-conference-info-diff+xml": {
        source: "iana",
        compressible: true
      },
      "application/xenc+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xenc"]
      },
      "application/xhtml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xhtml", "xht"]
      },
      "application/xhtml-voice+xml": {
        source: "apache",
        compressible: true
      },
      "application/xliff+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xlf"]
      },
      "application/xml": {
        source: "iana",
        compressible: true,
        extensions: ["xml", "xsl", "xsd", "rng"]
      },
      "application/xml-dtd": {
        source: "iana",
        compressible: true,
        extensions: ["dtd"]
      },
      "application/xml-external-parsed-entity": {
        source: "iana"
      },
      "application/xml-patch+xml": {
        source: "iana",
        compressible: true
      },
      "application/xmpp+xml": {
        source: "iana",
        compressible: true
      },
      "application/xop+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xop"]
      },
      "application/xproc+xml": {
        source: "apache",
        compressible: true,
        extensions: ["xpl"]
      },
      "application/xslt+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xsl", "xslt"]
      },
      "application/xspf+xml": {
        source: "apache",
        compressible: true,
        extensions: ["xspf"]
      },
      "application/xv+xml": {
        source: "iana",
        compressible: true,
        extensions: ["mxml", "xhvml", "xvml", "xvm"]
      },
      "application/yang": {
        source: "iana",
        extensions: ["yang"]
      },
      "application/yang-data+json": {
        source: "iana",
        compressible: true
      },
      "application/yang-data+xml": {
        source: "iana",
        compressible: true
      },
      "application/yang-patch+json": {
        source: "iana",
        compressible: true
      },
      "application/yang-patch+xml": {
        source: "iana",
        compressible: true
      },
      "application/yin+xml": {
        source: "iana",
        compressible: true,
        extensions: ["yin"]
      },
      "application/zip": {
        source: "iana",
        compressible: false,
        extensions: ["zip"]
      },
      "application/zlib": {
        source: "iana"
      },
      "application/zstd": {
        source: "iana"
      },
      "audio/1d-interleaved-parityfec": {
        source: "iana"
      },
      "audio/32kadpcm": {
        source: "iana"
      },
      "audio/3gpp": {
        source: "iana",
        compressible: false,
        extensions: ["3gpp"]
      },
      "audio/3gpp2": {
        source: "iana"
      },
      "audio/aac": {
        source: "iana"
      },
      "audio/ac3": {
        source: "iana"
      },
      "audio/adpcm": {
        source: "apache",
        extensions: ["adp"]
      },
      "audio/amr": {
        source: "iana",
        extensions: ["amr"]
      },
      "audio/amr-wb": {
        source: "iana"
      },
      "audio/amr-wb+": {
        source: "iana"
      },
      "audio/aptx": {
        source: "iana"
      },
      "audio/asc": {
        source: "iana"
      },
      "audio/atrac-advanced-lossless": {
        source: "iana"
      },
      "audio/atrac-x": {
        source: "iana"
      },
      "audio/atrac3": {
        source: "iana"
      },
      "audio/basic": {
        source: "iana",
        compressible: false,
        extensions: ["au", "snd"]
      },
      "audio/bv16": {
        source: "iana"
      },
      "audio/bv32": {
        source: "iana"
      },
      "audio/clearmode": {
        source: "iana"
      },
      "audio/cn": {
        source: "iana"
      },
      "audio/dat12": {
        source: "iana"
      },
      "audio/dls": {
        source: "iana"
      },
      "audio/dsr-es201108": {
        source: "iana"
      },
      "audio/dsr-es202050": {
        source: "iana"
      },
      "audio/dsr-es202211": {
        source: "iana"
      },
      "audio/dsr-es202212": {
        source: "iana"
      },
      "audio/dv": {
        source: "iana"
      },
      "audio/dvi4": {
        source: "iana"
      },
      "audio/eac3": {
        source: "iana"
      },
      "audio/encaprtp": {
        source: "iana"
      },
      "audio/evrc": {
        source: "iana"
      },
      "audio/evrc-qcp": {
        source: "iana"
      },
      "audio/evrc0": {
        source: "iana"
      },
      "audio/evrc1": {
        source: "iana"
      },
      "audio/evrcb": {
        source: "iana"
      },
      "audio/evrcb0": {
        source: "iana"
      },
      "audio/evrcb1": {
        source: "iana"
      },
      "audio/evrcnw": {
        source: "iana"
      },
      "audio/evrcnw0": {
        source: "iana"
      },
      "audio/evrcnw1": {
        source: "iana"
      },
      "audio/evrcwb": {
        source: "iana"
      },
      "audio/evrcwb0": {
        source: "iana"
      },
      "audio/evrcwb1": {
        source: "iana"
      },
      "audio/evs": {
        source: "iana"
      },
      "audio/flexfec": {
        source: "iana"
      },
      "audio/fwdred": {
        source: "iana"
      },
      "audio/g711-0": {
        source: "iana"
      },
      "audio/g719": {
        source: "iana"
      },
      "audio/g722": {
        source: "iana"
      },
      "audio/g7221": {
        source: "iana"
      },
      "audio/g723": {
        source: "iana"
      },
      "audio/g726-16": {
        source: "iana"
      },
      "audio/g726-24": {
        source: "iana"
      },
      "audio/g726-32": {
        source: "iana"
      },
      "audio/g726-40": {
        source: "iana"
      },
      "audio/g728": {
        source: "iana"
      },
      "audio/g729": {
        source: "iana"
      },
      "audio/g7291": {
        source: "iana"
      },
      "audio/g729d": {
        source: "iana"
      },
      "audio/g729e": {
        source: "iana"
      },
      "audio/gsm": {
        source: "iana"
      },
      "audio/gsm-efr": {
        source: "iana"
      },
      "audio/gsm-hr-08": {
        source: "iana"
      },
      "audio/ilbc": {
        source: "iana"
      },
      "audio/ip-mr_v2.5": {
        source: "iana"
      },
      "audio/isac": {
        source: "apache"
      },
      "audio/l16": {
        source: "iana"
      },
      "audio/l20": {
        source: "iana"
      },
      "audio/l24": {
        source: "iana",
        compressible: false
      },
      "audio/l8": {
        source: "iana"
      },
      "audio/lpc": {
        source: "iana"
      },
      "audio/melp": {
        source: "iana"
      },
      "audio/melp1200": {
        source: "iana"
      },
      "audio/melp2400": {
        source: "iana"
      },
      "audio/melp600": {
        source: "iana"
      },
      "audio/mhas": {
        source: "iana"
      },
      "audio/midi": {
        source: "apache",
        extensions: ["mid", "midi", "kar", "rmi"]
      },
      "audio/mobile-xmf": {
        source: "iana",
        extensions: ["mxmf"]
      },
      "audio/mp3": {
        compressible: false,
        extensions: ["mp3"]
      },
      "audio/mp4": {
        source: "iana",
        compressible: false,
        extensions: ["m4a", "mp4a"]
      },
      "audio/mp4a-latm": {
        source: "iana"
      },
      "audio/mpa": {
        source: "iana"
      },
      "audio/mpa-robust": {
        source: "iana"
      },
      "audio/mpeg": {
        source: "iana",
        compressible: false,
        extensions: ["mpga", "mp2", "mp2a", "mp3", "m2a", "m3a"]
      },
      "audio/mpeg4-generic": {
        source: "iana"
      },
      "audio/musepack": {
        source: "apache"
      },
      "audio/ogg": {
        source: "iana",
        compressible: false,
        extensions: ["oga", "ogg", "spx", "opus"]
      },
      "audio/opus": {
        source: "iana"
      },
      "audio/parityfec": {
        source: "iana"
      },
      "audio/pcma": {
        source: "iana"
      },
      "audio/pcma-wb": {
        source: "iana"
      },
      "audio/pcmu": {
        source: "iana"
      },
      "audio/pcmu-wb": {
        source: "iana"
      },
      "audio/prs.sid": {
        source: "iana"
      },
      "audio/qcelp": {
        source: "iana"
      },
      "audio/raptorfec": {
        source: "iana"
      },
      "audio/red": {
        source: "iana"
      },
      "audio/rtp-enc-aescm128": {
        source: "iana"
      },
      "audio/rtp-midi": {
        source: "iana"
      },
      "audio/rtploopback": {
        source: "iana"
      },
      "audio/rtx": {
        source: "iana"
      },
      "audio/s3m": {
        source: "apache",
        extensions: ["s3m"]
      },
      "audio/scip": {
        source: "iana"
      },
      "audio/silk": {
        source: "apache",
        extensions: ["sil"]
      },
      "audio/smv": {
        source: "iana"
      },
      "audio/smv-qcp": {
        source: "iana"
      },
      "audio/smv0": {
        source: "iana"
      },
      "audio/sofa": {
        source: "iana"
      },
      "audio/sp-midi": {
        source: "iana"
      },
      "audio/speex": {
        source: "iana"
      },
      "audio/t140c": {
        source: "iana"
      },
      "audio/t38": {
        source: "iana"
      },
      "audio/telephone-event": {
        source: "iana"
      },
      "audio/tetra_acelp": {
        source: "iana"
      },
      "audio/tetra_acelp_bb": {
        source: "iana"
      },
      "audio/tone": {
        source: "iana"
      },
      "audio/tsvcis": {
        source: "iana"
      },
      "audio/uemclip": {
        source: "iana"
      },
      "audio/ulpfec": {
        source: "iana"
      },
      "audio/usac": {
        source: "iana"
      },
      "audio/vdvi": {
        source: "iana"
      },
      "audio/vmr-wb": {
        source: "iana"
      },
      "audio/vnd.3gpp.iufp": {
        source: "iana"
      },
      "audio/vnd.4sb": {
        source: "iana"
      },
      "audio/vnd.audiokoz": {
        source: "iana"
      },
      "audio/vnd.celp": {
        source: "iana"
      },
      "audio/vnd.cisco.nse": {
        source: "iana"
      },
      "audio/vnd.cmles.radio-events": {
        source: "iana"
      },
      "audio/vnd.cns.anp1": {
        source: "iana"
      },
      "audio/vnd.cns.inf1": {
        source: "iana"
      },
      "audio/vnd.dece.audio": {
        source: "iana",
        extensions: ["uva", "uvva"]
      },
      "audio/vnd.digital-winds": {
        source: "iana",
        extensions: ["eol"]
      },
      "audio/vnd.dlna.adts": {
        source: "iana"
      },
      "audio/vnd.dolby.heaac.1": {
        source: "iana"
      },
      "audio/vnd.dolby.heaac.2": {
        source: "iana"
      },
      "audio/vnd.dolby.mlp": {
        source: "iana"
      },
      "audio/vnd.dolby.mps": {
        source: "iana"
      },
      "audio/vnd.dolby.pl2": {
        source: "iana"
      },
      "audio/vnd.dolby.pl2x": {
        source: "iana"
      },
      "audio/vnd.dolby.pl2z": {
        source: "iana"
      },
      "audio/vnd.dolby.pulse.1": {
        source: "iana"
      },
      "audio/vnd.dra": {
        source: "iana",
        extensions: ["dra"]
      },
      "audio/vnd.dts": {
        source: "iana",
        extensions: ["dts"]
      },
      "audio/vnd.dts.hd": {
        source: "iana",
        extensions: ["dtshd"]
      },
      "audio/vnd.dts.uhd": {
        source: "iana"
      },
      "audio/vnd.dvb.file": {
        source: "iana"
      },
      "audio/vnd.everad.plj": {
        source: "iana"
      },
      "audio/vnd.hns.audio": {
        source: "iana"
      },
      "audio/vnd.lucent.voice": {
        source: "iana",
        extensions: ["lvp"]
      },
      "audio/vnd.ms-playready.media.pya": {
        source: "iana",
        extensions: ["pya"]
      },
      "audio/vnd.nokia.mobile-xmf": {
        source: "iana"
      },
      "audio/vnd.nortel.vbk": {
        source: "iana"
      },
      "audio/vnd.nuera.ecelp4800": {
        source: "iana",
        extensions: ["ecelp4800"]
      },
      "audio/vnd.nuera.ecelp7470": {
        source: "iana",
        extensions: ["ecelp7470"]
      },
      "audio/vnd.nuera.ecelp9600": {
        source: "iana",
        extensions: ["ecelp9600"]
      },
      "audio/vnd.octel.sbc": {
        source: "iana"
      },
      "audio/vnd.presonus.multitrack": {
        source: "iana"
      },
      "audio/vnd.qcelp": {
        source: "iana"
      },
      "audio/vnd.rhetorex.32kadpcm": {
        source: "iana"
      },
      "audio/vnd.rip": {
        source: "iana",
        extensions: ["rip"]
      },
      "audio/vnd.rn-realaudio": {
        compressible: false
      },
      "audio/vnd.sealedmedia.softseal.mpeg": {
        source: "iana"
      },
      "audio/vnd.vmx.cvsd": {
        source: "iana"
      },
      "audio/vnd.wave": {
        compressible: false
      },
      "audio/vorbis": {
        source: "iana",
        compressible: false
      },
      "audio/vorbis-config": {
        source: "iana"
      },
      "audio/wav": {
        compressible: false,
        extensions: ["wav"]
      },
      "audio/wave": {
        compressible: false,
        extensions: ["wav"]
      },
      "audio/webm": {
        source: "apache",
        compressible: false,
        extensions: ["weba"]
      },
      "audio/x-aac": {
        source: "apache",
        compressible: false,
        extensions: ["aac"]
      },
      "audio/x-aiff": {
        source: "apache",
        extensions: ["aif", "aiff", "aifc"]
      },
      "audio/x-caf": {
        source: "apache",
        compressible: false,
        extensions: ["caf"]
      },
      "audio/x-flac": {
        source: "apache",
        extensions: ["flac"]
      },
      "audio/x-m4a": {
        source: "nginx",
        extensions: ["m4a"]
      },
      "audio/x-matroska": {
        source: "apache",
        extensions: ["mka"]
      },
      "audio/x-mpegurl": {
        source: "apache",
        extensions: ["m3u"]
      },
      "audio/x-ms-wax": {
        source: "apache",
        extensions: ["wax"]
      },
      "audio/x-ms-wma": {
        source: "apache",
        extensions: ["wma"]
      },
      "audio/x-pn-realaudio": {
        source: "apache",
        extensions: ["ram", "ra"]
      },
      "audio/x-pn-realaudio-plugin": {
        source: "apache",
        extensions: ["rmp"]
      },
      "audio/x-realaudio": {
        source: "nginx",
        extensions: ["ra"]
      },
      "audio/x-tta": {
        source: "apache"
      },
      "audio/x-wav": {
        source: "apache",
        extensions: ["wav"]
      },
      "audio/xm": {
        source: "apache",
        extensions: ["xm"]
      },
      "chemical/x-cdx": {
        source: "apache",
        extensions: ["cdx"]
      },
      "chemical/x-cif": {
        source: "apache",
        extensions: ["cif"]
      },
      "chemical/x-cmdf": {
        source: "apache",
        extensions: ["cmdf"]
      },
      "chemical/x-cml": {
        source: "apache",
        extensions: ["cml"]
      },
      "chemical/x-csml": {
        source: "apache",
        extensions: ["csml"]
      },
      "chemical/x-pdb": {
        source: "apache"
      },
      "chemical/x-xyz": {
        source: "apache",
        extensions: ["xyz"]
      },
      "font/collection": {
        source: "iana",
        extensions: ["ttc"]
      },
      "font/otf": {
        source: "iana",
        compressible: true,
        extensions: ["otf"]
      },
      "font/sfnt": {
        source: "iana"
      },
      "font/ttf": {
        source: "iana",
        compressible: true,
        extensions: ["ttf"]
      },
      "font/woff": {
        source: "iana",
        extensions: ["woff"]
      },
      "font/woff2": {
        source: "iana",
        extensions: ["woff2"]
      },
      "image/aces": {
        source: "iana",
        extensions: ["exr"]
      },
      "image/apng": {
        compressible: false,
        extensions: ["apng"]
      },
      "image/avci": {
        source: "iana",
        extensions: ["avci"]
      },
      "image/avcs": {
        source: "iana",
        extensions: ["avcs"]
      },
      "image/avif": {
        source: "iana",
        compressible: false,
        extensions: ["avif"]
      },
      "image/bmp": {
        source: "iana",
        compressible: true,
        extensions: ["bmp"]
      },
      "image/cgm": {
        source: "iana",
        extensions: ["cgm"]
      },
      "image/dicom-rle": {
        source: "iana",
        extensions: ["drle"]
      },
      "image/emf": {
        source: "iana",
        extensions: ["emf"]
      },
      "image/fits": {
        source: "iana",
        extensions: ["fits"]
      },
      "image/g3fax": {
        source: "iana",
        extensions: ["g3"]
      },
      "image/gif": {
        source: "iana",
        compressible: false,
        extensions: ["gif"]
      },
      "image/heic": {
        source: "iana",
        extensions: ["heic"]
      },
      "image/heic-sequence": {
        source: "iana",
        extensions: ["heics"]
      },
      "image/heif": {
        source: "iana",
        extensions: ["heif"]
      },
      "image/heif-sequence": {
        source: "iana",
        extensions: ["heifs"]
      },
      "image/hej2k": {
        source: "iana",
        extensions: ["hej2"]
      },
      "image/hsj2": {
        source: "iana",
        extensions: ["hsj2"]
      },
      "image/ief": {
        source: "iana",
        extensions: ["ief"]
      },
      "image/jls": {
        source: "iana",
        extensions: ["jls"]
      },
      "image/jp2": {
        source: "iana",
        compressible: false,
        extensions: ["jp2", "jpg2"]
      },
      "image/jpeg": {
        source: "iana",
        compressible: false,
        extensions: ["jpeg", "jpg", "jpe"]
      },
      "image/jph": {
        source: "iana",
        extensions: ["jph"]
      },
      "image/jphc": {
        source: "iana",
        extensions: ["jhc"]
      },
      "image/jpm": {
        source: "iana",
        compressible: false,
        extensions: ["jpm"]
      },
      "image/jpx": {
        source: "iana",
        compressible: false,
        extensions: ["jpx", "jpf"]
      },
      "image/jxr": {
        source: "iana",
        extensions: ["jxr"]
      },
      "image/jxra": {
        source: "iana",
        extensions: ["jxra"]
      },
      "image/jxrs": {
        source: "iana",
        extensions: ["jxrs"]
      },
      "image/jxs": {
        source: "iana",
        extensions: ["jxs"]
      },
      "image/jxsc": {
        source: "iana",
        extensions: ["jxsc"]
      },
      "image/jxsi": {
        source: "iana",
        extensions: ["jxsi"]
      },
      "image/jxss": {
        source: "iana",
        extensions: ["jxss"]
      },
      "image/ktx": {
        source: "iana",
        extensions: ["ktx"]
      },
      "image/ktx2": {
        source: "iana",
        extensions: ["ktx2"]
      },
      "image/naplps": {
        source: "iana"
      },
      "image/pjpeg": {
        compressible: false
      },
      "image/png": {
        source: "iana",
        compressible: false,
        extensions: ["png"]
      },
      "image/prs.btif": {
        source: "iana",
        extensions: ["btif"]
      },
      "image/prs.pti": {
        source: "iana",
        extensions: ["pti"]
      },
      "image/pwg-raster": {
        source: "iana"
      },
      "image/sgi": {
        source: "apache",
        extensions: ["sgi"]
      },
      "image/svg+xml": {
        source: "iana",
        compressible: true,
        extensions: ["svg", "svgz"]
      },
      "image/t38": {
        source: "iana",
        extensions: ["t38"]
      },
      "image/tiff": {
        source: "iana",
        compressible: false,
        extensions: ["tif", "tiff"]
      },
      "image/tiff-fx": {
        source: "iana",
        extensions: ["tfx"]
      },
      "image/vnd.adobe.photoshop": {
        source: "iana",
        compressible: true,
        extensions: ["psd"]
      },
      "image/vnd.airzip.accelerator.azv": {
        source: "iana",
        extensions: ["azv"]
      },
      "image/vnd.cns.inf2": {
        source: "iana"
      },
      "image/vnd.dece.graphic": {
        source: "iana",
        extensions: ["uvi", "uvvi", "uvg", "uvvg"]
      },
      "image/vnd.djvu": {
        source: "iana",
        extensions: ["djvu", "djv"]
      },
      "image/vnd.dvb.subtitle": {
        source: "iana",
        extensions: ["sub"]
      },
      "image/vnd.dwg": {
        source: "iana",
        extensions: ["dwg"]
      },
      "image/vnd.dxf": {
        source: "iana",
        extensions: ["dxf"]
      },
      "image/vnd.fastbidsheet": {
        source: "iana",
        extensions: ["fbs"]
      },
      "image/vnd.fpx": {
        source: "iana",
        extensions: ["fpx"]
      },
      "image/vnd.fst": {
        source: "iana",
        extensions: ["fst"]
      },
      "image/vnd.fujixerox.edmics-mmr": {
        source: "iana",
        extensions: ["mmr"]
      },
      "image/vnd.fujixerox.edmics-rlc": {
        source: "iana",
        extensions: ["rlc"]
      },
      "image/vnd.globalgraphics.pgb": {
        source: "iana"
      },
      "image/vnd.microsoft.icon": {
        source: "iana",
        compressible: true,
        extensions: ["ico"]
      },
      "image/vnd.mix": {
        source: "iana"
      },
      "image/vnd.mozilla.apng": {
        source: "iana"
      },
      "image/vnd.ms-dds": {
        compressible: true,
        extensions: ["dds"]
      },
      "image/vnd.ms-modi": {
        source: "iana",
        extensions: ["mdi"]
      },
      "image/vnd.ms-photo": {
        source: "apache",
        extensions: ["wdp"]
      },
      "image/vnd.net-fpx": {
        source: "iana",
        extensions: ["npx"]
      },
      "image/vnd.pco.b16": {
        source: "iana",
        extensions: ["b16"]
      },
      "image/vnd.radiance": {
        source: "iana"
      },
      "image/vnd.sealed.png": {
        source: "iana"
      },
      "image/vnd.sealedmedia.softseal.gif": {
        source: "iana"
      },
      "image/vnd.sealedmedia.softseal.jpg": {
        source: "iana"
      },
      "image/vnd.svf": {
        source: "iana"
      },
      "image/vnd.tencent.tap": {
        source: "iana",
        extensions: ["tap"]
      },
      "image/vnd.valve.source.texture": {
        source: "iana",
        extensions: ["vtf"]
      },
      "image/vnd.wap.wbmp": {
        source: "iana",
        extensions: ["wbmp"]
      },
      "image/vnd.xiff": {
        source: "iana",
        extensions: ["xif"]
      },
      "image/vnd.zbrush.pcx": {
        source: "iana",
        extensions: ["pcx"]
      },
      "image/webp": {
        source: "apache",
        extensions: ["webp"]
      },
      "image/wmf": {
        source: "iana",
        extensions: ["wmf"]
      },
      "image/x-3ds": {
        source: "apache",
        extensions: ["3ds"]
      },
      "image/x-cmu-raster": {
        source: "apache",
        extensions: ["ras"]
      },
      "image/x-cmx": {
        source: "apache",
        extensions: ["cmx"]
      },
      "image/x-freehand": {
        source: "apache",
        extensions: ["fh", "fhc", "fh4", "fh5", "fh7"]
      },
      "image/x-icon": {
        source: "apache",
        compressible: true,
        extensions: ["ico"]
      },
      "image/x-jng": {
        source: "nginx",
        extensions: ["jng"]
      },
      "image/x-mrsid-image": {
        source: "apache",
        extensions: ["sid"]
      },
      "image/x-ms-bmp": {
        source: "nginx",
        compressible: true,
        extensions: ["bmp"]
      },
      "image/x-pcx": {
        source: "apache",
        extensions: ["pcx"]
      },
      "image/x-pict": {
        source: "apache",
        extensions: ["pic", "pct"]
      },
      "image/x-portable-anymap": {
        source: "apache",
        extensions: ["pnm"]
      },
      "image/x-portable-bitmap": {
        source: "apache",
        extensions: ["pbm"]
      },
      "image/x-portable-graymap": {
        source: "apache",
        extensions: ["pgm"]
      },
      "image/x-portable-pixmap": {
        source: "apache",
        extensions: ["ppm"]
      },
      "image/x-rgb": {
        source: "apache",
        extensions: ["rgb"]
      },
      "image/x-tga": {
        source: "apache",
        extensions: ["tga"]
      },
      "image/x-xbitmap": {
        source: "apache",
        extensions: ["xbm"]
      },
      "image/x-xcf": {
        compressible: false
      },
      "image/x-xpixmap": {
        source: "apache",
        extensions: ["xpm"]
      },
      "image/x-xwindowdump": {
        source: "apache",
        extensions: ["xwd"]
      },
      "message/cpim": {
        source: "iana"
      },
      "message/delivery-status": {
        source: "iana"
      },
      "message/disposition-notification": {
        source: "iana",
        extensions: [
          "disposition-notification"
        ]
      },
      "message/external-body": {
        source: "iana"
      },
      "message/feedback-report": {
        source: "iana"
      },
      "message/global": {
        source: "iana",
        extensions: ["u8msg"]
      },
      "message/global-delivery-status": {
        source: "iana",
        extensions: ["u8dsn"]
      },
      "message/global-disposition-notification": {
        source: "iana",
        extensions: ["u8mdn"]
      },
      "message/global-headers": {
        source: "iana",
        extensions: ["u8hdr"]
      },
      "message/http": {
        source: "iana",
        compressible: false
      },
      "message/imdn+xml": {
        source: "iana",
        compressible: true
      },
      "message/news": {
        source: "iana"
      },
      "message/partial": {
        source: "iana",
        compressible: false
      },
      "message/rfc822": {
        source: "iana",
        compressible: true,
        extensions: ["eml", "mime"]
      },
      "message/s-http": {
        source: "iana"
      },
      "message/sip": {
        source: "iana"
      },
      "message/sipfrag": {
        source: "iana"
      },
      "message/tracking-status": {
        source: "iana"
      },
      "message/vnd.si.simp": {
        source: "iana"
      },
      "message/vnd.wfa.wsc": {
        source: "iana",
        extensions: ["wsc"]
      },
      "model/3mf": {
        source: "iana",
        extensions: ["3mf"]
      },
      "model/e57": {
        source: "iana"
      },
      "model/gltf+json": {
        source: "iana",
        compressible: true,
        extensions: ["gltf"]
      },
      "model/gltf-binary": {
        source: "iana",
        compressible: true,
        extensions: ["glb"]
      },
      "model/iges": {
        source: "iana",
        compressible: false,
        extensions: ["igs", "iges"]
      },
      "model/mesh": {
        source: "iana",
        compressible: false,
        extensions: ["msh", "mesh", "silo"]
      },
      "model/mtl": {
        source: "iana",
        extensions: ["mtl"]
      },
      "model/obj": {
        source: "iana",
        extensions: ["obj"]
      },
      "model/step": {
        source: "iana"
      },
      "model/step+xml": {
        source: "iana",
        compressible: true,
        extensions: ["stpx"]
      },
      "model/step+zip": {
        source: "iana",
        compressible: false,
        extensions: ["stpz"]
      },
      "model/step-xml+zip": {
        source: "iana",
        compressible: false,
        extensions: ["stpxz"]
      },
      "model/stl": {
        source: "iana",
        extensions: ["stl"]
      },
      "model/vnd.collada+xml": {
        source: "iana",
        compressible: true,
        extensions: ["dae"]
      },
      "model/vnd.dwf": {
        source: "iana",
        extensions: ["dwf"]
      },
      "model/vnd.flatland.3dml": {
        source: "iana"
      },
      "model/vnd.gdl": {
        source: "iana",
        extensions: ["gdl"]
      },
      "model/vnd.gs-gdl": {
        source: "apache"
      },
      "model/vnd.gs.gdl": {
        source: "iana"
      },
      "model/vnd.gtw": {
        source: "iana",
        extensions: ["gtw"]
      },
      "model/vnd.moml+xml": {
        source: "iana",
        compressible: true
      },
      "model/vnd.mts": {
        source: "iana",
        extensions: ["mts"]
      },
      "model/vnd.opengex": {
        source: "iana",
        extensions: ["ogex"]
      },
      "model/vnd.parasolid.transmit.binary": {
        source: "iana",
        extensions: ["x_b"]
      },
      "model/vnd.parasolid.transmit.text": {
        source: "iana",
        extensions: ["x_t"]
      },
      "model/vnd.pytha.pyox": {
        source: "iana"
      },
      "model/vnd.rosette.annotated-data-model": {
        source: "iana"
      },
      "model/vnd.sap.vds": {
        source: "iana",
        extensions: ["vds"]
      },
      "model/vnd.usdz+zip": {
        source: "iana",
        compressible: false,
        extensions: ["usdz"]
      },
      "model/vnd.valve.source.compiled-map": {
        source: "iana",
        extensions: ["bsp"]
      },
      "model/vnd.vtu": {
        source: "iana",
        extensions: ["vtu"]
      },
      "model/vrml": {
        source: "iana",
        compressible: false,
        extensions: ["wrl", "vrml"]
      },
      "model/x3d+binary": {
        source: "apache",
        compressible: false,
        extensions: ["x3db", "x3dbz"]
      },
      "model/x3d+fastinfoset": {
        source: "iana",
        extensions: ["x3db"]
      },
      "model/x3d+vrml": {
        source: "apache",
        compressible: false,
        extensions: ["x3dv", "x3dvz"]
      },
      "model/x3d+xml": {
        source: "iana",
        compressible: true,
        extensions: ["x3d", "x3dz"]
      },
      "model/x3d-vrml": {
        source: "iana",
        extensions: ["x3dv"]
      },
      "multipart/alternative": {
        source: "iana",
        compressible: false
      },
      "multipart/appledouble": {
        source: "iana"
      },
      "multipart/byteranges": {
        source: "iana"
      },
      "multipart/digest": {
        source: "iana"
      },
      "multipart/encrypted": {
        source: "iana",
        compressible: false
      },
      "multipart/form-data": {
        source: "iana",
        compressible: false
      },
      "multipart/header-set": {
        source: "iana"
      },
      "multipart/mixed": {
        source: "iana"
      },
      "multipart/multilingual": {
        source: "iana"
      },
      "multipart/parallel": {
        source: "iana"
      },
      "multipart/related": {
        source: "iana",
        compressible: false
      },
      "multipart/report": {
        source: "iana"
      },
      "multipart/signed": {
        source: "iana",
        compressible: false
      },
      "multipart/vnd.bint.med-plus": {
        source: "iana"
      },
      "multipart/voice-message": {
        source: "iana"
      },
      "multipart/x-mixed-replace": {
        source: "iana"
      },
      "text/1d-interleaved-parityfec": {
        source: "iana"
      },
      "text/cache-manifest": {
        source: "iana",
        compressible: true,
        extensions: ["appcache", "manifest"]
      },
      "text/calendar": {
        source: "iana",
        extensions: ["ics", "ifb"]
      },
      "text/calender": {
        compressible: true
      },
      "text/cmd": {
        compressible: true
      },
      "text/coffeescript": {
        extensions: ["coffee", "litcoffee"]
      },
      "text/cql": {
        source: "iana"
      },
      "text/cql-expression": {
        source: "iana"
      },
      "text/cql-identifier": {
        source: "iana"
      },
      "text/css": {
        source: "iana",
        charset: "UTF-8",
        compressible: true,
        extensions: ["css"]
      },
      "text/csv": {
        source: "iana",
        compressible: true,
        extensions: ["csv"]
      },
      "text/csv-schema": {
        source: "iana"
      },
      "text/directory": {
        source: "iana"
      },
      "text/dns": {
        source: "iana"
      },
      "text/ecmascript": {
        source: "iana"
      },
      "text/encaprtp": {
        source: "iana"
      },
      "text/enriched": {
        source: "iana"
      },
      "text/fhirpath": {
        source: "iana"
      },
      "text/flexfec": {
        source: "iana"
      },
      "text/fwdred": {
        source: "iana"
      },
      "text/gff3": {
        source: "iana"
      },
      "text/grammar-ref-list": {
        source: "iana"
      },
      "text/html": {
        source: "iana",
        compressible: true,
        extensions: ["html", "htm", "shtml"]
      },
      "text/jade": {
        extensions: ["jade"]
      },
      "text/javascript": {
        source: "iana",
        compressible: true
      },
      "text/jcr-cnd": {
        source: "iana"
      },
      "text/jsx": {
        compressible: true,
        extensions: ["jsx"]
      },
      "text/less": {
        compressible: true,
        extensions: ["less"]
      },
      "text/markdown": {
        source: "iana",
        compressible: true,
        extensions: ["markdown", "md"]
      },
      "text/mathml": {
        source: "nginx",
        extensions: ["mml"]
      },
      "text/mdx": {
        compressible: true,
        extensions: ["mdx"]
      },
      "text/mizar": {
        source: "iana"
      },
      "text/n3": {
        source: "iana",
        charset: "UTF-8",
        compressible: true,
        extensions: ["n3"]
      },
      "text/parameters": {
        source: "iana",
        charset: "UTF-8"
      },
      "text/parityfec": {
        source: "iana"
      },
      "text/plain": {
        source: "iana",
        compressible: true,
        extensions: ["txt", "text", "conf", "def", "list", "log", "in", "ini"]
      },
      "text/provenance-notation": {
        source: "iana",
        charset: "UTF-8"
      },
      "text/prs.fallenstein.rst": {
        source: "iana"
      },
      "text/prs.lines.tag": {
        source: "iana",
        extensions: ["dsc"]
      },
      "text/prs.prop.logic": {
        source: "iana"
      },
      "text/raptorfec": {
        source: "iana"
      },
      "text/red": {
        source: "iana"
      },
      "text/rfc822-headers": {
        source: "iana"
      },
      "text/richtext": {
        source: "iana",
        compressible: true,
        extensions: ["rtx"]
      },
      "text/rtf": {
        source: "iana",
        compressible: true,
        extensions: ["rtf"]
      },
      "text/rtp-enc-aescm128": {
        source: "iana"
      },
      "text/rtploopback": {
        source: "iana"
      },
      "text/rtx": {
        source: "iana"
      },
      "text/sgml": {
        source: "iana",
        extensions: ["sgml", "sgm"]
      },
      "text/shaclc": {
        source: "iana"
      },
      "text/shex": {
        source: "iana",
        extensions: ["shex"]
      },
      "text/slim": {
        extensions: ["slim", "slm"]
      },
      "text/spdx": {
        source: "iana",
        extensions: ["spdx"]
      },
      "text/strings": {
        source: "iana"
      },
      "text/stylus": {
        extensions: ["stylus", "styl"]
      },
      "text/t140": {
        source: "iana"
      },
      "text/tab-separated-values": {
        source: "iana",
        compressible: true,
        extensions: ["tsv"]
      },
      "text/troff": {
        source: "iana",
        extensions: ["t", "tr", "roff", "man", "me", "ms"]
      },
      "text/turtle": {
        source: "iana",
        charset: "UTF-8",
        extensions: ["ttl"]
      },
      "text/ulpfec": {
        source: "iana"
      },
      "text/uri-list": {
        source: "iana",
        compressible: true,
        extensions: ["uri", "uris", "urls"]
      },
      "text/vcard": {
        source: "iana",
        compressible: true,
        extensions: ["vcard"]
      },
      "text/vnd.a": {
        source: "iana"
      },
      "text/vnd.abc": {
        source: "iana"
      },
      "text/vnd.ascii-art": {
        source: "iana"
      },
      "text/vnd.curl": {
        source: "iana",
        extensions: ["curl"]
      },
      "text/vnd.curl.dcurl": {
        source: "apache",
        extensions: ["dcurl"]
      },
      "text/vnd.curl.mcurl": {
        source: "apache",
        extensions: ["mcurl"]
      },
      "text/vnd.curl.scurl": {
        source: "apache",
        extensions: ["scurl"]
      },
      "text/vnd.debian.copyright": {
        source: "iana",
        charset: "UTF-8"
      },
      "text/vnd.dmclientscript": {
        source: "iana"
      },
      "text/vnd.dvb.subtitle": {
        source: "iana",
        extensions: ["sub"]
      },
      "text/vnd.esmertec.theme-descriptor": {
        source: "iana",
        charset: "UTF-8"
      },
      "text/vnd.familysearch.gedcom": {
        source: "iana",
        extensions: ["ged"]
      },
      "text/vnd.ficlab.flt": {
        source: "iana"
      },
      "text/vnd.fly": {
        source: "iana",
        extensions: ["fly"]
      },
      "text/vnd.fmi.flexstor": {
        source: "iana",
        extensions: ["flx"]
      },
      "text/vnd.gml": {
        source: "iana"
      },
      "text/vnd.graphviz": {
        source: "iana",
        extensions: ["gv"]
      },
      "text/vnd.hans": {
        source: "iana"
      },
      "text/vnd.hgl": {
        source: "iana"
      },
      "text/vnd.in3d.3dml": {
        source: "iana",
        extensions: ["3dml"]
      },
      "text/vnd.in3d.spot": {
        source: "iana",
        extensions: ["spot"]
      },
      "text/vnd.iptc.newsml": {
        source: "iana"
      },
      "text/vnd.iptc.nitf": {
        source: "iana"
      },
      "text/vnd.latex-z": {
        source: "iana"
      },
      "text/vnd.motorola.reflex": {
        source: "iana"
      },
      "text/vnd.ms-mediapackage": {
        source: "iana"
      },
      "text/vnd.net2phone.commcenter.command": {
        source: "iana"
      },
      "text/vnd.radisys.msml-basic-layout": {
        source: "iana"
      },
      "text/vnd.senx.warpscript": {
        source: "iana"
      },
      "text/vnd.si.uricatalogue": {
        source: "iana"
      },
      "text/vnd.sosi": {
        source: "iana"
      },
      "text/vnd.sun.j2me.app-descriptor": {
        source: "iana",
        charset: "UTF-8",
        extensions: ["jad"]
      },
      "text/vnd.trolltech.linguist": {
        source: "iana",
        charset: "UTF-8"
      },
      "text/vnd.wap.si": {
        source: "iana"
      },
      "text/vnd.wap.sl": {
        source: "iana"
      },
      "text/vnd.wap.wml": {
        source: "iana",
        extensions: ["wml"]
      },
      "text/vnd.wap.wmlscript": {
        source: "iana",
        extensions: ["wmls"]
      },
      "text/vtt": {
        source: "iana",
        charset: "UTF-8",
        compressible: true,
        extensions: ["vtt"]
      },
      "text/x-asm": {
        source: "apache",
        extensions: ["s", "asm"]
      },
      "text/x-c": {
        source: "apache",
        extensions: ["c", "cc", "cxx", "cpp", "h", "hh", "dic"]
      },
      "text/x-component": {
        source: "nginx",
        extensions: ["htc"]
      },
      "text/x-fortran": {
        source: "apache",
        extensions: ["f", "for", "f77", "f90"]
      },
      "text/x-gwt-rpc": {
        compressible: true
      },
      "text/x-handlebars-template": {
        extensions: ["hbs"]
      },
      "text/x-java-source": {
        source: "apache",
        extensions: ["java"]
      },
      "text/x-jquery-tmpl": {
        compressible: true
      },
      "text/x-lua": {
        extensions: ["lua"]
      },
      "text/x-markdown": {
        compressible: true,
        extensions: ["mkd"]
      },
      "text/x-nfo": {
        source: "apache",
        extensions: ["nfo"]
      },
      "text/x-opml": {
        source: "apache",
        extensions: ["opml"]
      },
      "text/x-org": {
        compressible: true,
        extensions: ["org"]
      },
      "text/x-pascal": {
        source: "apache",
        extensions: ["p", "pas"]
      },
      "text/x-processing": {
        compressible: true,
        extensions: ["pde"]
      },
      "text/x-sass": {
        extensions: ["sass"]
      },
      "text/x-scss": {
        extensions: ["scss"]
      },
      "text/x-setext": {
        source: "apache",
        extensions: ["etx"]
      },
      "text/x-sfv": {
        source: "apache",
        extensions: ["sfv"]
      },
      "text/x-suse-ymp": {
        compressible: true,
        extensions: ["ymp"]
      },
      "text/x-uuencode": {
        source: "apache",
        extensions: ["uu"]
      },
      "text/x-vcalendar": {
        source: "apache",
        extensions: ["vcs"]
      },
      "text/x-vcard": {
        source: "apache",
        extensions: ["vcf"]
      },
      "text/xml": {
        source: "iana",
        compressible: true,
        extensions: ["xml"]
      },
      "text/xml-external-parsed-entity": {
        source: "iana"
      },
      "text/yaml": {
        compressible: true,
        extensions: ["yaml", "yml"]
      },
      "video/1d-interleaved-parityfec": {
        source: "iana"
      },
      "video/3gpp": {
        source: "iana",
        extensions: ["3gp", "3gpp"]
      },
      "video/3gpp-tt": {
        source: "iana"
      },
      "video/3gpp2": {
        source: "iana",
        extensions: ["3g2"]
      },
      "video/av1": {
        source: "iana"
      },
      "video/bmpeg": {
        source: "iana"
      },
      "video/bt656": {
        source: "iana"
      },
      "video/celb": {
        source: "iana"
      },
      "video/dv": {
        source: "iana"
      },
      "video/encaprtp": {
        source: "iana"
      },
      "video/ffv1": {
        source: "iana"
      },
      "video/flexfec": {
        source: "iana"
      },
      "video/h261": {
        source: "iana",
        extensions: ["h261"]
      },
      "video/h263": {
        source: "iana",
        extensions: ["h263"]
      },
      "video/h263-1998": {
        source: "iana"
      },
      "video/h263-2000": {
        source: "iana"
      },
      "video/h264": {
        source: "iana",
        extensions: ["h264"]
      },
      "video/h264-rcdo": {
        source: "iana"
      },
      "video/h264-svc": {
        source: "iana"
      },
      "video/h265": {
        source: "iana"
      },
      "video/iso.segment": {
        source: "iana",
        extensions: ["m4s"]
      },
      "video/jpeg": {
        source: "iana",
        extensions: ["jpgv"]
      },
      "video/jpeg2000": {
        source: "iana"
      },
      "video/jpm": {
        source: "apache",
        extensions: ["jpm", "jpgm"]
      },
      "video/jxsv": {
        source: "iana"
      },
      "video/mj2": {
        source: "iana",
        extensions: ["mj2", "mjp2"]
      },
      "video/mp1s": {
        source: "iana"
      },
      "video/mp2p": {
        source: "iana"
      },
      "video/mp2t": {
        source: "iana",
        extensions: ["ts"]
      },
      "video/mp4": {
        source: "iana",
        compressible: false,
        extensions: ["mp4", "mp4v", "mpg4"]
      },
      "video/mp4v-es": {
        source: "iana"
      },
      "video/mpeg": {
        source: "iana",
        compressible: false,
        extensions: ["mpeg", "mpg", "mpe", "m1v", "m2v"]
      },
      "video/mpeg4-generic": {
        source: "iana"
      },
      "video/mpv": {
        source: "iana"
      },
      "video/nv": {
        source: "iana"
      },
      "video/ogg": {
        source: "iana",
        compressible: false,
        extensions: ["ogv"]
      },
      "video/parityfec": {
        source: "iana"
      },
      "video/pointer": {
        source: "iana"
      },
      "video/quicktime": {
        source: "iana",
        compressible: false,
        extensions: ["qt", "mov"]
      },
      "video/raptorfec": {
        source: "iana"
      },
      "video/raw": {
        source: "iana"
      },
      "video/rtp-enc-aescm128": {
        source: "iana"
      },
      "video/rtploopback": {
        source: "iana"
      },
      "video/rtx": {
        source: "iana"
      },
      "video/scip": {
        source: "iana"
      },
      "video/smpte291": {
        source: "iana"
      },
      "video/smpte292m": {
        source: "iana"
      },
      "video/ulpfec": {
        source: "iana"
      },
      "video/vc1": {
        source: "iana"
      },
      "video/vc2": {
        source: "iana"
      },
      "video/vnd.cctv": {
        source: "iana"
      },
      "video/vnd.dece.hd": {
        source: "iana",
        extensions: ["uvh", "uvvh"]
      },
      "video/vnd.dece.mobile": {
        source: "iana",
        extensions: ["uvm", "uvvm"]
      },
      "video/vnd.dece.mp4": {
        source: "iana"
      },
      "video/vnd.dece.pd": {
        source: "iana",
        extensions: ["uvp", "uvvp"]
      },
      "video/vnd.dece.sd": {
        source: "iana",
        extensions: ["uvs", "uvvs"]
      },
      "video/vnd.dece.video": {
        source: "iana",
        extensions: ["uvv", "uvvv"]
      },
      "video/vnd.directv.mpeg": {
        source: "iana"
      },
      "video/vnd.directv.mpeg-tts": {
        source: "iana"
      },
      "video/vnd.dlna.mpeg-tts": {
        source: "iana"
      },
      "video/vnd.dvb.file": {
        source: "iana",
        extensions: ["dvb"]
      },
      "video/vnd.fvt": {
        source: "iana",
        extensions: ["fvt"]
      },
      "video/vnd.hns.video": {
        source: "iana"
      },
      "video/vnd.iptvforum.1dparityfec-1010": {
        source: "iana"
      },
      "video/vnd.iptvforum.1dparityfec-2005": {
        source: "iana"
      },
      "video/vnd.iptvforum.2dparityfec-1010": {
        source: "iana"
      },
      "video/vnd.iptvforum.2dparityfec-2005": {
        source: "iana"
      },
      "video/vnd.iptvforum.ttsavc": {
        source: "iana"
      },
      "video/vnd.iptvforum.ttsmpeg2": {
        source: "iana"
      },
      "video/vnd.motorola.video": {
        source: "iana"
      },
      "video/vnd.motorola.videop": {
        source: "iana"
      },
      "video/vnd.mpegurl": {
        source: "iana",
        extensions: ["mxu", "m4u"]
      },
      "video/vnd.ms-playready.media.pyv": {
        source: "iana",
        extensions: ["pyv"]
      },
      "video/vnd.nokia.interleaved-multimedia": {
        source: "iana"
      },
      "video/vnd.nokia.mp4vr": {
        source: "iana"
      },
      "video/vnd.nokia.videovoip": {
        source: "iana"
      },
      "video/vnd.objectvideo": {
        source: "iana"
      },
      "video/vnd.radgamettools.bink": {
        source: "iana"
      },
      "video/vnd.radgamettools.smacker": {
        source: "iana"
      },
      "video/vnd.sealed.mpeg1": {
        source: "iana"
      },
      "video/vnd.sealed.mpeg4": {
        source: "iana"
      },
      "video/vnd.sealed.swf": {
        source: "iana"
      },
      "video/vnd.sealedmedia.softseal.mov": {
        source: "iana"
      },
      "video/vnd.uvvu.mp4": {
        source: "iana",
        extensions: ["uvu", "uvvu"]
      },
      "video/vnd.vivo": {
        source: "iana",
        extensions: ["viv"]
      },
      "video/vnd.youtube.yt": {
        source: "iana"
      },
      "video/vp8": {
        source: "iana"
      },
      "video/vp9": {
        source: "iana"
      },
      "video/webm": {
        source: "apache",
        compressible: false,
        extensions: ["webm"]
      },
      "video/x-f4v": {
        source: "apache",
        extensions: ["f4v"]
      },
      "video/x-fli": {
        source: "apache",
        extensions: ["fli"]
      },
      "video/x-flv": {
        source: "apache",
        compressible: false,
        extensions: ["flv"]
      },
      "video/x-m4v": {
        source: "apache",
        extensions: ["m4v"]
      },
      "video/x-matroska": {
        source: "apache",
        compressible: false,
        extensions: ["mkv", "mk3d", "mks"]
      },
      "video/x-mng": {
        source: "apache",
        extensions: ["mng"]
      },
      "video/x-ms-asf": {
        source: "apache",
        extensions: ["asf", "asx"]
      },
      "video/x-ms-vob": {
        source: "apache",
        extensions: ["vob"]
      },
      "video/x-ms-wm": {
        source: "apache",
        extensions: ["wm"]
      },
      "video/x-ms-wmv": {
        source: "apache",
        compressible: false,
        extensions: ["wmv"]
      },
      "video/x-ms-wmx": {
        source: "apache",
        extensions: ["wmx"]
      },
      "video/x-ms-wvx": {
        source: "apache",
        extensions: ["wvx"]
      },
      "video/x-msvideo": {
        source: "apache",
        extensions: ["avi"]
      },
      "video/x-sgi-movie": {
        source: "apache",
        extensions: ["movie"]
      },
      "video/x-smv": {
        source: "apache",
        extensions: ["smv"]
      },
      "x-conference/x-cooltalk": {
        source: "apache",
        extensions: ["ice"]
      },
      "x-shader/x-fragment": {
        compressible: true
      },
      "x-shader/x-vertex": {
        compressible: true
      }
    };
  }
});

// node_modules/mime-db/index.js
var require_mime_db = __commonJS({
  "node_modules/mime-db/index.js"(exports, module2) {
    module2.exports = require_db();
  }
});

// node_modules/mime-types/index.js
var require_mime_types = __commonJS({
  "node_modules/mime-types/index.js"(exports) {
    "use strict";
    var db = require_mime_db();
    var extname = require("path").extname;
    var EXTRACT_TYPE_REGEXP = /^\s*([^;\s]*)(?:;|\s|$)/;
    var TEXT_TYPE_REGEXP = /^text\//i;
    exports.charset = charset;
    exports.charsets = { lookup: charset };
    exports.contentType = contentType;
    exports.extension = extension;
    exports.extensions = /* @__PURE__ */ Object.create(null);
    exports.lookup = lookup;
    exports.types = /* @__PURE__ */ Object.create(null);
    populateMaps(exports.extensions, exports.types);
    function charset(type) {
      if (!type || typeof type !== "string") {
        return false;
      }
      var match = EXTRACT_TYPE_REGEXP.exec(type);
      var mime = match && db[match[1].toLowerCase()];
      if (mime && mime.charset) {
        return mime.charset;
      }
      if (match && TEXT_TYPE_REGEXP.test(match[1])) {
        return "UTF-8";
      }
      return false;
    }
    function contentType(str) {
      if (!str || typeof str !== "string") {
        return false;
      }
      var mime = str.indexOf("/") === -1 ? exports.lookup(str) : str;
      if (!mime) {
        return false;
      }
      if (mime.indexOf("charset") === -1) {
        var charset2 = exports.charset(mime);
        if (charset2)
          mime += "; charset=" + charset2.toLowerCase();
      }
      return mime;
    }
    function extension(type) {
      if (!type || typeof type !== "string") {
        return false;
      }
      var match = EXTRACT_TYPE_REGEXP.exec(type);
      var exts = match && exports.extensions[match[1].toLowerCase()];
      if (!exts || !exts.length) {
        return false;
      }
      return exts[0];
    }
    function lookup(path) {
      if (!path || typeof path !== "string") {
        return false;
      }
      var extension2 = extname("x." + path).toLowerCase().substr(1);
      if (!extension2) {
        return false;
      }
      return exports.types[extension2] || false;
    }
    function populateMaps(extensions, types) {
      var preference = ["nginx", "apache", void 0, "iana"];
      Object.keys(db).forEach(function forEachMimeType(type) {
        var mime = db[type];
        var exts = mime.extensions;
        if (!exts || !exts.length) {
          return;
        }
        extensions[type] = exts;
        for (var i = 0; i < exts.length; i++) {
          var extension2 = exts[i];
          if (types[extension2]) {
            var from = preference.indexOf(db[types[extension2]].source);
            var to = preference.indexOf(mime.source);
            if (types[extension2] !== "application/octet-stream" && (from > to || from === to && types[extension2].substr(0, 12) === "application/")) {
              continue;
            }
          }
          types[extension2] = type;
        }
      });
    }
  }
});

// node_modules/asynckit/lib/defer.js
var require_defer = __commonJS({
  "node_modules/asynckit/lib/defer.js"(exports, module2) {
    module2.exports = defer;
    function defer(fn) {
      var nextTick = typeof setImmediate == "function" ? setImmediate : typeof process == "object" && typeof process.nextTick == "function" ? process.nextTick : null;
      if (nextTick) {
        nextTick(fn);
      } else {
        setTimeout(fn, 0);
      }
    }
  }
});

// node_modules/asynckit/lib/async.js
var require_async = __commonJS({
  "node_modules/asynckit/lib/async.js"(exports, module2) {
    var defer = require_defer();
    module2.exports = async;
    function async(callback) {
      var isAsync = false;
      defer(function() {
        isAsync = true;
      });
      return function async_callback(err, result) {
        if (isAsync) {
          callback(err, result);
        } else {
          defer(function nextTick_callback() {
            callback(err, result);
          });
        }
      };
    }
  }
});

// node_modules/asynckit/lib/abort.js
var require_abort = __commonJS({
  "node_modules/asynckit/lib/abort.js"(exports, module2) {
    module2.exports = abort;
    function abort(state) {
      Object.keys(state.jobs).forEach(clean.bind(state));
      state.jobs = {};
    }
    function clean(key) {
      if (typeof this.jobs[key] == "function") {
        this.jobs[key]();
      }
    }
  }
});

// node_modules/asynckit/lib/iterate.js
var require_iterate = __commonJS({
  "node_modules/asynckit/lib/iterate.js"(exports, module2) {
    var async = require_async();
    var abort = require_abort();
    module2.exports = iterate;
    function iterate(list2, iterator, state, callback) {
      var key = state["keyedList"] ? state["keyedList"][state.index] : state.index;
      state.jobs[key] = runJob(iterator, key, list2[key], function(error, output) {
        if (!(key in state.jobs)) {
          return;
        }
        delete state.jobs[key];
        if (error) {
          abort(state);
        } else {
          state.results[key] = output;
        }
        callback(error, state.results);
      });
    }
    function runJob(iterator, key, item, callback) {
      var aborter;
      if (iterator.length == 2) {
        aborter = iterator(item, async(callback));
      } else {
        aborter = iterator(item, key, async(callback));
      }
      return aborter;
    }
  }
});

// node_modules/asynckit/lib/state.js
var require_state = __commonJS({
  "node_modules/asynckit/lib/state.js"(exports, module2) {
    module2.exports = state;
    function state(list2, sortMethod) {
      var isNamedList = !Array.isArray(list2), initState = {
        index: 0,
        keyedList: isNamedList || sortMethod ? Object.keys(list2) : null,
        jobs: {},
        results: isNamedList ? {} : [],
        size: isNamedList ? Object.keys(list2).length : list2.length
      };
      if (sortMethod) {
        initState.keyedList.sort(isNamedList ? sortMethod : function(a, b) {
          return sortMethod(list2[a], list2[b]);
        });
      }
      return initState;
    }
  }
});

// node_modules/asynckit/lib/terminator.js
var require_terminator = __commonJS({
  "node_modules/asynckit/lib/terminator.js"(exports, module2) {
    var abort = require_abort();
    var async = require_async();
    module2.exports = terminator;
    function terminator(callback) {
      if (!Object.keys(this.jobs).length) {
        return;
      }
      this.index = this.size;
      abort(this);
      async(callback)(null, this.results);
    }
  }
});

// node_modules/asynckit/parallel.js
var require_parallel = __commonJS({
  "node_modules/asynckit/parallel.js"(exports, module2) {
    var iterate = require_iterate();
    var initState = require_state();
    var terminator = require_terminator();
    module2.exports = parallel;
    function parallel(list2, iterator, callback) {
      var state = initState(list2);
      while (state.index < (state["keyedList"] || list2).length) {
        iterate(list2, iterator, state, function(error, result) {
          if (error) {
            callback(error, result);
            return;
          }
          if (Object.keys(state.jobs).length === 0) {
            callback(null, state.results);
            return;
          }
        });
        state.index++;
      }
      return terminator.bind(state, callback);
    }
  }
});

// node_modules/asynckit/serialOrdered.js
var require_serialOrdered = __commonJS({
  "node_modules/asynckit/serialOrdered.js"(exports, module2) {
    var iterate = require_iterate();
    var initState = require_state();
    var terminator = require_terminator();
    module2.exports = serialOrdered;
    module2.exports.ascending = ascending;
    module2.exports.descending = descending;
    function serialOrdered(list2, iterator, sortMethod, callback) {
      var state = initState(list2, sortMethod);
      iterate(list2, iterator, state, function iteratorHandler(error, result) {
        if (error) {
          callback(error, result);
          return;
        }
        state.index++;
        if (state.index < (state["keyedList"] || list2).length) {
          iterate(list2, iterator, state, iteratorHandler);
          return;
        }
        callback(null, state.results);
      });
      return terminator.bind(state, callback);
    }
    function ascending(a, b) {
      return a < b ? -1 : a > b ? 1 : 0;
    }
    function descending(a, b) {
      return -1 * ascending(a, b);
    }
  }
});

// node_modules/asynckit/serial.js
var require_serial = __commonJS({
  "node_modules/asynckit/serial.js"(exports, module2) {
    var serialOrdered = require_serialOrdered();
    module2.exports = serial;
    function serial(list2, iterator, callback) {
      return serialOrdered(list2, iterator, null, callback);
    }
  }
});

// node_modules/asynckit/index.js
var require_asynckit = __commonJS({
  "node_modules/asynckit/index.js"(exports, module2) {
    module2.exports = {
      parallel: require_parallel(),
      serial: require_serial(),
      serialOrdered: require_serialOrdered()
    };
  }
});

// node_modules/form-data/lib/populate.js
var require_populate = __commonJS({
  "node_modules/form-data/lib/populate.js"(exports, module2) {
    module2.exports = function(dst, src) {
      Object.keys(src).forEach(function(prop) {
        dst[prop] = dst[prop] || src[prop];
      });
      return dst;
    };
  }
});

// node_modules/form-data/lib/form_data.js
var require_form_data = __commonJS({
  "node_modules/form-data/lib/form_data.js"(exports, module2) {
    var CombinedStream = require_combined_stream();
    var util = require("util");
    var path = require("path");
    var http = require("http");
    var https = require("https");
    var parseUrl = require("url").parse;
    var fs = require("fs");
    var Stream = require("stream").Stream;
    var mime = require_mime_types();
    var asynckit = require_asynckit();
    var populate = require_populate();
    module2.exports = FormData2;
    util.inherits(FormData2, CombinedStream);
    function FormData2(options) {
      if (!(this instanceof FormData2)) {
        return new FormData2(options);
      }
      this._overheadLength = 0;
      this._valueLength = 0;
      this._valuesToMeasure = [];
      CombinedStream.call(this);
      options = options || {};
      for (var option in options) {
        this[option] = options[option];
      }
    }
    FormData2.LINE_BREAK = "\r\n";
    FormData2.DEFAULT_CONTENT_TYPE = "application/octet-stream";
    FormData2.prototype.append = function(field, value, options) {
      options = options || {};
      if (typeof options == "string") {
        options = { filename: options };
      }
      var append = CombinedStream.prototype.append.bind(this);
      if (typeof value == "number") {
        value = "" + value;
      }
      if (util.isArray(value)) {
        this._error(new Error("Arrays are not supported."));
        return;
      }
      var header = this._multiPartHeader(field, value, options);
      var footer = this._multiPartFooter();
      append(header);
      append(value);
      append(footer);
      this._trackLength(header, value, options);
    };
    FormData2.prototype._trackLength = function(header, value, options) {
      var valueLength = 0;
      if (options.knownLength != null) {
        valueLength += +options.knownLength;
      } else if (Buffer.isBuffer(value)) {
        valueLength = value.length;
      } else if (typeof value === "string") {
        valueLength = Buffer.byteLength(value);
      }
      this._valueLength += valueLength;
      this._overheadLength += Buffer.byteLength(header) + FormData2.LINE_BREAK.length;
      if (!value || !value.path && !(value.readable && value.hasOwnProperty("httpVersion")) && !(value instanceof Stream)) {
        return;
      }
      if (!options.knownLength) {
        this._valuesToMeasure.push(value);
      }
    };
    FormData2.prototype._lengthRetriever = function(value, callback) {
      if (value.hasOwnProperty("fd")) {
        if (value.end != void 0 && value.end != Infinity && value.start != void 0) {
          callback(null, value.end + 1 - (value.start ? value.start : 0));
        } else {
          fs.stat(value.path, function(err, stat) {
            var fileSize;
            if (err) {
              callback(err);
              return;
            }
            fileSize = stat.size - (value.start ? value.start : 0);
            callback(null, fileSize);
          });
        }
      } else if (value.hasOwnProperty("httpVersion")) {
        callback(null, +value.headers["content-length"]);
      } else if (value.hasOwnProperty("httpModule")) {
        value.on("response", function(response) {
          value.pause();
          callback(null, +response.headers["content-length"]);
        });
        value.resume();
      } else {
        callback("Unknown stream");
      }
    };
    FormData2.prototype._multiPartHeader = function(field, value, options) {
      if (typeof options.header == "string") {
        return options.header;
      }
      var contentDisposition = this._getContentDisposition(value, options);
      var contentType = this._getContentType(value, options);
      var contents = "";
      var headers = {
        // add custom disposition as third element or keep it two elements if not
        "Content-Disposition": ["form-data", 'name="' + field + '"'].concat(contentDisposition || []),
        // if no content type. allow it to be empty array
        "Content-Type": [].concat(contentType || [])
      };
      if (typeof options.header == "object") {
        populate(headers, options.header);
      }
      var header;
      for (var prop in headers) {
        if (!headers.hasOwnProperty(prop))
          continue;
        header = headers[prop];
        if (header == null) {
          continue;
        }
        if (!Array.isArray(header)) {
          header = [header];
        }
        if (header.length) {
          contents += prop + ": " + header.join("; ") + FormData2.LINE_BREAK;
        }
      }
      return "--" + this.getBoundary() + FormData2.LINE_BREAK + contents + FormData2.LINE_BREAK;
    };
    FormData2.prototype._getContentDisposition = function(value, options) {
      var filename, contentDisposition;
      if (typeof options.filepath === "string") {
        filename = path.normalize(options.filepath).replace(/\\/g, "/");
      } else if (options.filename || value.name || value.path) {
        filename = path.basename(options.filename || value.name || value.path);
      } else if (value.readable && value.hasOwnProperty("httpVersion")) {
        filename = path.basename(value.client._httpMessage.path || "");
      }
      if (filename) {
        contentDisposition = 'filename="' + filename + '"';
      }
      return contentDisposition;
    };
    FormData2.prototype._getContentType = function(value, options) {
      var contentType = options.contentType;
      if (!contentType && value.name) {
        contentType = mime.lookup(value.name);
      }
      if (!contentType && value.path) {
        contentType = mime.lookup(value.path);
      }
      if (!contentType && value.readable && value.hasOwnProperty("httpVersion")) {
        contentType = value.headers["content-type"];
      }
      if (!contentType && (options.filepath || options.filename)) {
        contentType = mime.lookup(options.filepath || options.filename);
      }
      if (!contentType && typeof value == "object") {
        contentType = FormData2.DEFAULT_CONTENT_TYPE;
      }
      return contentType;
    };
    FormData2.prototype._multiPartFooter = function() {
      return function(next) {
        var footer = FormData2.LINE_BREAK;
        var lastPart = this._streams.length === 0;
        if (lastPart) {
          footer += this._lastBoundary();
        }
        next(footer);
      }.bind(this);
    };
    FormData2.prototype._lastBoundary = function() {
      return "--" + this.getBoundary() + "--" + FormData2.LINE_BREAK;
    };
    FormData2.prototype.getHeaders = function(userHeaders) {
      var header;
      var formHeaders = {
        "content-type": "multipart/form-data; boundary=" + this.getBoundary()
      };
      for (header in userHeaders) {
        if (userHeaders.hasOwnProperty(header)) {
          formHeaders[header.toLowerCase()] = userHeaders[header];
        }
      }
      return formHeaders;
    };
    FormData2.prototype.setBoundary = function(boundary) {
      this._boundary = boundary;
    };
    FormData2.prototype.getBoundary = function() {
      if (!this._boundary) {
        this._generateBoundary();
      }
      return this._boundary;
    };
    FormData2.prototype.getBuffer = function() {
      var dataBuffer = new Buffer.alloc(0);
      var boundary = this.getBoundary();
      for (var i = 0, len = this._streams.length; i < len; i++) {
        if (typeof this._streams[i] !== "function") {
          if (Buffer.isBuffer(this._streams[i])) {
            dataBuffer = Buffer.concat([dataBuffer, this._streams[i]]);
          } else {
            dataBuffer = Buffer.concat([dataBuffer, Buffer.from(this._streams[i])]);
          }
          if (typeof this._streams[i] !== "string" || this._streams[i].substring(2, boundary.length + 2) !== boundary) {
            dataBuffer = Buffer.concat([dataBuffer, Buffer.from(FormData2.LINE_BREAK)]);
          }
        }
      }
      return Buffer.concat([dataBuffer, Buffer.from(this._lastBoundary())]);
    };
    FormData2.prototype._generateBoundary = function() {
      var boundary = "--------------------------";
      for (var i = 0; i < 24; i++) {
        boundary += Math.floor(Math.random() * 10).toString(16);
      }
      this._boundary = boundary;
    };
    FormData2.prototype.getLengthSync = function() {
      var knownLength = this._overheadLength + this._valueLength;
      if (this._streams.length) {
        knownLength += this._lastBoundary().length;
      }
      if (!this.hasKnownLength()) {
        this._error(new Error("Cannot calculate proper length in synchronous way."));
      }
      return knownLength;
    };
    FormData2.prototype.hasKnownLength = function() {
      var hasKnownLength = true;
      if (this._valuesToMeasure.length) {
        hasKnownLength = false;
      }
      return hasKnownLength;
    };
    FormData2.prototype.getLength = function(cb) {
      var knownLength = this._overheadLength + this._valueLength;
      if (this._streams.length) {
        knownLength += this._lastBoundary().length;
      }
      if (!this._valuesToMeasure.length) {
        process.nextTick(cb.bind(this, null, knownLength));
        return;
      }
      asynckit.parallel(this._valuesToMeasure, this._lengthRetriever, function(err, values) {
        if (err) {
          cb(err);
          return;
        }
        values.forEach(function(length) {
          knownLength += length;
        });
        cb(null, knownLength);
      });
    };
    FormData2.prototype.submit = function(params, cb) {
      var request, options, defaults = { method: "post" };
      if (typeof params == "string") {
        params = parseUrl(params);
        options = populate({
          port: params.port,
          path: params.pathname,
          host: params.hostname,
          protocol: params.protocol
        }, defaults);
      } else {
        options = populate(params, defaults);
        if (!options.port) {
          options.port = options.protocol == "https:" ? 443 : 80;
        }
      }
      options.headers = this.getHeaders(params.headers);
      if (options.protocol == "https:") {
        request = https.request(options);
      } else {
        request = http.request(options);
      }
      this.getLength(function(err, length) {
        if (err && err !== "Unknown stream") {
          this._error(err);
          return;
        }
        if (length) {
          request.setHeader("Content-Length", length);
        }
        this.pipe(request);
        if (cb) {
          var onResponse;
          var callback = function(error, responce) {
            request.removeListener("error", callback);
            request.removeListener("response", onResponse);
            return cb.call(this, error, responce);
          };
          onResponse = callback.bind(this, null);
          request.on("error", callback);
          request.on("response", onResponse);
        }
      }.bind(this));
      return request;
    };
    FormData2.prototype._error = function(err) {
      if (!this.error) {
        this.error = err;
        this.pause();
        this.emit("error", err);
      }
    };
    FormData2.prototype.toString = function() {
      return "[object FormData]";
    };
  }
});

// node_modules/axios/lib/defaults/env/FormData.js
var require_FormData = __commonJS({
  "node_modules/axios/lib/defaults/env/FormData.js"(exports, module2) {
    module2.exports = require_form_data();
  }
});

// node_modules/axios/lib/defaults/index.js
var require_defaults = __commonJS({
  "node_modules/axios/lib/defaults/index.js"(exports, module2) {
    "use strict";
    var utils = require_utils();
    var normalizeHeaderName = require_normalizeHeaderName();
    var AxiosError2 = require_AxiosError();
    var transitionalDefaults = require_transitional();
    var toFormData = require_toFormData();
    var DEFAULT_CONTENT_TYPE = {
      "Content-Type": "application/x-www-form-urlencoded"
    };
    function setContentTypeIfUnset(headers, value) {
      if (!utils.isUndefined(headers) && utils.isUndefined(headers["Content-Type"])) {
        headers["Content-Type"] = value;
      }
    }
    function getDefaultAdapter() {
      var adapter;
      if (typeof XMLHttpRequest !== "undefined") {
        adapter = require_xhr();
      } else if (typeof process !== "undefined" && Object.prototype.toString.call(process) === "[object process]") {
        adapter = require_http();
      }
      return adapter;
    }
    function stringifySafely(rawValue, parser, encoder) {
      if (utils.isString(rawValue)) {
        try {
          (parser || JSON.parse)(rawValue);
          return utils.trim(rawValue);
        } catch (e) {
          if (e.name !== "SyntaxError") {
            throw e;
          }
        }
      }
      return (encoder || JSON.stringify)(rawValue);
    }
    var defaults = {
      transitional: transitionalDefaults,
      adapter: getDefaultAdapter(),
      transformRequest: [function transformRequest(data, headers) {
        normalizeHeaderName(headers, "Accept");
        normalizeHeaderName(headers, "Content-Type");
        if (utils.isFormData(data) || utils.isArrayBuffer(data) || utils.isBuffer(data) || utils.isStream(data) || utils.isFile(data) || utils.isBlob(data)) {
          return data;
        }
        if (utils.isArrayBufferView(data)) {
          return data.buffer;
        }
        if (utils.isURLSearchParams(data)) {
          setContentTypeIfUnset(headers, "application/x-www-form-urlencoded;charset=utf-8");
          return data.toString();
        }
        var isObjectPayload = utils.isObject(data);
        var contentType = headers && headers["Content-Type"];
        var isFileList;
        if ((isFileList = utils.isFileList(data)) || isObjectPayload && contentType === "multipart/form-data") {
          var _FormData = this.env && this.env.FormData;
          return toFormData(isFileList ? { "files[]": data } : data, _FormData && new _FormData());
        } else if (isObjectPayload || contentType === "application/json") {
          setContentTypeIfUnset(headers, "application/json");
          return stringifySafely(data);
        }
        return data;
      }],
      transformResponse: [function transformResponse(data) {
        var transitional = this.transitional || defaults.transitional;
        var silentJSONParsing = transitional && transitional.silentJSONParsing;
        var forcedJSONParsing = transitional && transitional.forcedJSONParsing;
        var strictJSONParsing = !silentJSONParsing && this.responseType === "json";
        if (strictJSONParsing || forcedJSONParsing && utils.isString(data) && data.length) {
          try {
            return JSON.parse(data);
          } catch (e) {
            if (strictJSONParsing) {
              if (e.name === "SyntaxError") {
                throw AxiosError2.from(e, AxiosError2.ERR_BAD_RESPONSE, this, null, this.response);
              }
              throw e;
            }
          }
        }
        return data;
      }],
      /**
       * A timeout in milliseconds to abort a request. If set to 0 (default) a
       * timeout is not created.
       */
      timeout: 0,
      xsrfCookieName: "XSRF-TOKEN",
      xsrfHeaderName: "X-XSRF-TOKEN",
      maxContentLength: -1,
      maxBodyLength: -1,
      env: {
        FormData: require_FormData()
      },
      validateStatus: function validateStatus(status) {
        return status >= 200 && status < 300;
      },
      headers: {
        common: {
          "Accept": "application/json, text/plain, */*"
        }
      }
    };
    utils.forEach(["delete", "get", "head"], function forEachMethodNoData(method) {
      defaults.headers[method] = {};
    });
    utils.forEach(["post", "put", "patch"], function forEachMethodWithData(method) {
      defaults.headers[method] = utils.merge(DEFAULT_CONTENT_TYPE);
    });
    module2.exports = defaults;
  }
});

// node_modules/axios/lib/core/transformData.js
var require_transformData = __commonJS({
  "node_modules/axios/lib/core/transformData.js"(exports, module2) {
    "use strict";
    var utils = require_utils();
    var defaults = require_defaults();
    module2.exports = function transformData(data, headers, fns) {
      var context = this || defaults;
      utils.forEach(fns, function transform2(fn) {
        data = fn.call(context, data, headers);
      });
      return data;
    };
  }
});

// node_modules/axios/lib/cancel/isCancel.js
var require_isCancel = __commonJS({
  "node_modules/axios/lib/cancel/isCancel.js"(exports, module2) {
    "use strict";
    module2.exports = function isCancel(value) {
      return !!(value && value.__CANCEL__);
    };
  }
});

// node_modules/axios/lib/core/dispatchRequest.js
var require_dispatchRequest = __commonJS({
  "node_modules/axios/lib/core/dispatchRequest.js"(exports, module2) {
    "use strict";
    var utils = require_utils();
    var transformData = require_transformData();
    var isCancel = require_isCancel();
    var defaults = require_defaults();
    var CanceledError = require_CanceledError();
    function throwIfCancellationRequested(config) {
      if (config.cancelToken) {
        config.cancelToken.throwIfRequested();
      }
      if (config.signal && config.signal.aborted) {
        throw new CanceledError();
      }
    }
    module2.exports = function dispatchRequest(config) {
      throwIfCancellationRequested(config);
      config.headers = config.headers || {};
      config.data = transformData.call(
        config,
        config.data,
        config.headers,
        config.transformRequest
      );
      config.headers = utils.merge(
        config.headers.common || {},
        config.headers[config.method] || {},
        config.headers
      );
      utils.forEach(
        ["delete", "get", "head", "post", "put", "patch", "common"],
        function cleanHeaderConfig(method) {
          delete config.headers[method];
        }
      );
      var adapter = config.adapter || defaults.adapter;
      return adapter(config).then(function onAdapterResolution(response) {
        throwIfCancellationRequested(config);
        response.data = transformData.call(
          config,
          response.data,
          response.headers,
          config.transformResponse
        );
        return response;
      }, function onAdapterRejection(reason) {
        if (!isCancel(reason)) {
          throwIfCancellationRequested(config);
          if (reason && reason.response) {
            reason.response.data = transformData.call(
              config,
              reason.response.data,
              reason.response.headers,
              config.transformResponse
            );
          }
        }
        return Promise.reject(reason);
      });
    };
  }
});

// node_modules/axios/lib/core/mergeConfig.js
var require_mergeConfig = __commonJS({
  "node_modules/axios/lib/core/mergeConfig.js"(exports, module2) {
    "use strict";
    var utils = require_utils();
    module2.exports = function mergeConfig(config1, config2) {
      config2 = config2 || {};
      var config = {};
      function getMergedValue(target, source) {
        if (utils.isPlainObject(target) && utils.isPlainObject(source)) {
          return utils.merge(target, source);
        } else if (utils.isPlainObject(source)) {
          return utils.merge({}, source);
        } else if (utils.isArray(source)) {
          return source.slice();
        }
        return source;
      }
      function mergeDeepProperties(prop) {
        if (!utils.isUndefined(config2[prop])) {
          return getMergedValue(config1[prop], config2[prop]);
        } else if (!utils.isUndefined(config1[prop])) {
          return getMergedValue(void 0, config1[prop]);
        }
      }
      function valueFromConfig2(prop) {
        if (!utils.isUndefined(config2[prop])) {
          return getMergedValue(void 0, config2[prop]);
        }
      }
      function defaultToConfig2(prop) {
        if (!utils.isUndefined(config2[prop])) {
          return getMergedValue(void 0, config2[prop]);
        } else if (!utils.isUndefined(config1[prop])) {
          return getMergedValue(void 0, config1[prop]);
        }
      }
      function mergeDirectKeys(prop) {
        if (prop in config2) {
          return getMergedValue(config1[prop], config2[prop]);
        } else if (prop in config1) {
          return getMergedValue(void 0, config1[prop]);
        }
      }
      var mergeMap = {
        "url": valueFromConfig2,
        "method": valueFromConfig2,
        "data": valueFromConfig2,
        "baseURL": defaultToConfig2,
        "transformRequest": defaultToConfig2,
        "transformResponse": defaultToConfig2,
        "paramsSerializer": defaultToConfig2,
        "timeout": defaultToConfig2,
        "timeoutMessage": defaultToConfig2,
        "withCredentials": defaultToConfig2,
        "adapter": defaultToConfig2,
        "responseType": defaultToConfig2,
        "xsrfCookieName": defaultToConfig2,
        "xsrfHeaderName": defaultToConfig2,
        "onUploadProgress": defaultToConfig2,
        "onDownloadProgress": defaultToConfig2,
        "decompress": defaultToConfig2,
        "maxContentLength": defaultToConfig2,
        "maxBodyLength": defaultToConfig2,
        "beforeRedirect": defaultToConfig2,
        "transport": defaultToConfig2,
        "httpAgent": defaultToConfig2,
        "httpsAgent": defaultToConfig2,
        "cancelToken": defaultToConfig2,
        "socketPath": defaultToConfig2,
        "responseEncoding": defaultToConfig2,
        "validateStatus": mergeDirectKeys
      };
      utils.forEach(Object.keys(config1).concat(Object.keys(config2)), function computeConfigValue(prop) {
        var merge = mergeMap[prop] || mergeDeepProperties;
        var configValue = merge(prop);
        utils.isUndefined(configValue) && merge !== mergeDirectKeys || (config[prop] = configValue);
      });
      return config;
    };
  }
});

// node_modules/axios/lib/helpers/validator.js
var require_validator = __commonJS({
  "node_modules/axios/lib/helpers/validator.js"(exports, module2) {
    "use strict";
    var VERSION = require_data().version;
    var AxiosError2 = require_AxiosError();
    var validators = {};
    ["object", "boolean", "number", "function", "string", "symbol"].forEach(function(type, i) {
      validators[type] = function validator(thing) {
        return typeof thing === type || "a" + (i < 1 ? "n " : " ") + type;
      };
    });
    var deprecatedWarnings = {};
    validators.transitional = function transitional(validator, version, message) {
      function formatMessage(opt, desc) {
        return "[Axios v" + VERSION + "] Transitional option '" + opt + "'" + desc + (message ? ". " + message : "");
      }
      return function(value, opt, opts) {
        if (validator === false) {
          throw new AxiosError2(
            formatMessage(opt, " has been removed" + (version ? " in " + version : "")),
            AxiosError2.ERR_DEPRECATED
          );
        }
        if (version && !deprecatedWarnings[opt]) {
          deprecatedWarnings[opt] = true;
          console.warn(
            formatMessage(
              opt,
              " has been deprecated since v" + version + " and will be removed in the near future"
            )
          );
        }
        return validator ? validator(value, opt, opts) : true;
      };
    };
    function assertOptions(options, schema, allowUnknown) {
      if (typeof options !== "object") {
        throw new AxiosError2("options must be an object", AxiosError2.ERR_BAD_OPTION_VALUE);
      }
      var keys2 = Object.keys(options);
      var i = keys2.length;
      while (i-- > 0) {
        var opt = keys2[i];
        var validator = schema[opt];
        if (validator) {
          var value = options[opt];
          var result = value === void 0 || validator(value, opt, options);
          if (result !== true) {
            throw new AxiosError2("option " + opt + " must be " + result, AxiosError2.ERR_BAD_OPTION_VALUE);
          }
          continue;
        }
        if (allowUnknown !== true) {
          throw new AxiosError2("Unknown option " + opt, AxiosError2.ERR_BAD_OPTION);
        }
      }
    }
    module2.exports = {
      assertOptions,
      validators
    };
  }
});

// node_modules/axios/lib/core/Axios.js
var require_Axios = __commonJS({
  "node_modules/axios/lib/core/Axios.js"(exports, module2) {
    "use strict";
    var utils = require_utils();
    var buildURL = require_buildURL();
    var InterceptorManager = require_InterceptorManager();
    var dispatchRequest = require_dispatchRequest();
    var mergeConfig = require_mergeConfig();
    var buildFullPath = require_buildFullPath();
    var validator = require_validator();
    var validators = validator.validators;
    function Axios(instanceConfig) {
      this.defaults = instanceConfig;
      this.interceptors = {
        request: new InterceptorManager(),
        response: new InterceptorManager()
      };
    }
    Axios.prototype.request = function request(configOrUrl, config) {
      if (typeof configOrUrl === "string") {
        config = config || {};
        config.url = configOrUrl;
      } else {
        config = configOrUrl || {};
      }
      config = mergeConfig(this.defaults, config);
      if (config.method) {
        config.method = config.method.toLowerCase();
      } else if (this.defaults.method) {
        config.method = this.defaults.method.toLowerCase();
      } else {
        config.method = "get";
      }
      var transitional = config.transitional;
      if (transitional !== void 0) {
        validator.assertOptions(transitional, {
          silentJSONParsing: validators.transitional(validators.boolean),
          forcedJSONParsing: validators.transitional(validators.boolean),
          clarifyTimeoutError: validators.transitional(validators.boolean)
        }, false);
      }
      var requestInterceptorChain = [];
      var synchronousRequestInterceptors = true;
      this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) {
        if (typeof interceptor.runWhen === "function" && interceptor.runWhen(config) === false) {
          return;
        }
        synchronousRequestInterceptors = synchronousRequestInterceptors && interceptor.synchronous;
        requestInterceptorChain.unshift(interceptor.fulfilled, interceptor.rejected);
      });
      var responseInterceptorChain = [];
      this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) {
        responseInterceptorChain.push(interceptor.fulfilled, interceptor.rejected);
      });
      var promise;
      if (!synchronousRequestInterceptors) {
        var chain = [dispatchRequest, void 0];
        Array.prototype.unshift.apply(chain, requestInterceptorChain);
        chain = chain.concat(responseInterceptorChain);
        promise = Promise.resolve(config);
        while (chain.length) {
          promise = promise.then(chain.shift(), chain.shift());
        }
        return promise;
      }
      var newConfig = config;
      while (requestInterceptorChain.length) {
        var onFulfilled = requestInterceptorChain.shift();
        var onRejected = requestInterceptorChain.shift();
        try {
          newConfig = onFulfilled(newConfig);
        } catch (error) {
          onRejected(error);
          break;
        }
      }
      try {
        promise = dispatchRequest(newConfig);
      } catch (error) {
        return Promise.reject(error);
      }
      while (responseInterceptorChain.length) {
        promise = promise.then(responseInterceptorChain.shift(), responseInterceptorChain.shift());
      }
      return promise;
    };
    Axios.prototype.getUri = function getUri(config) {
      config = mergeConfig(this.defaults, config);
      var fullPath = buildFullPath(config.baseURL, config.url);
      return buildURL(fullPath, config.params, config.paramsSerializer);
    };
    utils.forEach(["delete", "get", "head", "options"], function forEachMethodNoData(method) {
      Axios.prototype[method] = function(url, config) {
        return this.request(mergeConfig(config || {}, {
          method,
          url,
          data: (config || {}).data
        }));
      };
    });
    utils.forEach(["post", "put", "patch"], function forEachMethodWithData(method) {
      function generateHTTPMethod(isForm) {
        return function httpMethod(url, data, config) {
          return this.request(mergeConfig(config || {}, {
            method,
            headers: isForm ? {
              "Content-Type": "multipart/form-data"
            } : {},
            url,
            data
          }));
        };
      }
      Axios.prototype[method] = generateHTTPMethod();
      Axios.prototype[method + "Form"] = generateHTTPMethod(true);
    });
    module2.exports = Axios;
  }
});

// node_modules/axios/lib/cancel/CancelToken.js
var require_CancelToken = __commonJS({
  "node_modules/axios/lib/cancel/CancelToken.js"(exports, module2) {
    "use strict";
    var CanceledError = require_CanceledError();
    function CancelToken(executor) {
      if (typeof executor !== "function") {
        throw new TypeError("executor must be a function.");
      }
      var resolvePromise;
      this.promise = new Promise(function promiseExecutor(resolve) {
        resolvePromise = resolve;
      });
      var token = this;
      this.promise.then(function(cancel) {
        if (!token._listeners)
          return;
        var i;
        var l = token._listeners.length;
        for (i = 0; i < l; i++) {
          token._listeners[i](cancel);
        }
        token._listeners = null;
      });
      this.promise.then = function(onfulfilled) {
        var _resolve;
        var promise = new Promise(function(resolve) {
          token.subscribe(resolve);
          _resolve = resolve;
        }).then(onfulfilled);
        promise.cancel = function reject() {
          token.unsubscribe(_resolve);
        };
        return promise;
      };
      executor(function cancel(message) {
        if (token.reason) {
          return;
        }
        token.reason = new CanceledError(message);
        resolvePromise(token.reason);
      });
    }
    CancelToken.prototype.throwIfRequested = function throwIfRequested() {
      if (this.reason) {
        throw this.reason;
      }
    };
    CancelToken.prototype.subscribe = function subscribe(listener) {
      if (this.reason) {
        listener(this.reason);
        return;
      }
      if (this._listeners) {
        this._listeners.push(listener);
      } else {
        this._listeners = [listener];
      }
    };
    CancelToken.prototype.unsubscribe = function unsubscribe(listener) {
      if (!this._listeners) {
        return;
      }
      var index = this._listeners.indexOf(listener);
      if (index !== -1) {
        this._listeners.splice(index, 1);
      }
    };
    CancelToken.source = function source() {
      var cancel;
      var token = new CancelToken(function executor(c) {
        cancel = c;
      });
      return {
        token,
        cancel
      };
    };
    module2.exports = CancelToken;
  }
});

// node_modules/axios/lib/helpers/spread.js
var require_spread = __commonJS({
  "node_modules/axios/lib/helpers/spread.js"(exports, module2) {
    "use strict";
    module2.exports = function spread(callback) {
      return function wrap(arr) {
        return callback.apply(null, arr);
      };
    };
  }
});

// node_modules/axios/lib/helpers/isAxiosError.js
var require_isAxiosError = __commonJS({
  "node_modules/axios/lib/helpers/isAxiosError.js"(exports, module2) {
    "use strict";
    var utils = require_utils();
    module2.exports = function isAxiosError(payload) {
      return utils.isObject(payload) && payload.isAxiosError === true;
    };
  }
});

// node_modules/axios/lib/axios.js
var require_axios = __commonJS({
  "node_modules/axios/lib/axios.js"(exports, module2) {
    "use strict";
    var utils = require_utils();
    var bind = require_bind();
    var Axios = require_Axios();
    var mergeConfig = require_mergeConfig();
    var defaults = require_defaults();
    function createInstance(defaultConfig) {
      var context = new Axios(defaultConfig);
      var instance = bind(Axios.prototype.request, context);
      utils.extend(instance, Axios.prototype, context);
      utils.extend(instance, context);
      instance.create = function create(instanceConfig) {
        return createInstance(mergeConfig(defaultConfig, instanceConfig));
      };
      return instance;
    }
    var axios2 = createInstance(defaults);
    axios2.Axios = Axios;
    axios2.CanceledError = require_CanceledError();
    axios2.CancelToken = require_CancelToken();
    axios2.isCancel = require_isCancel();
    axios2.VERSION = require_data().version;
    axios2.toFormData = require_toFormData();
    axios2.AxiosError = require_AxiosError();
    axios2.Cancel = axios2.CanceledError;
    axios2.all = function all(promises) {
      return Promise.all(promises);
    };
    axios2.spread = require_spread();
    axios2.isAxiosError = require_isAxiosError();
    module2.exports = axios2;
    module2.exports.default = axios2;
  }
});

// node_modules/axios/index.js
var require_axios2 = __commonJS({
  "node_modules/axios/index.js"(exports, module2) {
    module2.exports = require_axios();
  }
});

// src/core/fetcher/Fetcher.ts
var import_axios, fetcher;
var init_Fetcher = __esm({
  "src/core/fetcher/Fetcher.ts"() {
    "use strict";
    import_axios = __toESM(require_axios2());
    fetcher = async (args) => {
      const headers = {};
      if (args.contentType != null) {
        headers["Content-Type"] = args.contentType;
      }
      if (args.headers != null) {
        for (const [key, value] of Object.entries(args.headers)) {
          if (value != null) {
            headers[key] = value;
          }
        }
      }
      try {
        const response = await (0, import_axios.default)({
          url: args.url,
          params: args.queryParameters,
          method: args.method,
          headers,
          data: args.body,
          validateStatus: () => true,
          transformResponse: (response2) => response2,
          timeout: args.timeoutMs ?? 6e4,
          transitional: {
            clarifyTimeoutError: true
          },
          withCredentials: args.withCredentials
        });
        let body;
        if (response.data != null && response.data.length > 0) {
          try {
            body = JSON.parse(response.data) ?? void 0;
          } catch {
            return {
              ok: false,
              error: {
                reason: "non-json",
                statusCode: response.status,
                rawBody: response.data
              }
            };
          }
        }
        if (response.status >= 200 && response.status < 300) {
          return {
            ok: true,
            body
          };
        } else {
          return {
            ok: false,
            error: {
              reason: "status-code",
              statusCode: response.status,
              body
            }
          };
        }
      } catch (error) {
        if (error.code === "ETIMEDOUT") {
          return {
            ok: false,
            error: {
              reason: "timeout"
            }
          };
        }
        return {
          ok: false,
          error: {
            reason: "unknown",
            errorMessage: error.message
          }
        };
      }
    };
  }
});

// src/core/fetcher/Supplier.ts
var Supplier;
var init_Supplier = __esm({
  "src/core/fetcher/Supplier.ts"() {
    "use strict";
    Supplier = {
      get: async (supplier) => {
        if (typeof supplier === "function") {
          return supplier();
        } else {
          return supplier;
        }
      }
    };
  }
});

// src/core/fetcher/index.ts
var init_fetcher = __esm({
  "src/core/fetcher/index.ts"() {
    "use strict";
    init_Fetcher();
    init_Supplier();
  }
});

// src/core/index.ts
var init_core = __esm({
  "src/core/index.ts"() {
    "use strict";
    init_schemas();
    init_auth();
    init_fetcher();
  }
});

// node_modules/url-join/lib/url-join.js
var require_url_join = __commonJS({
  "node_modules/url-join/lib/url-join.js"(exports, module2) {
    (function(name, context, definition) {
      if (typeof module2 !== "undefined" && module2.exports)
        module2.exports = definition();
      else if (typeof define === "function" && define.amd)
        define(definition);
      else
        context[name] = definition();
    })("urljoin", exports, function() {
      function normalize(strArray) {
        var resultArray = [];
        if (strArray.length === 0) {
          return "";
        }
        if (typeof strArray[0] !== "string") {
          throw new TypeError("Url must be a string. Received " + strArray[0]);
        }
        if (strArray[0].match(/^[^/:]+:\/*$/) && strArray.length > 1) {
          var first = strArray.shift();
          strArray[0] = first + strArray[0];
        }
        if (strArray[0].match(/^file:\/\/\//)) {
          strArray[0] = strArray[0].replace(/^([^/:]+):\/*/, "$1:///");
        } else {
          strArray[0] = strArray[0].replace(/^([^/:]+):\/*/, "$1://");
        }
        for (var i = 0; i < strArray.length; i++) {
          var component = strArray[i];
          if (typeof component !== "string") {
            throw new TypeError("Url must be a string. Received " + component);
          }
          if (component === "") {
            continue;
          }
          if (i > 0) {
            component = component.replace(/^[\/]+/, "");
          }
          if (i < strArray.length - 1) {
            component = component.replace(/[\/]+$/, "");
          } else {
            component = component.replace(/[\/]+$/, "/");
          }
          resultArray.push(component);
        }
        var str = resultArray.join("/");
        str = str.replace(/\/(\?|&|#[^!])/g, "$1");
        var parts = str.split("?");
        str = parts.shift() + (parts.length > 0 ? "?" : "") + parts.join("&");
        return str;
      }
      return function() {
        var input;
        if (typeof arguments[0] === "object") {
          input = arguments[0];
        } else {
          input = [].slice.call(arguments);
        }
        return normalize(input);
      };
    });
  }
});

// src/serialization/resources/admin/types/LoginRequest.ts
var LoginRequest;
var init_LoginRequest = __esm({
  "src/serialization/resources/admin/types/LoginRequest.ts"() {
    "use strict";
    init_core();
    LoginRequest = schemas_exports.object({
      name: schemas_exports.string()
    });
  }
});

// src/serialization/resources/admin/types/LoginResponse.ts
var LoginResponse;
var init_LoginResponse = __esm({
  "src/serialization/resources/admin/types/LoginResponse.ts"() {
    "use strict";
    init_core();
    LoginResponse = schemas_exports.object({
      url: schemas_exports.string()
    });
  }
});

// src/serialization/resources/admin/types/index.ts
var init_types = __esm({
  "src/serialization/resources/admin/types/index.ts"() {
    "use strict";
    init_LoginRequest();
    init_LoginResponse();
  }
});

// src/serialization/resources/admin/index.ts
var admin_exports2 = {};
__export(admin_exports2, {
  LoginRequest: () => LoginRequest,
  LoginResponse: () => LoginResponse
});
var init_admin = __esm({
  "src/serialization/resources/admin/index.ts"() {
    "use strict";
    init_types();
  }
});

// src/serialization/resources/cloud/types/BootstrapResponse.ts
var BootstrapResponse;
var init_BootstrapResponse = __esm({
  "src/serialization/resources/cloud/types/BootstrapResponse.ts"() {
    "use strict";
    init_core();
    BootstrapResponse = schemas_exports.object({
      cluster: schemas_exports.lazy(async () => (await Promise.resolve().then(() => (init_serialization(), serialization_exports))).cloud.BootstrapCluster),
      captcha: schemas_exports.lazyObject(async () => (await Promise.resolve().then(() => (init_serialization(), serialization_exports))).cloud.BootstrapCaptcha)
    });
  }
});

// src/serialization/resources/cloud/types/BootstrapCluster.ts
var BootstrapCluster2;
var init_BootstrapCluster = __esm({
  "src/serialization/resources/cloud/types/BootstrapCluster.ts"() {
    "use strict";
    init_core();
    BootstrapCluster2 = schemas_exports.enum_(["enterprise", "oss"]);
  }
});

// src/serialization/resources/cloud/types/BootstrapCaptcha.ts
var BootstrapCaptcha;
var init_BootstrapCaptcha = __esm({
  "src/serialization/resources/cloud/types/BootstrapCaptcha.ts"() {
    "use strict";
    init_core();
    BootstrapCaptcha = schemas_exports.object({
      turnstile: schemas_exports.lazyObject(async () => (await Promise.resolve().then(() => (init_serialization(), serialization_exports))).cloud.BootstrapCaptchaTurnstile).optional()
    });
  }
});

// src/serialization/resources/cloud/types/BootstrapCaptchaTurnstile.ts
var BootstrapCaptchaTurnstile;
var init_BootstrapCaptchaTurnstile = __esm({
  "src/serialization/resources/cloud/types/BootstrapCaptchaTurnstile.ts"() {
    "use strict";
    init_core();
    BootstrapCaptchaTurnstile = schemas_exports.object({
      siteKey: schemas_exports.property("site_key", schemas_exports.string())
    });
  }
});

// src/serialization/resources/cloud/types/index.ts
var init_types2 = __esm({
  "src/serialization/resources/cloud/types/index.ts"() {
    "use strict";
    init_BootstrapResponse();
    init_BootstrapCluster();
    init_BootstrapCaptcha();
    init_BootstrapCaptchaTurnstile();
  }
});

// src/serialization/resources/cloud/resources/games/resources/namespaces/types/CreateGameNamespaceRequest.ts
var CreateGameNamespaceRequest;
var init_CreateGameNamespaceRequest = __esm({
  "src/serialization/resources/cloud/resources/games/resources/namespaces/types/CreateGameNamespaceRequest.ts"() {
    "use strict";
    init_core();
    CreateGameNamespaceRequest = schemas_exports.object({
      displayName: schemas_exports.property("display_name", schemas_exports.string()),
      versionId: schemas_exports.property("version_id", schemas_exports.string()),
      nameId: schemas_exports.property("name_id", schemas_exports.string())
    });
  }
});

// src/serialization/resources/cloud/resources/games/resources/namespaces/types/CreateGameNamespaceResponse.ts
var CreateGameNamespaceResponse;
var init_CreateGameNamespaceResponse = __esm({
  "src/serialization/resources/cloud/resources/games/resources/namespaces/types/CreateGameNamespaceResponse.ts"() {
    "use strict";
    init_core();
    CreateGameNamespaceResponse = schemas_exports.object({
      namespaceId: schemas_exports.property("namespace_id", schemas_exports.string())
    });
  }
});

// src/serialization/resources/cloud/resources/games/resources/namespaces/types/ValidateGameNamespaceRequest.ts
var ValidateGameNamespaceRequest;
var init_ValidateGameNamespaceRequest = __esm({
  "src/serialization/resources/cloud/resources/games/resources/namespaces/types/ValidateGameNamespaceRequest.ts"() {
    "use strict";
    init_core();
    ValidateGameNamespaceRequest = schemas_exports.object({
      displayName: schemas_exports.property("display_name", schemas_exports.string()),
      nameId: schemas_exports.property("name_id", schemas_exports.string())
    });
  }
});

// src/serialization/resources/cloud/resources/games/resources/namespaces/types/ValidateGameNamespaceResponse.ts
var ValidateGameNamespaceResponse;
var init_ValidateGameNamespaceResponse = __esm({
  "src/serialization/resources/cloud/resources/games/resources/namespaces/types/ValidateGameNamespaceResponse.ts"() {
    "use strict";
    init_core();
    ValidateGameNamespaceResponse = schemas_exports.object({
      errors: schemas_exports.list(
        schemas_exports.lazyObject(async () => (await Promise.resolve().then(() => (init_serialization(), serialization_exports))).ValidationError)
      )
    });
  }
});

// src/serialization/resources/cloud/resources/games/resources/namespaces/types/GetGameNamespaceByIdResponse.ts
var GetGameNamespaceByIdResponse;
var init_GetGameNamespaceByIdResponse = __esm({
  "src/serialization/resources/cloud/resources/games/resources/namespaces/types/GetGameNamespaceByIdResponse.ts"() {
    "use strict";
    init_core();
    GetGameNamespaceByIdResponse = schemas_exports.object({
      namespace: schemas_exports.lazyObject(async () => (await Promise.resolve().then(() => (init_serialization(), serialization_exports))).cloud.NamespaceFull)
    });
  }
});

// src/serialization/resources/cloud/resources/games/resources/namespaces/types/UpdateNamespaceCdnAuthUserRequest.ts
var UpdateNamespaceCdnAuthUserRequest;
var init_UpdateNamespaceCdnAuthUserRequest = __esm({
  "src/serialization/resources/cloud/resources/games/resources/namespaces/types/UpdateNamespaceCdnAuthUserRequest.ts"() {
    "use strict";
    init_core();
    UpdateNamespaceCdnAuthUserRequest = schemas_exports.object({
      user: schemas_exports.string(),
      password: schemas_exports.string()
    });
  }
});

// src/serialization/resources/cloud/resources/games/resources/namespaces/types/SetNamespaceCdnAuthTypeRequest.ts
var SetNamespaceCdnAuthTypeRequest;
var init_SetNamespaceCdnAuthTypeRequest = __esm({
  "src/serialization/resources/cloud/resources/games/resources/namespaces/types/SetNamespaceCdnAuthTypeRequest.ts"() {
    "use strict";
    init_core();
    SetNamespaceCdnAuthTypeRequest = schemas_exports.object({
      authType: schemas_exports.property(
        "auth_type",
        schemas_exports.lazy(async () => (await Promise.resolve().then(() => (init_serialization(), serialization_exports))).cloud.CdnAuthType)
      )
    });
  }
});

// src/serialization/resources/cloud/resources/games/resources/namespaces/types/ToggleNamespaceDomainPublicAuthRequest.ts
var ToggleNamespaceDomainPublicAuthRequest;
var init_ToggleNamespaceDomainPublicAuthRequest = __esm({
  "src/serialization/resources/cloud/resources/games/resources/namespaces/types/ToggleNamespaceDomainPublicAuthRequest.ts"() {
    "use strict";
    init_core();
    ToggleNamespaceDomainPublicAuthRequest = schemas_exports.object({
      enabled: schemas_exports.boolean()
    });
  }
});

// src/serialization/resources/cloud/resources/games/resources/namespaces/types/AddNamespaceDomainRequest.ts
var AddNamespaceDomainRequest;
var init_AddNamespaceDomainRequest = __esm({
  "src/serialization/resources/cloud/resources/games/resources/namespaces/types/AddNamespaceDomainRequest.ts"() {
    "use strict";
    init_core();
    AddNamespaceDomainRequest = schemas_exports.object({
      domain: schemas_exports.string()
    });
  }
});

// src/serialization/resources/cloud/resources/games/resources/namespaces/types/UpdateGameNamespaceMatchmakerConfigRequest.ts
var UpdateGameNamespaceMatchmakerConfigRequest;
var init_UpdateGameNamespaceMatchmakerConfigRequest = __esm({
  "src/serialization/resources/cloud/resources/games/resources/namespaces/types/UpdateGameNamespaceMatchmakerConfigRequest.ts"() {
    "use strict";
    init_core();
    UpdateGameNamespaceMatchmakerConfigRequest = schemas_exports.object({
      lobbyCountMax: schemas_exports.property("lobby_count_max", schemas_exports.number()),
      maxPlayers: schemas_exports.property("max_players", schemas_exports.number())
    });
  }
});

// src/serialization/resources/cloud/resources/games/resources/namespaces/types/GetGameNamespaceVersionHistoryResponse.ts
var GetGameNamespaceVersionHistoryResponse;
var init_GetGameNamespaceVersionHistoryResponse = __esm({
  "src/serialization/resources/cloud/resources/games/resources/namespaces/types/GetGameNamespaceVersionHistoryResponse.ts"() {
    "use strict";
    init_core();
    GetGameNamespaceVersionHistoryResponse = schemas_exports.object({
      versions: schemas_exports.list(
        schemas_exports.lazyObject(async () => (await Promise.resolve().then(() => (init_serialization(), serialization_exports))).cloud.NamespaceVersion)
      )
    });
  }
});

// src/serialization/resources/cloud/resources/games/resources/namespaces/types/ValidateGameNamespaceMatchmakerConfigRequest.ts
var ValidateGameNamespaceMatchmakerConfigRequest;
var init_ValidateGameNamespaceMatchmakerConfigRequest = __esm({
  "src/serialization/resources/cloud/resources/games/resources/namespaces/types/ValidateGameNamespaceMatchmakerConfigRequest.ts"() {
    "use strict";
    init_core();
    ValidateGameNamespaceMatchmakerConfigRequest = schemas_exports.object({
      lobbyCountMax: schemas_exports.property("lobby_count_max", schemas_exports.number()),
      maxPlayers: schemas_exports.property("max_players", schemas_exports.number())
    });
  }
});

// src/serialization/resources/cloud/resources/games/resources/namespaces/types/ValidateGameNamespaceMatchmakerConfigResponse.ts
var ValidateGameNamespaceMatchmakerConfigResponse;
var init_ValidateGameNamespaceMatchmakerConfigResponse = __esm({
  "src/serialization/resources/cloud/resources/games/resources/namespaces/types/ValidateGameNamespaceMatchmakerConfigResponse.ts"() {
    "use strict";
    init_core();
    ValidateGameNamespaceMatchmakerConfigResponse = schemas_exports.object({
      errors: schemas_exports.list(
        schemas_exports.lazyObject(async () => (await Promise.resolve().then(() => (init_serialization(), serialization_exports))).ValidationError)
      )
    });
  }
});

// src/serialization/resources/cloud/resources/games/resources/namespaces/types/CreateGameNamespaceTokenDevelopmentRequest.ts
var CreateGameNamespaceTokenDevelopmentRequest;
var init_CreateGameNamespaceTokenDevelopmentRequest = __esm({
  "src/serialization/resources/cloud/resources/games/resources/namespaces/types/CreateGameNamespaceTokenDevelopmentRequest.ts"() {
    "use strict";
    init_core();
    CreateGameNamespaceTokenDevelopmentRequest = schemas_exports.object({
      hostname: schemas_exports.string(),
      ports: schemas_exports.record(
        schemas_exports.string(),
        schemas_exports.lazyObject(
          async () => (await Promise.resolve().then(() => (init_serialization(), serialization_exports))).cloud.MatchmakerDevelopmentPort
        )
      ).optional(),
      lobbyPorts: schemas_exports.property(
        "lobby_ports",
        schemas_exports.list(
          schemas_exports.lazyObject(
            async () => (await Promise.resolve().then(() => (init_serialization(), serialization_exports))).cloud.version.matchmaker.LobbyGroupRuntimeDockerPort
          )
        ).optional()
      )
    });
  }
});

// src/serialization/resources/cloud/resources/games/resources/namespaces/types/CreateGameNamespaceTokenDevelopmentResponse.ts
var CreateGameNamespaceTokenDevelopmentResponse;
var init_CreateGameNamespaceTokenDevelopmentResponse = __esm({
  "src/serialization/resources/cloud/resources/games/resources/namespaces/types/CreateGameNamespaceTokenDevelopmentResponse.ts"() {
    "use strict";
    init_core();
    CreateGameNamespaceTokenDevelopmentResponse = schemas_exports.object({
      token: schemas_exports.string()
    });
  }
});

// src/serialization/resources/cloud/resources/games/resources/namespaces/types/ValidateGameNamespaceTokenDevelopmentRequest.ts
var ValidateGameNamespaceTokenDevelopmentRequest;
var init_ValidateGameNamespaceTokenDevelopmentRequest = __esm({
  "src/serialization/resources/cloud/resources/games/resources/namespaces/types/ValidateGameNamespaceTokenDevelopmentRequest.ts"() {
    "use strict";
    init_core();
    ValidateGameNamespaceTokenDevelopmentRequest = schemas_exports.object({
      hostname: schemas_exports.string(),
      lobbyPorts: schemas_exports.property(
        "lobby_ports",
        schemas_exports.list(
          schemas_exports.lazyObject(
            async () => (await Promise.resolve().then(() => (init_serialization(), serialization_exports))).cloud.version.matchmaker.LobbyGroupRuntimeDockerPort
          )
        )
      )
    });
  }
});

// src/serialization/resources/cloud/resources/games/resources/namespaces/types/ValidateGameNamespaceTokenDevelopmentResponse.ts
var ValidateGameNamespaceTokenDevelopmentResponse;
var init_ValidateGameNamespaceTokenDevelopmentResponse = __esm({
  "src/serialization/resources/cloud/resources/games/resources/namespaces/types/ValidateGameNamespaceTokenDevelopmentResponse.ts"() {
    "use strict";
    init_core();
    ValidateGameNamespaceTokenDevelopmentResponse = schemas_exports.object({
      errors: schemas_exports.list(
        schemas_exports.lazyObject(async () => (await Promise.resolve().then(() => (init_serialization(), serialization_exports))).ValidationError)
      )
    });
  }
});

// src/serialization/resources/cloud/resources/games/resources/namespaces/types/CreateGameNamespaceTokenPublicResponse.ts
var CreateGameNamespaceTokenPublicResponse;
var init_CreateGameNamespaceTokenPublicResponse = __esm({
  "src/serialization/resources/cloud/resources/games/resources/namespaces/types/CreateGameNamespaceTokenPublicResponse.ts"() {
    "use strict";
    init_core();
    CreateGameNamespaceTokenPublicResponse = schemas_exports.object({
      token: schemas_exports.string()
    });
  }
});

// src/serialization/resources/cloud/resources/games/resources/namespaces/types/UpdateGameNamespaceVersionRequest.ts
var UpdateGameNamespaceVersionRequest;
var init_UpdateGameNamespaceVersionRequest = __esm({
  "src/serialization/resources/cloud/resources/games/resources/namespaces/types/UpdateGameNamespaceVersionRequest.ts"() {
    "use strict";
    init_core();
    UpdateGameNamespaceVersionRequest = schemas_exports.object({
      versionId: schemas_exports.property("version_id", schemas_exports.string())
    });
  }
});

// src/serialization/resources/cloud/resources/games/resources/namespaces/types/index.ts
var init_types3 = __esm({
  "src/serialization/resources/cloud/resources/games/resources/namespaces/types/index.ts"() {
    "use strict";
    init_CreateGameNamespaceRequest();
    init_CreateGameNamespaceResponse();
    init_ValidateGameNamespaceRequest();
    init_ValidateGameNamespaceResponse();
    init_GetGameNamespaceByIdResponse();
    init_UpdateNamespaceCdnAuthUserRequest();
    init_SetNamespaceCdnAuthTypeRequest();
    init_ToggleNamespaceDomainPublicAuthRequest();
    init_AddNamespaceDomainRequest();
    init_UpdateGameNamespaceMatchmakerConfigRequest();
    init_GetGameNamespaceVersionHistoryResponse();
    init_ValidateGameNamespaceMatchmakerConfigRequest();
    init_ValidateGameNamespaceMatchmakerConfigResponse();
    init_CreateGameNamespaceTokenDevelopmentRequest();
    init_CreateGameNamespaceTokenDevelopmentResponse();
    init_ValidateGameNamespaceTokenDevelopmentRequest();
    init_ValidateGameNamespaceTokenDevelopmentResponse();
    init_CreateGameNamespaceTokenPublicResponse();
    init_UpdateGameNamespaceVersionRequest();
  }
});

// src/serialization/resources/cloud/resources/games/resources/namespaces/resources/analytics/types/GetAnalyticsMatchmakerLiveResponse.ts
var GetAnalyticsMatchmakerLiveResponse;
var init_GetAnalyticsMatchmakerLiveResponse = __esm({
  "src/serialization/resources/cloud/resources/games/resources/namespaces/resources/analytics/types/GetAnalyticsMatchmakerLiveResponse.ts"() {
    "use strict";
    init_core();
    GetAnalyticsMatchmakerLiveResponse = schemas_exports.object({
      lobbies: schemas_exports.list(
        schemas_exports.lazyObject(
          async () => (await Promise.resolve().then(() => (init_serialization(), serialization_exports))).cloud.LobbySummaryAnalytics
        )
      )
    });
  }
});

// src/serialization/resources/cloud/resources/games/resources/namespaces/resources/analytics/types/index.ts
var init_types4 = __esm({
  "src/serialization/resources/cloud/resources/games/resources/namespaces/resources/analytics/types/index.ts"() {
    "use strict";
    init_GetAnalyticsMatchmakerLiveResponse();
  }
});

// src/serialization/resources/cloud/resources/games/resources/namespaces/resources/analytics/index.ts
var analytics_exports2 = {};
__export(analytics_exports2, {
  GetAnalyticsMatchmakerLiveResponse: () => GetAnalyticsMatchmakerLiveResponse
});
var init_analytics = __esm({
  "src/serialization/resources/cloud/resources/games/resources/namespaces/resources/analytics/index.ts"() {
    "use strict";
    init_types4();
  }
});

// src/serialization/resources/cloud/resources/games/resources/namespaces/resources/logs/types/ListNamespaceLobbiesResponse.ts
var ListNamespaceLobbiesResponse;
var init_ListNamespaceLobbiesResponse = __esm({
  "src/serialization/resources/cloud/resources/games/resources/namespaces/resources/logs/types/ListNamespaceLobbiesResponse.ts"() {
    "use strict";
    init_core();
    ListNamespaceLobbiesResponse = schemas_exports.object({
      lobbies: schemas_exports.list(
        schemas_exports.lazyObject(async () => (await Promise.resolve().then(() => (init_serialization(), serialization_exports))).cloud.LogsLobbySummary)
      )
    });
  }
});

// src/serialization/resources/cloud/resources/games/resources/namespaces/resources/logs/types/GetNamespaceLobbyResponse.ts
var GetNamespaceLobbyResponse;
var init_GetNamespaceLobbyResponse = __esm({
  "src/serialization/resources/cloud/resources/games/resources/namespaces/resources/logs/types/GetNamespaceLobbyResponse.ts"() {
    "use strict";
    init_core();
    GetNamespaceLobbyResponse = schemas_exports.object({
      lobby: schemas_exports.lazyObject(
        async () => (await Promise.resolve().then(() => (init_serialization(), serialization_exports))).cloud.LogsLobbySummary
      ),
      metrics: schemas_exports.lazyObject(async () => (await Promise.resolve().then(() => (init_serialization(), serialization_exports))).cloud.SvcMetrics).optional(),
      stdoutPresignedUrls: schemas_exports.property(
        "stdout_presigned_urls",
        schemas_exports.list(schemas_exports.string())
      ),
      stderrPresignedUrls: schemas_exports.property(
        "stderr_presigned_urls",
        schemas_exports.list(schemas_exports.string())
      ),
      perfLists: schemas_exports.property(
        "perf_lists",
        schemas_exports.list(
          schemas_exports.lazyObject(async () => (await Promise.resolve().then(() => (init_serialization(), serialization_exports))).cloud.SvcPerf)
        )
      )
    });
  }
});

// src/serialization/resources/cloud/resources/games/resources/namespaces/resources/logs/types/index.ts
var init_types5 = __esm({
  "src/serialization/resources/cloud/resources/games/resources/namespaces/resources/logs/types/index.ts"() {
    "use strict";
    init_ListNamespaceLobbiesResponse();
    init_GetNamespaceLobbyResponse();
  }
});

// src/serialization/resources/cloud/resources/games/resources/namespaces/resources/logs/index.ts
var logs_exports3 = {};
__export(logs_exports3, {
  GetNamespaceLobbyResponse: () => GetNamespaceLobbyResponse,
  ListNamespaceLobbiesResponse: () => ListNamespaceLobbiesResponse
});
var init_logs = __esm({
  "src/serialization/resources/cloud/resources/games/resources/namespaces/resources/logs/index.ts"() {
    "use strict";
    init_types5();
  }
});

// src/serialization/resources/cloud/resources/games/resources/namespaces/resources/index.ts
var init_resources = __esm({
  "src/serialization/resources/cloud/resources/games/resources/namespaces/resources/index.ts"() {
    "use strict";
    init_analytics();
    init_types4();
    init_logs();
    init_types5();
  }
});

// src/serialization/resources/cloud/resources/games/resources/namespaces/index.ts
var namespaces_exports2 = {};
__export(namespaces_exports2, {
  AddNamespaceDomainRequest: () => AddNamespaceDomainRequest,
  CreateGameNamespaceRequest: () => CreateGameNamespaceRequest,
  CreateGameNamespaceResponse: () => CreateGameNamespaceResponse,
  CreateGameNamespaceTokenDevelopmentRequest: () => CreateGameNamespaceTokenDevelopmentRequest,
  CreateGameNamespaceTokenDevelopmentResponse: () => CreateGameNamespaceTokenDevelopmentResponse,
  CreateGameNamespaceTokenPublicResponse: () => CreateGameNamespaceTokenPublicResponse,
  GetAnalyticsMatchmakerLiveResponse: () => GetAnalyticsMatchmakerLiveResponse,
  GetGameNamespaceByIdResponse: () => GetGameNamespaceByIdResponse,
  GetGameNamespaceVersionHistoryResponse: () => GetGameNamespaceVersionHistoryResponse,
  GetNamespaceLobbyResponse: () => GetNamespaceLobbyResponse,
  ListNamespaceLobbiesResponse: () => ListNamespaceLobbiesResponse,
  SetNamespaceCdnAuthTypeRequest: () => SetNamespaceCdnAuthTypeRequest,
  ToggleNamespaceDomainPublicAuthRequest: () => ToggleNamespaceDomainPublicAuthRequest,
  UpdateGameNamespaceMatchmakerConfigRequest: () => UpdateGameNamespaceMatchmakerConfigRequest,
  UpdateGameNamespaceVersionRequest: () => UpdateGameNamespaceVersionRequest,
  UpdateNamespaceCdnAuthUserRequest: () => UpdateNamespaceCdnAuthUserRequest,
  ValidateGameNamespaceMatchmakerConfigRequest: () => ValidateGameNamespaceMatchmakerConfigRequest,
  ValidateGameNamespaceMatchmakerConfigResponse: () => ValidateGameNamespaceMatchmakerConfigResponse,
  ValidateGameNamespaceRequest: () => ValidateGameNamespaceRequest,
  ValidateGameNamespaceResponse: () => ValidateGameNamespaceResponse,
  ValidateGameNamespaceTokenDevelopmentRequest: () => ValidateGameNamespaceTokenDevelopmentRequest,
  ValidateGameNamespaceTokenDevelopmentResponse: () => ValidateGameNamespaceTokenDevelopmentResponse,
  analytics: () => analytics_exports2,
  logs: () => logs_exports3
});
var init_namespaces = __esm({
  "src/serialization/resources/cloud/resources/games/resources/namespaces/index.ts"() {
    "use strict";
    init_types3();
    init_resources();
  }
});

// src/serialization/resources/cloud/resources/games/resources/avatars/types/ListGameCustomAvatarsResponse.ts
var ListGameCustomAvatarsResponse;
var init_ListGameCustomAvatarsResponse = __esm({
  "src/serialization/resources/cloud/resources/games/resources/avatars/types/ListGameCustomAvatarsResponse.ts"() {
    "use strict";
    init_core();
    ListGameCustomAvatarsResponse = schemas_exports.object({
      customAvatars: schemas_exports.property(
        "custom_avatars",
        schemas_exports.list(
          schemas_exports.lazyObject(async () => (await Promise.resolve().then(() => (init_serialization(), serialization_exports))).cloud.CustomAvatarSummary)
        )
      )
    });
  }
});

// src/serialization/resources/cloud/resources/games/resources/avatars/types/PrepareCustomAvatarUploadRequest.ts
var PrepareCustomAvatarUploadRequest;
var init_PrepareCustomAvatarUploadRequest = __esm({
  "src/serialization/resources/cloud/resources/games/resources/avatars/types/PrepareCustomAvatarUploadRequest.ts"() {
    "use strict";
    init_core();
    PrepareCustomAvatarUploadRequest = schemas_exports.object({
      path: schemas_exports.string(),
      mime: schemas_exports.string().optional(),
      contentLength: schemas_exports.property("content_length", schemas_exports.number())
    });
  }
});

// src/serialization/resources/cloud/resources/games/resources/avatars/types/PrepareCustomAvatarUploadResponse.ts
var PrepareCustomAvatarUploadResponse;
var init_PrepareCustomAvatarUploadResponse = __esm({
  "src/serialization/resources/cloud/resources/games/resources/avatars/types/PrepareCustomAvatarUploadResponse.ts"() {
    "use strict";
    init_core();
    PrepareCustomAvatarUploadResponse = schemas_exports.object({
      uploadId: schemas_exports.property("upload_id", schemas_exports.string()),
      presignedRequest: schemas_exports.property(
        "presigned_request",
        schemas_exports.lazyObject(async () => (await Promise.resolve().then(() => (init_serialization(), serialization_exports))).upload.PresignedRequest)
      )
    });
  }
});

// src/serialization/resources/cloud/resources/games/resources/avatars/types/index.ts
var init_types6 = __esm({
  "src/serialization/resources/cloud/resources/games/resources/avatars/types/index.ts"() {
    "use strict";
    init_ListGameCustomAvatarsResponse();
    init_PrepareCustomAvatarUploadRequest();
    init_PrepareCustomAvatarUploadResponse();
  }
});

// src/serialization/resources/cloud/resources/games/resources/avatars/index.ts
var avatars_exports2 = {};
__export(avatars_exports2, {
  ListGameCustomAvatarsResponse: () => ListGameCustomAvatarsResponse,
  PrepareCustomAvatarUploadRequest: () => PrepareCustomAvatarUploadRequest,
  PrepareCustomAvatarUploadResponse: () => PrepareCustomAvatarUploadResponse
});
var init_avatars = __esm({
  "src/serialization/resources/cloud/resources/games/resources/avatars/index.ts"() {
    "use strict";
    init_types6();
  }
});

// src/serialization/resources/cloud/resources/games/resources/builds/types/ListGameBuildsResponse.ts
var ListGameBuildsResponse;
var init_ListGameBuildsResponse = __esm({
  "src/serialization/resources/cloud/resources/games/resources/builds/types/ListGameBuildsResponse.ts"() {
    "use strict";
    init_core();
    ListGameBuildsResponse = schemas_exports.object({
      builds: schemas_exports.list(
        schemas_exports.lazyObject(async () => (await Promise.resolve().then(() => (init_serialization(), serialization_exports))).cloud.BuildSummary)
      )
    });
  }
});

// src/serialization/resources/cloud/resources/games/resources/builds/types/CreateGameBuildRequest.ts
var CreateGameBuildRequest;
var init_CreateGameBuildRequest = __esm({
  "src/serialization/resources/cloud/resources/games/resources/builds/types/CreateGameBuildRequest.ts"() {
    "use strict";
    init_core();
    CreateGameBuildRequest = schemas_exports.object({
      displayName: schemas_exports.property("display_name", schemas_exports.string()),
      imageTag: schemas_exports.property("image_tag", schemas_exports.string()),
      imageFile: schemas_exports.property(
        "image_file",
        schemas_exports.lazyObject(async () => (await Promise.resolve().then(() => (init_serialization(), serialization_exports))).upload.PrepareFile)
      ),
      multipartUpload: schemas_exports.property("multipart_upload", schemas_exports.boolean().optional()),
      kind: schemas_exports.lazy(async () => (await Promise.resolve().then(() => (init_serialization(), serialization_exports))).cloud.games.BuildKind).optional(),
      compression: schemas_exports.lazy(async () => (await Promise.resolve().then(() => (init_serialization(), serialization_exports))).cloud.games.BuildCompression).optional()
    });
  }
});

// src/serialization/resources/cloud/resources/games/resources/builds/types/CreateGameBuildResponse.ts
var CreateGameBuildResponse;
var init_CreateGameBuildResponse = __esm({
  "src/serialization/resources/cloud/resources/games/resources/builds/types/CreateGameBuildResponse.ts"() {
    "use strict";
    init_core();
    CreateGameBuildResponse = schemas_exports.object({
      buildId: schemas_exports.property("build_id", schemas_exports.string()),
      uploadId: schemas_exports.property("upload_id", schemas_exports.string()),
      imagePresignedRequest: schemas_exports.property(
        "image_presigned_request",
        schemas_exports.lazyObject(async () => (await Promise.resolve().then(() => (init_serialization(), serialization_exports))).upload.PresignedRequest).optional()
      ),
      imagePresignedRequests: schemas_exports.property(
        "image_presigned_requests",
        schemas_exports.list(
          schemas_exports.lazyObject(
            async () => (await Promise.resolve().then(() => (init_serialization(), serialization_exports))).upload.PresignedRequest
          )
        ).optional()
      )
    });
  }
});

// src/serialization/resources/cloud/resources/games/resources/builds/types/BuildKind.ts
var BuildKind2;
var init_BuildKind = __esm({
  "src/serialization/resources/cloud/resources/games/resources/builds/types/BuildKind.ts"() {
    "use strict";
    init_core();
    BuildKind2 = schemas_exports.enum_(["docker_image", "oci_bundle"]);
  }
});

// src/serialization/resources/cloud/resources/games/resources/builds/types/BuildCompression.ts
var BuildCompression2;
var init_BuildCompression = __esm({
  "src/serialization/resources/cloud/resources/games/resources/builds/types/BuildCompression.ts"() {
    "use strict";
    init_core();
    BuildCompression2 = schemas_exports.enum_(["none", "lz4"]);
  }
});

// src/serialization/resources/cloud/resources/games/resources/builds/types/index.ts
var init_types7 = __esm({
  "src/serialization/resources/cloud/resources/games/resources/builds/types/index.ts"() {
    "use strict";
    init_ListGameBuildsResponse();
    init_CreateGameBuildRequest();
    init_CreateGameBuildResponse();
    init_BuildKind();
    init_BuildCompression();
  }
});

// src/serialization/resources/cloud/resources/games/resources/builds/index.ts
var builds_exports2 = {};
__export(builds_exports2, {
  BuildCompression: () => BuildCompression2,
  BuildKind: () => BuildKind2,
  CreateGameBuildRequest: () => CreateGameBuildRequest,
  CreateGameBuildResponse: () => CreateGameBuildResponse,
  ListGameBuildsResponse: () => ListGameBuildsResponse
});
var init_builds = __esm({
  "src/serialization/resources/cloud/resources/games/resources/builds/index.ts"() {
    "use strict";
    init_types7();
  }
});

// src/serialization/resources/cloud/resources/games/resources/cdn/types/ListGameCdnSitesResponse.ts
var ListGameCdnSitesResponse;
var init_ListGameCdnSitesResponse = __esm({
  "src/serialization/resources/cloud/resources/games/resources/cdn/types/ListGameCdnSitesResponse.ts"() {
    "use strict";
    init_core();
    ListGameCdnSitesResponse = schemas_exports.object({
      sites: schemas_exports.list(
        schemas_exports.lazyObject(async () => (await Promise.resolve().then(() => (init_serialization(), serialization_exports))).cloud.CdnSiteSummary)
      )
    });
  }
});

// src/serialization/resources/cloud/resources/games/resources/cdn/types/CreateGameCdnSiteRequest.ts
var CreateGameCdnSiteRequest;
var init_CreateGameCdnSiteRequest = __esm({
  "src/serialization/resources/cloud/resources/games/resources/cdn/types/CreateGameCdnSiteRequest.ts"() {
    "use strict";
    init_core();
    CreateGameCdnSiteRequest = schemas_exports.object({
      displayName: schemas_exports.property("display_name", schemas_exports.string()),
      files: schemas_exports.list(
        schemas_exports.lazyObject(async () => (await Promise.resolve().then(() => (init_serialization(), serialization_exports))).upload.PrepareFile)
      )
    });
  }
});

// src/serialization/resources/cloud/resources/games/resources/cdn/types/CreateGameCdnSiteResponse.ts
var CreateGameCdnSiteResponse;
var init_CreateGameCdnSiteResponse = __esm({
  "src/serialization/resources/cloud/resources/games/resources/cdn/types/CreateGameCdnSiteResponse.ts"() {
    "use strict";
    init_core();
    CreateGameCdnSiteResponse = schemas_exports.object({
      siteId: schemas_exports.property("site_id", schemas_exports.string()),
      uploadId: schemas_exports.property("upload_id", schemas_exports.string()),
      presignedRequests: schemas_exports.property(
        "presigned_requests",
        schemas_exports.list(
          schemas_exports.lazyObject(async () => (await Promise.resolve().then(() => (init_serialization(), serialization_exports))).upload.PresignedRequest)
        )
      )
    });
  }
});

// src/serialization/resources/cloud/resources/games/resources/cdn/types/index.ts
var init_types8 = __esm({
  "src/serialization/resources/cloud/resources/games/resources/cdn/types/index.ts"() {
    "use strict";
    init_ListGameCdnSitesResponse();
    init_CreateGameCdnSiteRequest();
    init_CreateGameCdnSiteResponse();
  }
});

// src/serialization/resources/cloud/resources/games/resources/cdn/index.ts
var cdn_exports3 = {};
__export(cdn_exports3, {
  CreateGameCdnSiteRequest: () => CreateGameCdnSiteRequest,
  CreateGameCdnSiteResponse: () => CreateGameCdnSiteResponse,
  ListGameCdnSitesResponse: () => ListGameCdnSitesResponse
});
var init_cdn = __esm({
  "src/serialization/resources/cloud/resources/games/resources/cdn/index.ts"() {
    "use strict";
    init_types8();
  }
});

// src/serialization/resources/cloud/resources/games/resources/games/types/GetGamesResponse.ts
var GetGamesResponse;
var init_GetGamesResponse = __esm({
  "src/serialization/resources/cloud/resources/games/resources/games/types/GetGamesResponse.ts"() {
    "use strict";
    init_core();
    GetGamesResponse = schemas_exports.object({
      games: schemas_exports.list(
        schemas_exports.lazyObject(async () => (await Promise.resolve().then(() => (init_serialization(), serialization_exports))).game.Summary)
      ),
      groups: schemas_exports.list(
        schemas_exports.lazyObject(async () => (await Promise.resolve().then(() => (init_serialization(), serialization_exports))).group.Summary)
      ),
      watch: schemas_exports.lazyObject(async () => (await Promise.resolve().then(() => (init_serialization(), serialization_exports))).WatchResponse)
    });
  }
});

// src/serialization/resources/cloud/resources/games/resources/games/types/CreateGameRequest.ts
var CreateGameRequest;
var init_CreateGameRequest = __esm({
  "src/serialization/resources/cloud/resources/games/resources/games/types/CreateGameRequest.ts"() {
    "use strict";
    init_core();
    CreateGameRequest = schemas_exports.object({
      nameId: schemas_exports.property("name_id", schemas_exports.string()),
      displayName: schemas_exports.property("display_name", schemas_exports.string()),
      developerGroupId: schemas_exports.property("developer_group_id", schemas_exports.string())
    });
  }
});

// src/serialization/resources/cloud/resources/games/resources/games/types/CreateGameResponse.ts
var CreateGameResponse;
var init_CreateGameResponse = __esm({
  "src/serialization/resources/cloud/resources/games/resources/games/types/CreateGameResponse.ts"() {
    "use strict";
    init_core();
    CreateGameResponse = schemas_exports.object({
      gameId: schemas_exports.property("game_id", schemas_exports.string())
    });
  }
});

// src/serialization/resources/cloud/resources/games/resources/games/types/ValidateGameRequest.ts
var ValidateGameRequest;
var init_ValidateGameRequest = __esm({
  "src/serialization/resources/cloud/resources/games/resources/games/types/ValidateGameRequest.ts"() {
    "use strict";
    init_core();
    ValidateGameRequest = schemas_exports.object({
      displayName: schemas_exports.property("display_name", schemas_exports.string()),
      nameId: schemas_exports.property("name_id", schemas_exports.string())
    });
  }
});

// src/serialization/resources/cloud/resources/games/resources/games/types/ValidateGameResponse.ts
var ValidateGameResponse;
var init_ValidateGameResponse = __esm({
  "src/serialization/resources/cloud/resources/games/resources/games/types/ValidateGameResponse.ts"() {
    "use strict";
    init_core();
    ValidateGameResponse = schemas_exports.object({
      errors: schemas_exports.list(
        schemas_exports.lazyObject(async () => (await Promise.resolve().then(() => (init_serialization(), serialization_exports))).ValidationError)
      )
    });
  }
});

// src/serialization/resources/cloud/resources/games/resources/games/types/GetGameByIdResponse.ts
var GetGameByIdResponse;
var init_GetGameByIdResponse = __esm({
  "src/serialization/resources/cloud/resources/games/resources/games/types/GetGameByIdResponse.ts"() {
    "use strict";
    init_core();
    GetGameByIdResponse = schemas_exports.object({
      game: schemas_exports.lazyObject(async () => (await Promise.resolve().then(() => (init_serialization(), serialization_exports))).cloud.GameFull),
      watch: schemas_exports.lazyObject(async () => (await Promise.resolve().then(() => (init_serialization(), serialization_exports))).WatchResponse)
    });
  }
});

// src/serialization/resources/cloud/resources/games/resources/games/types/GameBannerUploadPrepareRequest.ts
var GameBannerUploadPrepareRequest;
var init_GameBannerUploadPrepareRequest = __esm({
  "src/serialization/resources/cloud/resources/games/resources/games/types/GameBannerUploadPrepareRequest.ts"() {
    "use strict";
    init_core();
    GameBannerUploadPrepareRequest = schemas_exports.object({
      path: schemas_exports.string(),
      mime: schemas_exports.string().optional(),
      contentLength: schemas_exports.property("content_length", schemas_exports.number())
    });
  }
});

// src/serialization/resources/cloud/resources/games/resources/games/types/GameBannerUploadPrepareResponse.ts
var GameBannerUploadPrepareResponse;
var init_GameBannerUploadPrepareResponse = __esm({
  "src/serialization/resources/cloud/resources/games/resources/games/types/GameBannerUploadPrepareResponse.ts"() {
    "use strict";
    init_core();
    GameBannerUploadPrepareResponse = schemas_exports.object({
      uploadId: schemas_exports.property("upload_id", schemas_exports.string()),
      presignedRequest: schemas_exports.property(
        "presigned_request",
        schemas_exports.lazyObject(async () => (await Promise.resolve().then(() => (init_serialization(), serialization_exports))).upload.PresignedRequest)
      )
    });
  }
});

// src/serialization/resources/cloud/resources/games/resources/games/types/GameLogoUploadPrepareRequest.ts
var GameLogoUploadPrepareRequest;
var init_GameLogoUploadPrepareRequest = __esm({
  "src/serialization/resources/cloud/resources/games/resources/games/types/GameLogoUploadPrepareRequest.ts"() {
    "use strict";
    init_core();
    GameLogoUploadPrepareRequest = schemas_exports.object({
      path: schemas_exports.string(),
      mime: schemas_exports.string().optional(),
      contentLength: schemas_exports.property("content_length", schemas_exports.number())
    });
  }
});

// src/serialization/resources/cloud/resources/games/resources/games/types/GameLogoUploadPrepareResponse.ts
var GameLogoUploadPrepareResponse;
var init_GameLogoUploadPrepareResponse = __esm({
  "src/serialization/resources/cloud/resources/games/resources/games/types/GameLogoUploadPrepareResponse.ts"() {
    "use strict";
    init_core();
    GameLogoUploadPrepareResponse = schemas_exports.object({
      uploadId: schemas_exports.property("upload_id", schemas_exports.string()),
      presignedRequest: schemas_exports.property(
        "presigned_request",
        schemas_exports.lazyObject(async () => (await Promise.resolve().then(() => (init_serialization(), serialization_exports))).upload.PresignedRequest)
      )
    });
  }
});

// src/serialization/resources/cloud/resources/games/resources/games/types/index.ts
var init_types9 = __esm({
  "src/serialization/resources/cloud/resources/games/resources/games/types/index.ts"() {
    "use strict";
    init_GetGamesResponse();
    init_CreateGameRequest();
    init_CreateGameResponse();
    init_ValidateGameRequest();
    init_ValidateGameResponse();
    init_GetGameByIdResponse();
    init_GameBannerUploadPrepareRequest();
    init_GameBannerUploadPrepareResponse();
    init_GameLogoUploadPrepareRequest();
    init_GameLogoUploadPrepareResponse();
  }
});

// src/serialization/resources/cloud/resources/games/resources/games/index.ts
var games_exports3 = {};
__export(games_exports3, {
  CreateGameRequest: () => CreateGameRequest,
  CreateGameResponse: () => CreateGameResponse,
  GameBannerUploadPrepareRequest: () => GameBannerUploadPrepareRequest,
  GameBannerUploadPrepareResponse: () => GameBannerUploadPrepareResponse,
  GameLogoUploadPrepareRequest: () => GameLogoUploadPrepareRequest,
  GameLogoUploadPrepareResponse: () => GameLogoUploadPrepareResponse,
  GetGameByIdResponse: () => GetGameByIdResponse,
  GetGamesResponse: () => GetGamesResponse,
  ValidateGameRequest: () => ValidateGameRequest,
  ValidateGameResponse: () => ValidateGameResponse
});
var init_games = __esm({
  "src/serialization/resources/cloud/resources/games/resources/games/index.ts"() {
    "use strict";
    init_types9();
  }
});

// src/serialization/resources/cloud/resources/games/resources/matchmaker/types/ExportMatchmakerLobbyHistoryRequest.ts
var ExportMatchmakerLobbyHistoryRequest;
var init_ExportMatchmakerLobbyHistoryRequest = __esm({
  "src/serialization/resources/cloud/resources/games/resources/matchmaker/types/ExportMatchmakerLobbyHistoryRequest.ts"() {
    "use strict";
    init_core();
    ExportMatchmakerLobbyHistoryRequest = schemas_exports.object({
      queryStart: schemas_exports.property("query_start", schemas_exports.number()),
      queryEnd: schemas_exports.property("query_end", schemas_exports.number())
    });
  }
});

// src/serialization/resources/cloud/resources/games/resources/matchmaker/types/ExportMatchmakerLobbyHistoryResponse.ts
var ExportMatchmakerLobbyHistoryResponse;
var init_ExportMatchmakerLobbyHistoryResponse = __esm({
  "src/serialization/resources/cloud/resources/games/resources/matchmaker/types/ExportMatchmakerLobbyHistoryResponse.ts"() {
    "use strict";
    init_core();
    ExportMatchmakerLobbyHistoryResponse = schemas_exports.object({
      url: schemas_exports.string()
    });
  }
});

// src/serialization/resources/cloud/resources/games/resources/matchmaker/types/DeleteMatchmakerLobbyResponse.ts
var DeleteMatchmakerLobbyResponse;
var init_DeleteMatchmakerLobbyResponse = __esm({
  "src/serialization/resources/cloud/resources/games/resources/matchmaker/types/DeleteMatchmakerLobbyResponse.ts"() {
    "use strict";
    init_core();
    DeleteMatchmakerLobbyResponse = schemas_exports.object({
      didRemove: schemas_exports.property("did_remove", schemas_exports.boolean())
    });
  }
});

// src/serialization/resources/cloud/resources/games/resources/matchmaker/types/GetLobbyLogsResponse.ts
var GetLobbyLogsResponse;
var init_GetLobbyLogsResponse = __esm({
  "src/serialization/resources/cloud/resources/games/resources/matchmaker/types/GetLobbyLogsResponse.ts"() {
    "use strict";
    init_core();
    GetLobbyLogsResponse = schemas_exports.object({
      lines: schemas_exports.list(schemas_exports.string()),
      timestamps: schemas_exports.list(schemas_exports.string()),
      watch: schemas_exports.lazyObject(async () => (await Promise.resolve().then(() => (init_serialization(), serialization_exports))).WatchResponse)
    });
  }
});

// src/serialization/resources/cloud/resources/games/resources/matchmaker/types/ExportLobbyLogsRequest.ts
var ExportLobbyLogsRequest;
var init_ExportLobbyLogsRequest = __esm({
  "src/serialization/resources/cloud/resources/games/resources/matchmaker/types/ExportLobbyLogsRequest.ts"() {
    "use strict";
    init_core();
    ExportLobbyLogsRequest = schemas_exports.object({
      stream: schemas_exports.lazy(async () => (await Promise.resolve().then(() => (init_serialization(), serialization_exports))).cloud.games.LogStream)
    });
  }
});

// src/serialization/resources/cloud/resources/games/resources/matchmaker/types/ExportLobbyLogsResponse.ts
var ExportLobbyLogsResponse;
var init_ExportLobbyLogsResponse = __esm({
  "src/serialization/resources/cloud/resources/games/resources/matchmaker/types/ExportLobbyLogsResponse.ts"() {
    "use strict";
    init_core();
    ExportLobbyLogsResponse = schemas_exports.object({
      url: schemas_exports.string()
    });
  }
});

// src/serialization/resources/cloud/resources/games/resources/matchmaker/types/LogStream.ts
var LogStream2;
var init_LogStream = __esm({
  "src/serialization/resources/cloud/resources/games/resources/matchmaker/types/LogStream.ts"() {
    "use strict";
    init_core();
    LogStream2 = schemas_exports.enum_(["std_out", "std_err"]);
  }
});

// src/serialization/resources/cloud/resources/games/resources/matchmaker/types/index.ts
var init_types10 = __esm({
  "src/serialization/resources/cloud/resources/games/resources/matchmaker/types/index.ts"() {
    "use strict";
    init_ExportMatchmakerLobbyHistoryRequest();
    init_ExportMatchmakerLobbyHistoryResponse();
    init_DeleteMatchmakerLobbyResponse();
    init_GetLobbyLogsResponse();
    init_ExportLobbyLogsRequest();
    init_ExportLobbyLogsResponse();
    init_LogStream();
  }
});

// src/serialization/resources/cloud/resources/games/resources/matchmaker/index.ts
var matchmaker_exports4 = {};
__export(matchmaker_exports4, {
  DeleteMatchmakerLobbyResponse: () => DeleteMatchmakerLobbyResponse,
  ExportLobbyLogsRequest: () => ExportLobbyLogsRequest,
  ExportLobbyLogsResponse: () => ExportLobbyLogsResponse,
  ExportMatchmakerLobbyHistoryRequest: () => ExportMatchmakerLobbyHistoryRequest,
  ExportMatchmakerLobbyHistoryResponse: () => ExportMatchmakerLobbyHistoryResponse,
  GetLobbyLogsResponse: () => GetLobbyLogsResponse,
  LogStream: () => LogStream2
});
var init_matchmaker = __esm({
  "src/serialization/resources/cloud/resources/games/resources/matchmaker/index.ts"() {
    "use strict";
    init_types10();
  }
});

// src/serialization/resources/cloud/resources/games/resources/tokens/types/CreateCloudTokenResponse.ts
var CreateCloudTokenResponse;
var init_CreateCloudTokenResponse = __esm({
  "src/serialization/resources/cloud/resources/games/resources/tokens/types/CreateCloudTokenResponse.ts"() {
    "use strict";
    init_core();
    CreateCloudTokenResponse = schemas_exports.object({
      token: schemas_exports.string()
    });
  }
});

// src/serialization/resources/cloud/resources/games/resources/tokens/types/index.ts
var init_types11 = __esm({
  "src/serialization/resources/cloud/resources/games/resources/tokens/types/index.ts"() {
    "use strict";
    init_CreateCloudTokenResponse();
  }
});

// src/serialization/resources/cloud/resources/games/resources/tokens/index.ts
var tokens_exports2 = {};
__export(tokens_exports2, {
  CreateCloudTokenResponse: () => CreateCloudTokenResponse
});
var init_tokens = __esm({
  "src/serialization/resources/cloud/resources/games/resources/tokens/index.ts"() {
    "use strict";
    init_types11();
  }
});

// src/serialization/resources/cloud/resources/games/resources/versions/types/CreateGameVersionRequest.ts
var CreateGameVersionRequest;
var init_CreateGameVersionRequest = __esm({
  "src/serialization/resources/cloud/resources/games/resources/versions/types/CreateGameVersionRequest.ts"() {
    "use strict";
    init_core();
    CreateGameVersionRequest = schemas_exports.object({
      displayName: schemas_exports.property("display_name", schemas_exports.string()),
      config: schemas_exports.lazyObject(async () => (await Promise.resolve().then(() => (init_serialization(), serialization_exports))).cloud.version.Config)
    });
  }
});

// src/serialization/resources/cloud/resources/games/resources/versions/types/CreateGameVersionResponse.ts
var CreateGameVersionResponse;
var init_CreateGameVersionResponse = __esm({
  "src/serialization/resources/cloud/resources/games/resources/versions/types/CreateGameVersionResponse.ts"() {
    "use strict";
    init_core();
    CreateGameVersionResponse = schemas_exports.object({
      versionId: schemas_exports.property("version_id", schemas_exports.string())
    });
  }
});

// src/serialization/resources/cloud/resources/games/resources/versions/types/ValidateGameVersionRequest.ts
var ValidateGameVersionRequest;
var init_ValidateGameVersionRequest = __esm({
  "src/serialization/resources/cloud/resources/games/resources/versions/types/ValidateGameVersionRequest.ts"() {
    "use strict";
    init_core();
    ValidateGameVersionRequest = schemas_exports.object({
      displayName: schemas_exports.property("display_name", schemas_exports.string()),
      config: schemas_exports.lazyObject(async () => (await Promise.resolve().then(() => (init_serialization(), serialization_exports))).cloud.version.Config)
    });
  }
});

// src/serialization/resources/cloud/resources/games/resources/versions/types/ValidateGameVersionResponse.ts
var ValidateGameVersionResponse;
var init_ValidateGameVersionResponse = __esm({
  "src/serialization/resources/cloud/resources/games/resources/versions/types/ValidateGameVersionResponse.ts"() {
    "use strict";
    init_core();
    ValidateGameVersionResponse = schemas_exports.object({
      errors: schemas_exports.list(
        schemas_exports.lazyObject(async () => (await Promise.resolve().then(() => (init_serialization(), serialization_exports))).ValidationError)
      )
    });
  }
});

// src/serialization/resources/cloud/resources/games/resources/versions/types/GetGameVersionByIdResponse.ts
var GetGameVersionByIdResponse;
var init_GetGameVersionByIdResponse = __esm({
  "src/serialization/resources/cloud/resources/games/resources/versions/types/GetGameVersionByIdResponse.ts"() {
    "use strict";
    init_core();
    GetGameVersionByIdResponse = schemas_exports.object({
      version: schemas_exports.lazyObject(async () => (await Promise.resolve().then(() => (init_serialization(), serialization_exports))).cloud.version.Full)
    });
  }
});

// src/serialization/resources/cloud/resources/games/resources/versions/types/index.ts
var init_types12 = __esm({
  "src/serialization/resources/cloud/resources/games/resources/versions/types/index.ts"() {
    "use strict";
    init_CreateGameVersionRequest();
    init_CreateGameVersionResponse();
    init_ValidateGameVersionRequest();
    init_ValidateGameVersionResponse();
    init_GetGameVersionByIdResponse();
  }
});

// src/serialization/resources/cloud/resources/games/resources/versions/index.ts
var versions_exports2 = {};
__export(versions_exports2, {
  CreateGameVersionRequest: () => CreateGameVersionRequest,
  CreateGameVersionResponse: () => CreateGameVersionResponse,
  GetGameVersionByIdResponse: () => GetGameVersionByIdResponse,
  ValidateGameVersionRequest: () => ValidateGameVersionRequest,
  ValidateGameVersionResponse: () => ValidateGameVersionResponse
});
var init_versions = __esm({
  "src/serialization/resources/cloud/resources/games/resources/versions/index.ts"() {
    "use strict";
    init_types12();
  }
});

// src/serialization/resources/cloud/resources/games/resources/index.ts
var init_resources2 = __esm({
  "src/serialization/resources/cloud/resources/games/resources/index.ts"() {
    "use strict";
    init_namespaces();
    init_avatars();
    init_types6();
    init_builds();
    init_types7();
    init_cdn();
    init_types8();
    init_games();
    init_types9();
    init_matchmaker();
    init_types10();
    init_tokens();
    init_types11();
    init_versions();
    init_types12();
  }
});

// src/serialization/resources/cloud/resources/games/index.ts
var games_exports4 = {};
__export(games_exports4, {
  BuildCompression: () => BuildCompression2,
  BuildKind: () => BuildKind2,
  CreateCloudTokenResponse: () => CreateCloudTokenResponse,
  CreateGameBuildRequest: () => CreateGameBuildRequest,
  CreateGameBuildResponse: () => CreateGameBuildResponse,
  CreateGameCdnSiteRequest: () => CreateGameCdnSiteRequest,
  CreateGameCdnSiteResponse: () => CreateGameCdnSiteResponse,
  CreateGameRequest: () => CreateGameRequest,
  CreateGameResponse: () => CreateGameResponse,
  CreateGameVersionRequest: () => CreateGameVersionRequest,
  CreateGameVersionResponse: () => CreateGameVersionResponse,
  DeleteMatchmakerLobbyResponse: () => DeleteMatchmakerLobbyResponse,
  ExportLobbyLogsRequest: () => ExportLobbyLogsRequest,
  ExportLobbyLogsResponse: () => ExportLobbyLogsResponse,
  ExportMatchmakerLobbyHistoryRequest: () => ExportMatchmakerLobbyHistoryRequest,
  ExportMatchmakerLobbyHistoryResponse: () => ExportMatchmakerLobbyHistoryResponse,
  GameBannerUploadPrepareRequest: () => GameBannerUploadPrepareRequest,
  GameBannerUploadPrepareResponse: () => GameBannerUploadPrepareResponse,
  GameLogoUploadPrepareRequest: () => GameLogoUploadPrepareRequest,
  GameLogoUploadPrepareResponse: () => GameLogoUploadPrepareResponse,
  GetGameByIdResponse: () => GetGameByIdResponse,
  GetGameVersionByIdResponse: () => GetGameVersionByIdResponse,
  GetGamesResponse: () => GetGamesResponse,
  GetLobbyLogsResponse: () => GetLobbyLogsResponse,
  ListGameBuildsResponse: () => ListGameBuildsResponse,
  ListGameCdnSitesResponse: () => ListGameCdnSitesResponse,
  ListGameCustomAvatarsResponse: () => ListGameCustomAvatarsResponse,
  LogStream: () => LogStream2,
  PrepareCustomAvatarUploadRequest: () => PrepareCustomAvatarUploadRequest,
  PrepareCustomAvatarUploadResponse: () => PrepareCustomAvatarUploadResponse,
  ValidateGameRequest: () => ValidateGameRequest,
  ValidateGameResponse: () => ValidateGameResponse,
  ValidateGameVersionRequest: () => ValidateGameVersionRequest,
  ValidateGameVersionResponse: () => ValidateGameVersionResponse,
  avatars: () => avatars_exports2,
  builds: () => builds_exports2,
  cdn: () => cdn_exports3,
  games: () => games_exports3,
  matchmaker: () => matchmaker_exports4,
  namespaces: () => namespaces_exports2,
  tokens: () => tokens_exports2,
  versions: () => versions_exports2
});
var init_games2 = __esm({
  "src/serialization/resources/cloud/resources/games/index.ts"() {
    "use strict";
    init_resources2();
  }
});

// src/serialization/resources/cloud/resources/version/types/Config.ts
var Config;
var init_Config = __esm({
  "src/serialization/resources/cloud/resources/version/types/Config.ts"() {
    "use strict";
    init_core();
    Config = schemas_exports.object({
      engine: schemas_exports.lazyObject(async () => (await Promise.resolve().then(() => (init_serialization(), serialization_exports))).cloud.version.engine.Config).optional(),
      cdn: schemas_exports.lazyObject(async () => (await Promise.resolve().then(() => (init_serialization(), serialization_exports))).cloud.version.cdn.Config).optional(),
      matchmaker: schemas_exports.lazyObject(async () => (await Promise.resolve().then(() => (init_serialization(), serialization_exports))).cloud.version.matchmaker.Config).optional(),
      kv: schemas_exports.lazyObject(async () => (await Promise.resolve().then(() => (init_serialization(), serialization_exports))).cloud.version.kv.Config).optional(),
      identity: schemas_exports.lazyObject(async () => (await Promise.resolve().then(() => (init_serialization(), serialization_exports))).cloud.version.identity.Config).optional()
    });
  }
});

// src/serialization/resources/cloud/resources/version/types/Full.ts
var Full;
var init_Full = __esm({
  "src/serialization/resources/cloud/resources/version/types/Full.ts"() {
    "use strict";
    init_core();
    Full = schemas_exports.object({
      versionId: schemas_exports.property("version_id", schemas_exports.string()),
      createTs: schemas_exports.property("create_ts", schemas_exports.date()),
      displayName: schemas_exports.property("display_name", schemas_exports.string()),
      config: schemas_exports.lazyObject(async () => (await Promise.resolve().then(() => (init_serialization(), serialization_exports))).cloud.version.Config)
    });
  }
});

// src/serialization/resources/cloud/resources/version/types/Summary.ts
var Summary;
var init_Summary = __esm({
  "src/serialization/resources/cloud/resources/version/types/Summary.ts"() {
    "use strict";
    init_core();
    Summary = schemas_exports.object({
      versionId: schemas_exports.property("version_id", schemas_exports.string()),
      createTs: schemas_exports.property("create_ts", schemas_exports.date()),
      displayName: schemas_exports.property("display_name", schemas_exports.string())
    });
  }
});

// src/serialization/resources/cloud/resources/version/types/index.ts
var init_types13 = __esm({
  "src/serialization/resources/cloud/resources/version/types/index.ts"() {
    "use strict";
    init_Config();
    init_Full();
    init_Summary();
  }
});

// src/serialization/resources/cloud/resources/version/resources/cdn/types/Config.ts
var Config2;
var init_Config2 = __esm({
  "src/serialization/resources/cloud/resources/version/resources/cdn/types/Config.ts"() {
    "use strict";
    init_core();
    Config2 = schemas_exports.object({
      buildCommand: schemas_exports.property("build_command", schemas_exports.string().optional()),
      buildOutput: schemas_exports.property("build_output", schemas_exports.string().optional()),
      siteId: schemas_exports.property("site_id", schemas_exports.string().optional()),
      routes: schemas_exports.list(schemas_exports.lazyObject(async () => (await Promise.resolve().then(() => (init_serialization(), serialization_exports))).cloud.version.cdn.Route)).optional()
    });
  }
});

// src/serialization/resources/cloud/resources/version/resources/cdn/types/Route.ts
var Route;
var init_Route = __esm({
  "src/serialization/resources/cloud/resources/version/resources/cdn/types/Route.ts"() {
    "use strict";
    init_core();
    Route = schemas_exports.object({
      glob: schemas_exports.string(),
      priority: schemas_exports.number(),
      middlewares: schemas_exports.list(
        schemas_exports.lazyObject(async () => (await Promise.resolve().then(() => (init_serialization(), serialization_exports))).cloud.version.cdn.Middleware)
      )
    });
  }
});

// src/serialization/resources/cloud/resources/version/resources/cdn/types/Middleware.ts
var Middleware;
var init_Middleware = __esm({
  "src/serialization/resources/cloud/resources/version/resources/cdn/types/Middleware.ts"() {
    "use strict";
    init_core();
    Middleware = schemas_exports.object({
      kind: schemas_exports.lazyObject(
        async () => (await Promise.resolve().then(() => (init_serialization(), serialization_exports))).cloud.version.cdn.MiddlewareKind
      )
    });
  }
});

// src/serialization/resources/cloud/resources/version/resources/cdn/types/MiddlewareKind.ts
var MiddlewareKind;
var init_MiddlewareKind = __esm({
  "src/serialization/resources/cloud/resources/version/resources/cdn/types/MiddlewareKind.ts"() {
    "use strict";
    init_core();
    MiddlewareKind = schemas_exports.object({
      customHeaders: schemas_exports.property(
        "custom_headers",
        schemas_exports.lazyObject(async () => (await Promise.resolve().then(() => (init_serialization(), serialization_exports))).cloud.version.cdn.CustomHeadersMiddleware).optional()
      )
    });
  }
});

// src/serialization/resources/cloud/resources/version/resources/cdn/types/CustomHeadersMiddleware.ts
var CustomHeadersMiddleware;
var init_CustomHeadersMiddleware = __esm({
  "src/serialization/resources/cloud/resources/version/resources/cdn/types/CustomHeadersMiddleware.ts"() {
    "use strict";
    init_core();
    CustomHeadersMiddleware = schemas_exports.object({
      headers: schemas_exports.list(
        schemas_exports.lazyObject(async () => (await Promise.resolve().then(() => (init_serialization(), serialization_exports))).cloud.version.cdn.Header)
      )
    });
  }
});

// src/serialization/resources/cloud/resources/version/resources/cdn/types/Header.ts
var Header;
var init_Header = __esm({
  "src/serialization/resources/cloud/resources/version/resources/cdn/types/Header.ts"() {
    "use strict";
    init_core();
    Header = schemas_exports.object({
      name: schemas_exports.string(),
      value: schemas_exports.string()
    });
  }
});

// src/serialization/resources/cloud/resources/version/resources/cdn/types/index.ts
var init_types14 = __esm({
  "src/serialization/resources/cloud/resources/version/resources/cdn/types/index.ts"() {
    "use strict";
    init_Config2();
    init_Route();
    init_Middleware();
    init_MiddlewareKind();
    init_CustomHeadersMiddleware();
    init_Header();
  }
});

// src/serialization/resources/cloud/resources/version/resources/cdn/index.ts
var cdn_exports4 = {};
__export(cdn_exports4, {
  Config: () => Config2,
  CustomHeadersMiddleware: () => CustomHeadersMiddleware,
  Header: () => Header,
  Middleware: () => Middleware,
  MiddlewareKind: () => MiddlewareKind,
  Route: () => Route
});
var init_cdn2 = __esm({
  "src/serialization/resources/cloud/resources/version/resources/cdn/index.ts"() {
    "use strict";
    init_types14();
  }
});

// src/serialization/resources/cloud/resources/version/resources/engine/types/Config.ts
var Config3;
var init_Config3 = __esm({
  "src/serialization/resources/cloud/resources/version/resources/engine/types/Config.ts"() {
    "use strict";
    init_core();
    Config3 = schemas_exports.object({
      unity: schemas_exports.lazyObject(async () => (await Promise.resolve().then(() => (init_serialization(), serialization_exports))).cloud.version.engine.UnityConfig).optional(),
      unreal: schemas_exports.lazyObject(async () => (await Promise.resolve().then(() => (init_serialization(), serialization_exports))).cloud.version.engine.UnrealConfig).optional(),
      godot: schemas_exports.lazyObject(async () => (await Promise.resolve().then(() => (init_serialization(), serialization_exports))).cloud.version.engine.GodotConfig).optional(),
      html5: schemas_exports.lazyObject(async () => (await Promise.resolve().then(() => (init_serialization(), serialization_exports))).cloud.version.engine.Html5Config).optional()
    });
  }
});

// src/serialization/resources/cloud/resources/version/resources/engine/types/index.ts
var init_types15 = __esm({
  "src/serialization/resources/cloud/resources/version/resources/engine/types/index.ts"() {
    "use strict";
    init_Config3();
  }
});

// src/serialization/resources/cloud/resources/version/resources/engine/resources/godot/types/GodotConfig.ts
var GodotConfig;
var init_GodotConfig = __esm({
  "src/serialization/resources/cloud/resources/version/resources/engine/resources/godot/types/GodotConfig.ts"() {
    "use strict";
    init_core();
    GodotConfig = schemas_exports.object({});
  }
});

// src/serialization/resources/cloud/resources/version/resources/engine/resources/godot/types/index.ts
var init_types16 = __esm({
  "src/serialization/resources/cloud/resources/version/resources/engine/resources/godot/types/index.ts"() {
    "use strict";
    init_GodotConfig();
  }
});

// src/serialization/resources/cloud/resources/version/resources/engine/resources/godot/index.ts
var godot_exports2 = {};
__export(godot_exports2, {
  GodotConfig: () => GodotConfig
});
var init_godot = __esm({
  "src/serialization/resources/cloud/resources/version/resources/engine/resources/godot/index.ts"() {
    "use strict";
    init_types16();
  }
});

// src/serialization/resources/cloud/resources/version/resources/engine/resources/html5/types/Html5Config.ts
var Html5Config;
var init_Html5Config = __esm({
  "src/serialization/resources/cloud/resources/version/resources/engine/resources/html5/types/Html5Config.ts"() {
    "use strict";
    init_core();
    Html5Config = schemas_exports.object({});
  }
});

// src/serialization/resources/cloud/resources/version/resources/engine/resources/html5/types/index.ts
var init_types17 = __esm({
  "src/serialization/resources/cloud/resources/version/resources/engine/resources/html5/types/index.ts"() {
    "use strict";
    init_Html5Config();
  }
});

// src/serialization/resources/cloud/resources/version/resources/engine/resources/html5/index.ts
var html5_exports2 = {};
__export(html5_exports2, {
  Html5Config: () => Html5Config
});
var init_html5 = __esm({
  "src/serialization/resources/cloud/resources/version/resources/engine/resources/html5/index.ts"() {
    "use strict";
    init_types17();
  }
});

// src/serialization/resources/cloud/resources/version/resources/engine/resources/unity/types/UnityConfig.ts
var UnityConfig;
var init_UnityConfig = __esm({
  "src/serialization/resources/cloud/resources/version/resources/engine/resources/unity/types/UnityConfig.ts"() {
    "use strict";
    init_core();
    UnityConfig = schemas_exports.object({});
  }
});

// src/serialization/resources/cloud/resources/version/resources/engine/resources/unity/types/index.ts
var init_types18 = __esm({
  "src/serialization/resources/cloud/resources/version/resources/engine/resources/unity/types/index.ts"() {
    "use strict";
    init_UnityConfig();
  }
});

// src/serialization/resources/cloud/resources/version/resources/engine/resources/unity/index.ts
var unity_exports2 = {};
__export(unity_exports2, {
  UnityConfig: () => UnityConfig
});
var init_unity = __esm({
  "src/serialization/resources/cloud/resources/version/resources/engine/resources/unity/index.ts"() {
    "use strict";
    init_types18();
  }
});

// src/serialization/resources/cloud/resources/version/resources/engine/resources/unreal/types/UnrealConfig.ts
var UnrealConfig;
var init_UnrealConfig = __esm({
  "src/serialization/resources/cloud/resources/version/resources/engine/resources/unreal/types/UnrealConfig.ts"() {
    "use strict";
    init_core();
    UnrealConfig = schemas_exports.object({
      gameModule: schemas_exports.property("game_module", schemas_exports.string())
    });
  }
});

// src/serialization/resources/cloud/resources/version/resources/engine/resources/unreal/types/index.ts
var init_types19 = __esm({
  "src/serialization/resources/cloud/resources/version/resources/engine/resources/unreal/types/index.ts"() {
    "use strict";
    init_UnrealConfig();
  }
});

// src/serialization/resources/cloud/resources/version/resources/engine/resources/unreal/index.ts
var unreal_exports2 = {};
__export(unreal_exports2, {
  UnrealConfig: () => UnrealConfig
});
var init_unreal = __esm({
  "src/serialization/resources/cloud/resources/version/resources/engine/resources/unreal/index.ts"() {
    "use strict";
    init_types19();
  }
});

// src/serialization/resources/cloud/resources/version/resources/engine/resources/index.ts
var init_resources3 = __esm({
  "src/serialization/resources/cloud/resources/version/resources/engine/resources/index.ts"() {
    "use strict";
    init_godot();
    init_types16();
    init_html5();
    init_types17();
    init_unity();
    init_types18();
    init_unreal();
    init_types19();
  }
});

// src/serialization/resources/cloud/resources/version/resources/engine/index.ts
var engine_exports2 = {};
__export(engine_exports2, {
  Config: () => Config3,
  GodotConfig: () => GodotConfig,
  Html5Config: () => Html5Config,
  UnityConfig: () => UnityConfig,
  UnrealConfig: () => UnrealConfig,
  godot: () => godot_exports2,
  html5: () => html5_exports2,
  unity: () => unity_exports2,
  unreal: () => unreal_exports2
});
var init_engine = __esm({
  "src/serialization/resources/cloud/resources/version/resources/engine/index.ts"() {
    "use strict";
    init_types15();
    init_resources3();
  }
});

// src/serialization/resources/cloud/resources/version/resources/kv/types/Config.ts
var Config4;
var init_Config4 = __esm({
  "src/serialization/resources/cloud/resources/version/resources/kv/types/Config.ts"() {
    "use strict";
    init_core();
    Config4 = schemas_exports.object({});
  }
});

// src/serialization/resources/cloud/resources/version/resources/kv/types/index.ts
var init_types20 = __esm({
  "src/serialization/resources/cloud/resources/version/resources/kv/types/index.ts"() {
    "use strict";
    init_Config4();
  }
});

// src/serialization/resources/cloud/resources/version/resources/kv/index.ts
var kv_exports3 = {};
__export(kv_exports3, {
  Config: () => Config4
});
var init_kv = __esm({
  "src/serialization/resources/cloud/resources/version/resources/kv/index.ts"() {
    "use strict";
    init_types20();
  }
});

// src/serialization/resources/cloud/resources/version/resources/matchmaker/types/Config.ts
var Config5;
var init_Config5 = __esm({
  "src/serialization/resources/cloud/resources/version/resources/matchmaker/types/Config.ts"() {
    "use strict";
    init_core();
    Config5 = schemas_exports.object({
      gameModes: schemas_exports.property(
        "game_modes",
        schemas_exports.record(
          schemas_exports.string(),
          schemas_exports.lazyObject(
            async () => (await Promise.resolve().then(() => (init_serialization(), serialization_exports))).cloud.version.matchmaker.GameMode
          )
        ).optional()
      ),
      captcha: schemas_exports.lazyObject(async () => (await Promise.resolve().then(() => (init_serialization(), serialization_exports))).cloud.version.matchmaker.Captcha).optional(),
      devHostname: schemas_exports.property("dev_hostname", schemas_exports.string().optional()),
      regions: schemas_exports.record(
        schemas_exports.string(),
        schemas_exports.lazyObject(
          async () => (await Promise.resolve().then(() => (init_serialization(), serialization_exports))).cloud.version.matchmaker.GameModeRegion
        )
      ).optional(),
      maxPlayers: schemas_exports.property("max_players", schemas_exports.number().optional()),
      maxPlayersDirect: schemas_exports.property("max_players_direct", schemas_exports.number().optional()),
      maxPlayersParty: schemas_exports.property("max_players_party", schemas_exports.number().optional()),
      docker: schemas_exports.lazyObject(async () => (await Promise.resolve().then(() => (init_serialization(), serialization_exports))).cloud.version.matchmaker.GameModeRuntimeDocker).optional(),
      tier: schemas_exports.string().optional(),
      idleLobbies: schemas_exports.property(
        "idle_lobbies",
        schemas_exports.lazyObject(
          async () => (await Promise.resolve().then(() => (init_serialization(), serialization_exports))).cloud.version.matchmaker.GameModeIdleLobbiesConfig
        ).optional()
      ),
      lobbyGroups: schemas_exports.property(
        "lobby_groups",
        schemas_exports.list(
          schemas_exports.lazyObject(
            async () => (await Promise.resolve().then(() => (init_serialization(), serialization_exports))).cloud.version.matchmaker.LobbyGroup
          )
        ).optional()
      )
    });
  }
});

// src/serialization/resources/cloud/resources/version/resources/matchmaker/types/index.ts
var init_types21 = __esm({
  "src/serialization/resources/cloud/resources/version/resources/matchmaker/types/index.ts"() {
    "use strict";
    init_Config5();
  }
});

// src/serialization/resources/cloud/resources/version/resources/matchmaker/resources/common/types/PortRange.ts
var PortRange;
var init_PortRange = __esm({
  "src/serialization/resources/cloud/resources/version/resources/matchmaker/resources/common/types/PortRange.ts"() {
    "use strict";
    init_core();
    PortRange = schemas_exports.object({
      min: schemas_exports.number(),
      max: schemas_exports.number()
    });
  }
});

// src/serialization/resources/cloud/resources/version/resources/matchmaker/resources/common/types/PortProtocol.ts
var PortProtocol2;
var init_PortProtocol = __esm({
  "src/serialization/resources/cloud/resources/version/resources/matchmaker/resources/common/types/PortProtocol.ts"() {
    "use strict";
    init_core();
    PortProtocol2 = schemas_exports.enum_(["http", "https", "tcp", "tcp_tls", "udp"]);
  }
});

// src/serialization/resources/cloud/resources/version/resources/matchmaker/resources/common/types/ProxyKind.ts
var ProxyKind2;
var init_ProxyKind = __esm({
  "src/serialization/resources/cloud/resources/version/resources/matchmaker/resources/common/types/ProxyKind.ts"() {
    "use strict";
    init_core();
    ProxyKind2 = schemas_exports.enum_(["none", "game_guard"]);
  }
});

// src/serialization/resources/cloud/resources/version/resources/matchmaker/resources/common/types/Captcha.ts
var Captcha;
var init_Captcha = __esm({
  "src/serialization/resources/cloud/resources/version/resources/matchmaker/resources/common/types/Captcha.ts"() {
    "use strict";
    init_core();
    Captcha = schemas_exports.object({
      requestsBeforeReverify: schemas_exports.property("requests_before_reverify", schemas_exports.number()),
      verificationTtl: schemas_exports.property("verification_ttl", schemas_exports.number()),
      hcaptcha: schemas_exports.lazyObject(async () => (await Promise.resolve().then(() => (init_serialization(), serialization_exports))).cloud.version.matchmaker.CaptchaHcaptcha).optional(),
      turnstile: schemas_exports.lazyObject(async () => (await Promise.resolve().then(() => (init_serialization(), serialization_exports))).cloud.version.matchmaker.CaptchaTurnstile).optional()
    });
  }
});

// src/serialization/resources/cloud/resources/version/resources/matchmaker/resources/common/types/CaptchaHcaptcha.ts
var CaptchaHcaptcha;
var init_CaptchaHcaptcha = __esm({
  "src/serialization/resources/cloud/resources/version/resources/matchmaker/resources/common/types/CaptchaHcaptcha.ts"() {
    "use strict";
    init_core();
    CaptchaHcaptcha = schemas_exports.object({
      level: schemas_exports.lazy(
        async () => (await Promise.resolve().then(() => (init_serialization(), serialization_exports))).cloud.version.matchmaker.CaptchaHcaptchaLevel
      )
    });
  }
});

// src/serialization/resources/cloud/resources/version/resources/matchmaker/resources/common/types/CaptchaHcaptchaLevel.ts
var CaptchaHcaptchaLevel2;
var init_CaptchaHcaptchaLevel = __esm({
  "src/serialization/resources/cloud/resources/version/resources/matchmaker/resources/common/types/CaptchaHcaptchaLevel.ts"() {
    "use strict";
    init_core();
    CaptchaHcaptchaLevel2 = schemas_exports.enum_(["easy", "moderate", "difficult", "always_on"]);
  }
});

// src/serialization/resources/cloud/resources/version/resources/matchmaker/resources/common/types/CaptchaTurnstile.ts
var CaptchaTurnstile;
var init_CaptchaTurnstile = __esm({
  "src/serialization/resources/cloud/resources/version/resources/matchmaker/resources/common/types/CaptchaTurnstile.ts"() {
    "use strict";
    init_core();
    CaptchaTurnstile = schemas_exports.object({
      siteKey: schemas_exports.property("site_key", schemas_exports.string()),
      secretKey: schemas_exports.property("secret_key", schemas_exports.string())
    });
  }
});

// src/serialization/resources/cloud/resources/version/resources/matchmaker/resources/common/types/NetworkMode.ts
var NetworkMode2;
var init_NetworkMode = __esm({
  "src/serialization/resources/cloud/resources/version/resources/matchmaker/resources/common/types/NetworkMode.ts"() {
    "use strict";
    init_core();
    NetworkMode2 = schemas_exports.enum_(["bridge", "host"]);
  }
});

// src/serialization/resources/cloud/resources/version/resources/matchmaker/resources/common/types/index.ts
var init_types22 = __esm({
  "src/serialization/resources/cloud/resources/version/resources/matchmaker/resources/common/types/index.ts"() {
    "use strict";
    init_PortRange();
    init_PortProtocol();
    init_ProxyKind();
    init_Captcha();
    init_CaptchaHcaptcha();
    init_CaptchaHcaptchaLevel();
    init_CaptchaTurnstile();
    init_NetworkMode();
  }
});

// src/serialization/resources/cloud/resources/version/resources/matchmaker/resources/common/index.ts
var common_exports11 = {};
__export(common_exports11, {
  Captcha: () => Captcha,
  CaptchaHcaptcha: () => CaptchaHcaptcha,
  CaptchaHcaptchaLevel: () => CaptchaHcaptchaLevel2,
  CaptchaTurnstile: () => CaptchaTurnstile,
  NetworkMode: () => NetworkMode2,
  PortProtocol: () => PortProtocol2,
  PortRange: () => PortRange,
  ProxyKind: () => ProxyKind2
});
var init_common = __esm({
  "src/serialization/resources/cloud/resources/version/resources/matchmaker/resources/common/index.ts"() {
    "use strict";
    init_types22();
  }
});

// src/serialization/resources/cloud/resources/version/resources/matchmaker/resources/gameMode/types/GameMode.ts
var GameMode;
var init_GameMode = __esm({
  "src/serialization/resources/cloud/resources/version/resources/matchmaker/resources/gameMode/types/GameMode.ts"() {
    "use strict";
    init_core();
    GameMode = schemas_exports.object({
      regions: schemas_exports.record(
        schemas_exports.string(),
        schemas_exports.lazyObject(
          async () => (await Promise.resolve().then(() => (init_serialization(), serialization_exports))).cloud.version.matchmaker.GameModeRegion
        )
      ).optional(),
      maxPlayers: schemas_exports.property("max_players", schemas_exports.number().optional()),
      maxPlayersDirect: schemas_exports.property("max_players_direct", schemas_exports.number().optional()),
      maxPlayersParty: schemas_exports.property("max_players_party", schemas_exports.number().optional()),
      docker: schemas_exports.lazyObject(
        async () => (await Promise.resolve().then(() => (init_serialization(), serialization_exports))).cloud.version.matchmaker.GameModeRuntimeDocker
      ).optional(),
      listable: schemas_exports.boolean().optional(),
      taggable: schemas_exports.boolean().optional(),
      allowDynamicMaxPlayers: schemas_exports.property(
        "allow_dynamic_max_players",
        schemas_exports.boolean().optional()
      ),
      actions: schemas_exports.lazyObject(async () => (await Promise.resolve().then(() => (init_serialization(), serialization_exports))).cloud.version.matchmaker.GameModeActions).optional(),
      tier: schemas_exports.string().optional(),
      idleLobbies: schemas_exports.property(
        "idle_lobbies",
        schemas_exports.lazyObject(
          async () => (await Promise.resolve().then(() => (init_serialization(), serialization_exports))).cloud.version.matchmaker.GameModeIdleLobbiesConfig
        ).optional()
      )
    });
  }
});

// src/serialization/resources/cloud/resources/version/resources/matchmaker/resources/gameMode/types/GameModeRegion.ts
var GameModeRegion;
var init_GameModeRegion = __esm({
  "src/serialization/resources/cloud/resources/version/resources/matchmaker/resources/gameMode/types/GameModeRegion.ts"() {
    "use strict";
    init_core();
    GameModeRegion = schemas_exports.object({
      tier: schemas_exports.string().optional(),
      idleLobbies: schemas_exports.property(
        "idle_lobbies",
        schemas_exports.lazyObject(
          async () => (await Promise.resolve().then(() => (init_serialization(), serialization_exports))).cloud.version.matchmaker.GameModeIdleLobbiesConfig
        ).optional()
      )
    });
  }
});

// src/serialization/resources/cloud/resources/version/resources/matchmaker/resources/gameMode/types/GameModeRuntimeDocker.ts
var GameModeRuntimeDocker;
var init_GameModeRuntimeDocker = __esm({
  "src/serialization/resources/cloud/resources/version/resources/matchmaker/resources/gameMode/types/GameModeRuntimeDocker.ts"() {
    "use strict";
    init_core();
    GameModeRuntimeDocker = schemas_exports.object({
      dockerfile: schemas_exports.string().optional(),
      image: schemas_exports.string().optional(),
      imageId: schemas_exports.property("image_id", schemas_exports.string().optional()),
      args: schemas_exports.list(schemas_exports.string()).optional(),
      env: schemas_exports.record(schemas_exports.string(), schemas_exports.string()).optional(),
      networkMode: schemas_exports.property(
        "network_mode",
        schemas_exports.lazy(async () => (await Promise.resolve().then(() => (init_serialization(), serialization_exports))).cloud.version.matchmaker.NetworkMode).optional()
      ),
      ports: schemas_exports.record(
        schemas_exports.string(),
        schemas_exports.lazyObject(
          async () => (await Promise.resolve().then(() => (init_serialization(), serialization_exports))).cloud.version.matchmaker.GameModeRuntimeDockerPort
        )
      ).optional()
    });
  }
});

// src/serialization/resources/cloud/resources/version/resources/matchmaker/resources/gameMode/types/GameModeRuntimeDockerPort.ts
var GameModeRuntimeDockerPort;
var init_GameModeRuntimeDockerPort = __esm({
  "src/serialization/resources/cloud/resources/version/resources/matchmaker/resources/gameMode/types/GameModeRuntimeDockerPort.ts"() {
    "use strict";
    init_core();
    GameModeRuntimeDockerPort = schemas_exports.object({
      port: schemas_exports.number().optional(),
      portRange: schemas_exports.property(
        "port_range",
        schemas_exports.lazyObject(async () => (await Promise.resolve().then(() => (init_serialization(), serialization_exports))).cloud.version.matchmaker.PortRange).optional()
      ),
      protocol: schemas_exports.lazy(async () => (await Promise.resolve().then(() => (init_serialization(), serialization_exports))).cloud.version.matchmaker.PortProtocol).optional(),
      proxy: schemas_exports.lazy(async () => (await Promise.resolve().then(() => (init_serialization(), serialization_exports))).cloud.version.matchmaker.ProxyKind).optional(),
      devPort: schemas_exports.property("dev_port", schemas_exports.number().optional()),
      devPortRange: schemas_exports.property(
        "dev_port_range",
        schemas_exports.lazyObject(async () => (await Promise.resolve().then(() => (init_serialization(), serialization_exports))).cloud.version.matchmaker.PortRange).optional()
      ),
      devProtocol: schemas_exports.property(
        "dev_protocol",
        schemas_exports.lazy(async () => (await Promise.resolve().then(() => (init_serialization(), serialization_exports))).cloud.version.matchmaker.PortProtocol).optional()
      )
    });
  }
});

// src/serialization/resources/cloud/resources/version/resources/matchmaker/resources/gameMode/types/GameModeIdleLobbiesConfig.ts
var GameModeIdleLobbiesConfig;
var init_GameModeIdleLobbiesConfig = __esm({
  "src/serialization/resources/cloud/resources/version/resources/matchmaker/resources/gameMode/types/GameModeIdleLobbiesConfig.ts"() {
    "use strict";
    init_core();
    GameModeIdleLobbiesConfig = schemas_exports.object({
      min: schemas_exports.number(),
      max: schemas_exports.number()
    });
  }
});

// src/serialization/resources/cloud/resources/version/resources/matchmaker/resources/gameMode/types/GameModeActions.ts
var GameModeActions;
var init_GameModeActions = __esm({
  "src/serialization/resources/cloud/resources/version/resources/matchmaker/resources/gameMode/types/GameModeActions.ts"() {
    "use strict";
    init_core();
    GameModeActions = schemas_exports.object({
      find: schemas_exports.lazyObject(
        async () => (await Promise.resolve().then(() => (init_serialization(), serialization_exports))).cloud.version.matchmaker.GameModeFindConfig
      ).optional(),
      join: schemas_exports.lazyObject(
        async () => (await Promise.resolve().then(() => (init_serialization(), serialization_exports))).cloud.version.matchmaker.GameModeJoinConfig
      ).optional(),
      create: schemas_exports.lazyObject(
        async () => (await Promise.resolve().then(() => (init_serialization(), serialization_exports))).cloud.version.matchmaker.GameModeCreateConfig
      ).optional()
    });
  }
});

// src/serialization/resources/cloud/resources/version/resources/matchmaker/resources/gameMode/types/GameModeIdentityRequirement.ts
var GameModeIdentityRequirement2;
var init_GameModeIdentityRequirement = __esm({
  "src/serialization/resources/cloud/resources/version/resources/matchmaker/resources/gameMode/types/GameModeIdentityRequirement.ts"() {
    "use strict";
    init_core();
    GameModeIdentityRequirement2 = schemas_exports.enum_(["none", "guest", "registered"]);
  }
});

// src/serialization/resources/cloud/resources/version/resources/matchmaker/resources/gameMode/types/GameModeVerificationConfig.ts
var GameModeVerificationConfig;
var init_GameModeVerificationConfig = __esm({
  "src/serialization/resources/cloud/resources/version/resources/matchmaker/resources/gameMode/types/GameModeVerificationConfig.ts"() {
    "use strict";
    init_core();
    GameModeVerificationConfig = schemas_exports.object({
      url: schemas_exports.string(),
      headers: schemas_exports.record(schemas_exports.string(), schemas_exports.string())
    });
  }
});

// src/serialization/resources/cloud/resources/version/resources/matchmaker/resources/gameMode/types/GameModeFindConfig.ts
var GameModeFindConfig;
var init_GameModeFindConfig = __esm({
  "src/serialization/resources/cloud/resources/version/resources/matchmaker/resources/gameMode/types/GameModeFindConfig.ts"() {
    "use strict";
    init_core();
    GameModeFindConfig = schemas_exports.object({
      enabled: schemas_exports.boolean(),
      identityRequirement: schemas_exports.property(
        "identity_requirement",
        schemas_exports.lazy(
          async () => (await Promise.resolve().then(() => (init_serialization(), serialization_exports))).cloud.version.matchmaker.GameModeIdentityRequirement
        ).optional()
      ),
      verification: schemas_exports.lazyObject(
        async () => (await Promise.resolve().then(() => (init_serialization(), serialization_exports))).cloud.version.matchmaker.GameModeVerificationConfig
      ).optional()
    });
  }
});

// src/serialization/resources/cloud/resources/version/resources/matchmaker/resources/gameMode/types/GameModeJoinConfig.ts
var GameModeJoinConfig;
var init_GameModeJoinConfig = __esm({
  "src/serialization/resources/cloud/resources/version/resources/matchmaker/resources/gameMode/types/GameModeJoinConfig.ts"() {
    "use strict";
    init_core();
    GameModeJoinConfig = schemas_exports.object({
      enabled: schemas_exports.boolean(),
      identityRequirement: schemas_exports.property(
        "identity_requirement",
        schemas_exports.lazy(
          async () => (await Promise.resolve().then(() => (init_serialization(), serialization_exports))).cloud.version.matchmaker.GameModeIdentityRequirement
        ).optional()
      ),
      verification: schemas_exports.lazyObject(
        async () => (await Promise.resolve().then(() => (init_serialization(), serialization_exports))).cloud.version.matchmaker.GameModeVerificationConfig
      ).optional()
    });
  }
});

// src/serialization/resources/cloud/resources/version/resources/matchmaker/resources/gameMode/types/GameModeCreateConfig.ts
var GameModeCreateConfig;
var init_GameModeCreateConfig = __esm({
  "src/serialization/resources/cloud/resources/version/resources/matchmaker/resources/gameMode/types/GameModeCreateConfig.ts"() {
    "use strict";
    init_core();
    GameModeCreateConfig = schemas_exports.object({
      enabled: schemas_exports.boolean(),
      identityRequirement: schemas_exports.property(
        "identity_requirement",
        schemas_exports.lazy(
          async () => (await Promise.resolve().then(() => (init_serialization(), serialization_exports))).cloud.version.matchmaker.GameModeIdentityRequirement
        ).optional()
      ),
      verification: schemas_exports.lazyObject(
        async () => (await Promise.resolve().then(() => (init_serialization(), serialization_exports))).cloud.version.matchmaker.GameModeVerificationConfig
      ).optional(),
      enablePublic: schemas_exports.property("enable_public", schemas_exports.boolean().optional()),
      enablePrivate: schemas_exports.property("enable_private", schemas_exports.boolean().optional()),
      maxLobbiesPerIdentity: schemas_exports.property(
        "max_lobbies_per_identity",
        schemas_exports.number().optional()
      )
    });
  }
});

// src/serialization/resources/cloud/resources/version/resources/matchmaker/resources/gameMode/types/index.ts
var init_types23 = __esm({
  "src/serialization/resources/cloud/resources/version/resources/matchmaker/resources/gameMode/types/index.ts"() {
    "use strict";
    init_GameMode();
    init_GameModeRegion();
    init_GameModeRuntimeDocker();
    init_GameModeRuntimeDockerPort();
    init_GameModeIdleLobbiesConfig();
    init_GameModeActions();
    init_GameModeIdentityRequirement();
    init_GameModeVerificationConfig();
    init_GameModeFindConfig();
    init_GameModeJoinConfig();
    init_GameModeCreateConfig();
  }
});

// src/serialization/resources/cloud/resources/version/resources/matchmaker/resources/gameMode/index.ts
var gameMode_exports2 = {};
__export(gameMode_exports2, {
  GameMode: () => GameMode,
  GameModeActions: () => GameModeActions,
  GameModeCreateConfig: () => GameModeCreateConfig,
  GameModeFindConfig: () => GameModeFindConfig,
  GameModeIdentityRequirement: () => GameModeIdentityRequirement2,
  GameModeIdleLobbiesConfig: () => GameModeIdleLobbiesConfig,
  GameModeJoinConfig: () => GameModeJoinConfig,
  GameModeRegion: () => GameModeRegion,
  GameModeRuntimeDocker: () => GameModeRuntimeDocker,
  GameModeRuntimeDockerPort: () => GameModeRuntimeDockerPort,
  GameModeVerificationConfig: () => GameModeVerificationConfig
});
var init_gameMode = __esm({
  "src/serialization/resources/cloud/resources/version/resources/matchmaker/resources/gameMode/index.ts"() {
    "use strict";
    init_types23();
  }
});

// src/serialization/resources/cloud/resources/version/resources/matchmaker/resources/lobbyGroup/types/LobbyGroup.ts
var LobbyGroup;
var init_LobbyGroup = __esm({
  "src/serialization/resources/cloud/resources/version/resources/matchmaker/resources/lobbyGroup/types/LobbyGroup.ts"() {
    "use strict";
    init_core();
    LobbyGroup = schemas_exports.object({
      nameId: schemas_exports.property("name_id", schemas_exports.string()),
      regions: schemas_exports.list(
        schemas_exports.lazyObject(
          async () => (await Promise.resolve().then(() => (init_serialization(), serialization_exports))).cloud.version.matchmaker.LobbyGroupRegion
        )
      ),
      maxPlayersNormal: schemas_exports.property("max_players_normal", schemas_exports.number()),
      maxPlayersDirect: schemas_exports.property("max_players_direct", schemas_exports.number()),
      maxPlayersParty: schemas_exports.property("max_players_party", schemas_exports.number()),
      runtime: schemas_exports.lazyObject(
        async () => (await Promise.resolve().then(() => (init_serialization(), serialization_exports))).cloud.version.matchmaker.LobbyGroupRuntime
      )
    });
  }
});

// src/serialization/resources/cloud/resources/version/resources/matchmaker/resources/lobbyGroup/types/LobbyGroupRuntime.ts
var LobbyGroupRuntime;
var init_LobbyGroupRuntime = __esm({
  "src/serialization/resources/cloud/resources/version/resources/matchmaker/resources/lobbyGroup/types/LobbyGroupRuntime.ts"() {
    "use strict";
    init_core();
    LobbyGroupRuntime = schemas_exports.object({
      docker: schemas_exports.lazyObject(
        async () => (await Promise.resolve().then(() => (init_serialization(), serialization_exports))).cloud.version.matchmaker.LobbyGroupRuntimeDocker
      ).optional()
    });
  }
});

// src/serialization/resources/cloud/resources/version/resources/matchmaker/resources/lobbyGroup/types/LobbyGroupRegion.ts
var LobbyGroupRegion;
var init_LobbyGroupRegion = __esm({
  "src/serialization/resources/cloud/resources/version/resources/matchmaker/resources/lobbyGroup/types/LobbyGroupRegion.ts"() {
    "use strict";
    init_core();
    LobbyGroupRegion = schemas_exports.object({
      regionId: schemas_exports.property("region_id", schemas_exports.string()),
      tierNameId: schemas_exports.property("tier_name_id", schemas_exports.string()),
      idleLobbies: schemas_exports.property(
        "idle_lobbies",
        schemas_exports.lazyObject(
          async () => (await Promise.resolve().then(() => (init_serialization(), serialization_exports))).cloud.version.matchmaker.LobbyGroupIdleLobbiesConfig
        ).optional()
      )
    });
  }
});

// src/serialization/resources/cloud/resources/version/resources/matchmaker/resources/lobbyGroup/types/LobbyGroupRuntimeDocker.ts
var LobbyGroupRuntimeDocker;
var init_LobbyGroupRuntimeDocker = __esm({
  "src/serialization/resources/cloud/resources/version/resources/matchmaker/resources/lobbyGroup/types/LobbyGroupRuntimeDocker.ts"() {
    "use strict";
    init_core();
    LobbyGroupRuntimeDocker = schemas_exports.object({
      buildId: schemas_exports.property("build_id", schemas_exports.string().optional()),
      args: schemas_exports.list(schemas_exports.string()),
      envVars: schemas_exports.property(
        "env_vars",
        schemas_exports.list(
          schemas_exports.lazyObject(
            async () => (await Promise.resolve().then(() => (init_serialization(), serialization_exports))).cloud.version.matchmaker.LobbyGroupRuntimeDockerEnvVar
          )
        )
      ),
      networkMode: schemas_exports.property(
        "network_mode",
        schemas_exports.lazy(async () => (await Promise.resolve().then(() => (init_serialization(), serialization_exports))).cloud.version.matchmaker.NetworkMode).optional()
      ),
      ports: schemas_exports.list(
        schemas_exports.lazyObject(
          async () => (await Promise.resolve().then(() => (init_serialization(), serialization_exports))).cloud.version.matchmaker.LobbyGroupRuntimeDockerPort
        )
      )
    });
  }
});

// src/serialization/resources/cloud/resources/version/resources/matchmaker/resources/lobbyGroup/types/LobbyGroupRuntimeDockerEnvVar.ts
var LobbyGroupRuntimeDockerEnvVar;
var init_LobbyGroupRuntimeDockerEnvVar = __esm({
  "src/serialization/resources/cloud/resources/version/resources/matchmaker/resources/lobbyGroup/types/LobbyGroupRuntimeDockerEnvVar.ts"() {
    "use strict";
    init_core();
    LobbyGroupRuntimeDockerEnvVar = schemas_exports.object({
      key: schemas_exports.string(),
      value: schemas_exports.string()
    });
  }
});

// src/serialization/resources/cloud/resources/version/resources/matchmaker/resources/lobbyGroup/types/LobbyGroupRuntimeDockerPort.ts
var LobbyGroupRuntimeDockerPort;
var init_LobbyGroupRuntimeDockerPort = __esm({
  "src/serialization/resources/cloud/resources/version/resources/matchmaker/resources/lobbyGroup/types/LobbyGroupRuntimeDockerPort.ts"() {
    "use strict";
    init_core();
    LobbyGroupRuntimeDockerPort = schemas_exports.object({
      label: schemas_exports.string(),
      targetPort: schemas_exports.property("target_port", schemas_exports.number().optional()),
      portRange: schemas_exports.property(
        "port_range",
        schemas_exports.lazyObject(async () => (await Promise.resolve().then(() => (init_serialization(), serialization_exports))).cloud.version.matchmaker.PortRange).optional()
      ),
      proxyProtocol: schemas_exports.property(
        "proxy_protocol",
        schemas_exports.lazy(
          async () => (await Promise.resolve().then(() => (init_serialization(), serialization_exports))).cloud.version.matchmaker.PortProtocol
        )
      )
    });
  }
});

// src/serialization/resources/cloud/resources/version/resources/matchmaker/resources/lobbyGroup/types/LobbyGroupIdleLobbiesConfig.ts
var LobbyGroupIdleLobbiesConfig;
var init_LobbyGroupIdleLobbiesConfig = __esm({
  "src/serialization/resources/cloud/resources/version/resources/matchmaker/resources/lobbyGroup/types/LobbyGroupIdleLobbiesConfig.ts"() {
    "use strict";
    init_core();
    LobbyGroupIdleLobbiesConfig = schemas_exports.object({
      minIdleLobbies: schemas_exports.property("min_idle_lobbies", schemas_exports.number()),
      maxIdleLobbies: schemas_exports.property("max_idle_lobbies", schemas_exports.number())
    });
  }
});

// src/serialization/resources/cloud/resources/version/resources/matchmaker/resources/lobbyGroup/types/index.ts
var init_types24 = __esm({
  "src/serialization/resources/cloud/resources/version/resources/matchmaker/resources/lobbyGroup/types/index.ts"() {
    "use strict";
    init_LobbyGroup();
    init_LobbyGroupRuntime();
    init_LobbyGroupRegion();
    init_LobbyGroupRuntimeDocker();
    init_LobbyGroupRuntimeDockerEnvVar();
    init_LobbyGroupRuntimeDockerPort();
    init_LobbyGroupIdleLobbiesConfig();
  }
});

// src/serialization/resources/cloud/resources/version/resources/matchmaker/resources/lobbyGroup/index.ts
var lobbyGroup_exports2 = {};
__export(lobbyGroup_exports2, {
  LobbyGroup: () => LobbyGroup,
  LobbyGroupIdleLobbiesConfig: () => LobbyGroupIdleLobbiesConfig,
  LobbyGroupRegion: () => LobbyGroupRegion,
  LobbyGroupRuntime: () => LobbyGroupRuntime,
  LobbyGroupRuntimeDocker: () => LobbyGroupRuntimeDocker,
  LobbyGroupRuntimeDockerEnvVar: () => LobbyGroupRuntimeDockerEnvVar,
  LobbyGroupRuntimeDockerPort: () => LobbyGroupRuntimeDockerPort
});
var init_lobbyGroup = __esm({
  "src/serialization/resources/cloud/resources/version/resources/matchmaker/resources/lobbyGroup/index.ts"() {
    "use strict";
    init_types24();
  }
});

// src/serialization/resources/cloud/resources/version/resources/matchmaker/resources/index.ts
var init_resources4 = __esm({
  "src/serialization/resources/cloud/resources/version/resources/matchmaker/resources/index.ts"() {
    "use strict";
    init_common();
    init_types22();
    init_gameMode();
    init_types23();
    init_lobbyGroup();
    init_types24();
  }
});

// src/serialization/resources/cloud/resources/version/resources/matchmaker/index.ts
var matchmaker_exports5 = {};
__export(matchmaker_exports5, {
  Captcha: () => Captcha,
  CaptchaHcaptcha: () => CaptchaHcaptcha,
  CaptchaHcaptchaLevel: () => CaptchaHcaptchaLevel2,
  CaptchaTurnstile: () => CaptchaTurnstile,
  Config: () => Config5,
  GameMode: () => GameMode,
  GameModeActions: () => GameModeActions,
  GameModeCreateConfig: () => GameModeCreateConfig,
  GameModeFindConfig: () => GameModeFindConfig,
  GameModeIdentityRequirement: () => GameModeIdentityRequirement2,
  GameModeIdleLobbiesConfig: () => GameModeIdleLobbiesConfig,
  GameModeJoinConfig: () => GameModeJoinConfig,
  GameModeRegion: () => GameModeRegion,
  GameModeRuntimeDocker: () => GameModeRuntimeDocker,
  GameModeRuntimeDockerPort: () => GameModeRuntimeDockerPort,
  GameModeVerificationConfig: () => GameModeVerificationConfig,
  LobbyGroup: () => LobbyGroup,
  LobbyGroupIdleLobbiesConfig: () => LobbyGroupIdleLobbiesConfig,
  LobbyGroupRegion: () => LobbyGroupRegion,
  LobbyGroupRuntime: () => LobbyGroupRuntime,
  LobbyGroupRuntimeDocker: () => LobbyGroupRuntimeDocker,
  LobbyGroupRuntimeDockerEnvVar: () => LobbyGroupRuntimeDockerEnvVar,
  LobbyGroupRuntimeDockerPort: () => LobbyGroupRuntimeDockerPort,
  NetworkMode: () => NetworkMode2,
  PortProtocol: () => PortProtocol2,
  PortRange: () => PortRange,
  ProxyKind: () => ProxyKind2,
  common: () => common_exports11,
  gameMode: () => gameMode_exports2,
  lobbyGroup: () => lobbyGroup_exports2
});
var init_matchmaker2 = __esm({
  "src/serialization/resources/cloud/resources/version/resources/matchmaker/index.ts"() {
    "use strict";
    init_types21();
    init_resources4();
  }
});

// src/serialization/resources/cloud/resources/version/resources/identity/resources/pacakge/types/Config.ts
var Config6;
var init_Config6 = __esm({
  "src/serialization/resources/cloud/resources/version/resources/identity/resources/pacakge/types/Config.ts"() {
    "use strict";
    init_core();
    Config6 = schemas_exports.object({
      displayNames: schemas_exports.property(
        "display_names",
        schemas_exports.list(schemas_exports.string()).optional()
      ),
      avatars: schemas_exports.list(schemas_exports.string()).optional(),
      customDisplayNames: schemas_exports.property(
        "custom_display_names",
        schemas_exports.list(
          schemas_exports.lazyObject(
            async () => (await Promise.resolve().then(() => (init_serialization(), serialization_exports))).cloud.version.identity.CustomDisplayName
          )
        ).optional()
      ),
      customAvatars: schemas_exports.property(
        "custom_avatars",
        schemas_exports.list(
          schemas_exports.lazyObject(
            async () => (await Promise.resolve().then(() => (init_serialization(), serialization_exports))).cloud.version.identity.CustomAvatar
          )
        ).optional()
      )
    });
  }
});

// src/serialization/resources/cloud/resources/version/resources/identity/resources/pacakge/types/CustomDisplayName.ts
var CustomDisplayName;
var init_CustomDisplayName = __esm({
  "src/serialization/resources/cloud/resources/version/resources/identity/resources/pacakge/types/CustomDisplayName.ts"() {
    "use strict";
    init_core();
    CustomDisplayName = schemas_exports.object({
      displayName: schemas_exports.property("display_name", schemas_exports.string())
    });
  }
});

// src/serialization/resources/cloud/resources/version/resources/identity/resources/pacakge/types/CustomAvatar.ts
var CustomAvatar;
var init_CustomAvatar = __esm({
  "src/serialization/resources/cloud/resources/version/resources/identity/resources/pacakge/types/CustomAvatar.ts"() {
    "use strict";
    init_core();
    CustomAvatar = schemas_exports.object({
      uploadId: schemas_exports.property("upload_id", schemas_exports.string())
    });
  }
});

// src/serialization/resources/cloud/resources/version/resources/identity/resources/pacakge/types/index.ts
var init_types25 = __esm({
  "src/serialization/resources/cloud/resources/version/resources/identity/resources/pacakge/types/index.ts"() {
    "use strict";
    init_Config6();
    init_CustomDisplayName();
    init_CustomAvatar();
  }
});

// src/serialization/resources/cloud/resources/version/resources/identity/resources/pacakge/index.ts
var pacakge_exports2 = {};
__export(pacakge_exports2, {
  Config: () => Config6,
  CustomAvatar: () => CustomAvatar,
  CustomDisplayName: () => CustomDisplayName
});
var init_pacakge = __esm({
  "src/serialization/resources/cloud/resources/version/resources/identity/resources/pacakge/index.ts"() {
    "use strict";
    init_types25();
  }
});

// src/serialization/resources/cloud/resources/version/resources/identity/resources/index.ts
var init_resources5 = __esm({
  "src/serialization/resources/cloud/resources/version/resources/identity/resources/index.ts"() {
    "use strict";
    init_pacakge();
    init_types25();
  }
});

// src/serialization/resources/cloud/resources/version/resources/identity/index.ts
var identity_exports3 = {};
__export(identity_exports3, {
  Config: () => Config6,
  CustomAvatar: () => CustomAvatar,
  CustomDisplayName: () => CustomDisplayName,
  pacakge: () => pacakge_exports2
});
var init_identity = __esm({
  "src/serialization/resources/cloud/resources/version/resources/identity/index.ts"() {
    "use strict";
    init_resources5();
  }
});

// src/serialization/resources/cloud/resources/version/resources/index.ts
var init_resources6 = __esm({
  "src/serialization/resources/cloud/resources/version/resources/index.ts"() {
    "use strict";
    init_cdn2();
    init_engine();
    init_kv();
    init_matchmaker2();
    init_identity();
  }
});

// src/serialization/resources/cloud/resources/version/index.ts
var version_exports2 = {};
__export(version_exports2, {
  Config: () => Config,
  Full: () => Full,
  Summary: () => Summary,
  cdn: () => cdn_exports4,
  engine: () => engine_exports2,
  identity: () => identity_exports3,
  kv: () => kv_exports3,
  matchmaker: () => matchmaker_exports5
});
var init_version = __esm({
  "src/serialization/resources/cloud/resources/version/index.ts"() {
    "use strict";
    init_types13();
    init_resources6();
  }
});

// src/serialization/resources/cloud/resources/auth/types/InspectResponse.ts
var InspectResponse;
var init_InspectResponse = __esm({
  "src/serialization/resources/cloud/resources/auth/types/InspectResponse.ts"() {
    "use strict";
    init_core();
    InspectResponse = schemas_exports.object({
      agent: schemas_exports.lazyObject(async () => (await Promise.resolve().then(() => (init_serialization(), serialization_exports))).cloud.AuthAgent)
    });
  }
});

// src/serialization/resources/cloud/resources/auth/types/index.ts
var init_types26 = __esm({
  "src/serialization/resources/cloud/resources/auth/types/index.ts"() {
    "use strict";
    init_InspectResponse();
  }
});

// src/serialization/resources/cloud/resources/auth/index.ts
var auth_exports2 = {};
__export(auth_exports2, {
  InspectResponse: () => InspectResponse
});
var init_auth2 = __esm({
  "src/serialization/resources/cloud/resources/auth/index.ts"() {
    "use strict";
    init_types26();
  }
});

// src/serialization/resources/cloud/resources/common/types/SvcPerf.ts
var SvcPerf;
var init_SvcPerf = __esm({
  "src/serialization/resources/cloud/resources/common/types/SvcPerf.ts"() {
    "use strict";
    init_core();
    SvcPerf = schemas_exports.object({
      svcName: schemas_exports.property("svc_name", schemas_exports.string()),
      ts: schemas_exports.date(),
      duration: schemas_exports.number(),
      reqId: schemas_exports.property("req_id", schemas_exports.string().optional()),
      spans: schemas_exports.list(
        schemas_exports.lazyObject(async () => (await Promise.resolve().then(() => (init_serialization(), serialization_exports))).cloud.LogsPerfSpan)
      ),
      marks: schemas_exports.list(
        schemas_exports.lazyObject(async () => (await Promise.resolve().then(() => (init_serialization(), serialization_exports))).cloud.LogsPerfMark)
      )
    });
  }
});

// src/serialization/resources/cloud/resources/common/types/LogsPerfSpan.ts
var LogsPerfSpan;
var init_LogsPerfSpan = __esm({
  "src/serialization/resources/cloud/resources/common/types/LogsPerfSpan.ts"() {
    "use strict";
    init_core();
    LogsPerfSpan = schemas_exports.object({
      label: schemas_exports.string(),
      startTs: schemas_exports.property("start_ts", schemas_exports.date()),
      finishTs: schemas_exports.property("finish_ts", schemas_exports.date().optional()),
      reqId: schemas_exports.property("req_id", schemas_exports.string().optional())
    });
  }
});

// src/serialization/resources/cloud/resources/common/types/LogsPerfMark.ts
var LogsPerfMark;
var init_LogsPerfMark = __esm({
  "src/serialization/resources/cloud/resources/common/types/LogsPerfMark.ts"() {
    "use strict";
    init_core();
    LogsPerfMark = schemas_exports.object({
      label: schemas_exports.string(),
      ts: schemas_exports.date(),
      rayId: schemas_exports.property("ray_id", schemas_exports.string().optional()),
      reqId: schemas_exports.property("req_id", schemas_exports.string().optional())
    });
  }
});

// src/serialization/resources/cloud/resources/common/types/LobbySummaryAnalytics.ts
var LobbySummaryAnalytics;
var init_LobbySummaryAnalytics = __esm({
  "src/serialization/resources/cloud/resources/common/types/LobbySummaryAnalytics.ts"() {
    "use strict";
    init_core();
    LobbySummaryAnalytics = schemas_exports.object({
      lobbyId: schemas_exports.property("lobby_id", schemas_exports.string()),
      lobbyGroupId: schemas_exports.property("lobby_group_id", schemas_exports.string()),
      lobbyGroupNameId: schemas_exports.property("lobby_group_name_id", schemas_exports.string()),
      regionId: schemas_exports.property("region_id", schemas_exports.string()),
      createTs: schemas_exports.property("create_ts", schemas_exports.date()),
      isReady: schemas_exports.property("is_ready", schemas_exports.boolean()),
      isIdle: schemas_exports.property("is_idle", schemas_exports.boolean()),
      isClosed: schemas_exports.property("is_closed", schemas_exports.boolean()),
      isOutdated: schemas_exports.property("is_outdated", schemas_exports.boolean()),
      maxPlayersNormal: schemas_exports.property("max_players_normal", schemas_exports.number()),
      maxPlayersDirect: schemas_exports.property("max_players_direct", schemas_exports.number()),
      maxPlayersParty: schemas_exports.property("max_players_party", schemas_exports.number()),
      totalPlayerCount: schemas_exports.property("total_player_count", schemas_exports.number()),
      registeredPlayerCount: schemas_exports.property("registered_player_count", schemas_exports.number())
    });
  }
});

// src/serialization/resources/cloud/resources/common/types/LogsLobbySummary.ts
var LogsLobbySummary;
var init_LogsLobbySummary = __esm({
  "src/serialization/resources/cloud/resources/common/types/LogsLobbySummary.ts"() {
    "use strict";
    init_core();
    LogsLobbySummary = schemas_exports.object({
      lobbyId: schemas_exports.property("lobby_id", schemas_exports.string()),
      namespaceId: schemas_exports.property("namespace_id", schemas_exports.string()),
      lobbyGroupNameId: schemas_exports.property("lobby_group_name_id", schemas_exports.string()),
      regionId: schemas_exports.property("region_id", schemas_exports.string()),
      createTs: schemas_exports.property("create_ts", schemas_exports.date()),
      startTs: schemas_exports.property("start_ts", schemas_exports.date().optional()),
      readyTs: schemas_exports.property("ready_ts", schemas_exports.date().optional()),
      status: schemas_exports.lazyObject(async () => (await Promise.resolve().then(() => (init_serialization(), serialization_exports))).cloud.LogsLobbyStatus)
    });
  }
});

// src/serialization/resources/cloud/resources/common/types/LogsLobbyStatus.ts
var LogsLobbyStatus;
var init_LogsLobbyStatus = __esm({
  "src/serialization/resources/cloud/resources/common/types/LogsLobbyStatus.ts"() {
    "use strict";
    init_core();
    LogsLobbyStatus = schemas_exports.object({
      running: schemas_exports.lazyObject(async () => (await Promise.resolve().then(() => (init_serialization(), serialization_exports))).EmptyObject),
      stopped: schemas_exports.lazyObject(async () => (await Promise.resolve().then(() => (init_serialization(), serialization_exports))).cloud.LogsLobbyStatusStopped).optional()
    });
  }
});

// src/serialization/resources/cloud/resources/common/types/LogsLobbyStatusStopped.ts
var LogsLobbyStatusStopped;
var init_LogsLobbyStatusStopped = __esm({
  "src/serialization/resources/cloud/resources/common/types/LogsLobbyStatusStopped.ts"() {
    "use strict";
    init_core();
    LogsLobbyStatusStopped = schemas_exports.object({
      stopTs: schemas_exports.property("stop_ts", schemas_exports.date()),
      failed: schemas_exports.boolean(),
      exitCode: schemas_exports.property("exit_code", schemas_exports.number())
    });
  }
});

// src/serialization/resources/cloud/resources/common/types/SvcMetrics.ts
var SvcMetrics;
var init_SvcMetrics = __esm({
  "src/serialization/resources/cloud/resources/common/types/SvcMetrics.ts"() {
    "use strict";
    init_core();
    SvcMetrics = schemas_exports.object({
      job: schemas_exports.string(),
      cpu: schemas_exports.list(schemas_exports.number()),
      memory: schemas_exports.list(schemas_exports.number()),
      allocatedMemory: schemas_exports.property("allocated_memory", schemas_exports.number().optional())
    });
  }
});

// src/serialization/resources/cloud/resources/common/types/AuthAgent.ts
var AuthAgent;
var init_AuthAgent = __esm({
  "src/serialization/resources/cloud/resources/common/types/AuthAgent.ts"() {
    "use strict";
    init_core();
    AuthAgent = schemas_exports.object({
      identity: schemas_exports.lazyObject(async () => (await Promise.resolve().then(() => (init_serialization(), serialization_exports))).cloud.AuthAgentIdentity).optional(),
      gameCloud: schemas_exports.property(
        "game_cloud",
        schemas_exports.lazyObject(async () => (await Promise.resolve().then(() => (init_serialization(), serialization_exports))).cloud.AuthAgentGameCloud).optional()
      )
    });
  }
});

// src/serialization/resources/cloud/resources/common/types/AuthAgentIdentity.ts
var AuthAgentIdentity;
var init_AuthAgentIdentity = __esm({
  "src/serialization/resources/cloud/resources/common/types/AuthAgentIdentity.ts"() {
    "use strict";
    init_core();
    AuthAgentIdentity = schemas_exports.object({
      identityId: schemas_exports.property("identity_id", schemas_exports.string())
    });
  }
});

// src/serialization/resources/cloud/resources/common/types/AuthAgentGameCloud.ts
var AuthAgentGameCloud;
var init_AuthAgentGameCloud = __esm({
  "src/serialization/resources/cloud/resources/common/types/AuthAgentGameCloud.ts"() {
    "use strict";
    init_core();
    AuthAgentGameCloud = schemas_exports.object({
      gameId: schemas_exports.property("game_id", schemas_exports.string())
    });
  }
});

// src/serialization/resources/cloud/resources/common/types/CustomAvatarSummary.ts
var CustomAvatarSummary;
var init_CustomAvatarSummary = __esm({
  "src/serialization/resources/cloud/resources/common/types/CustomAvatarSummary.ts"() {
    "use strict";
    init_core();
    CustomAvatarSummary = schemas_exports.object({
      uploadId: schemas_exports.property("upload_id", schemas_exports.string()),
      displayName: schemas_exports.property("display_name", schemas_exports.string()),
      createTs: schemas_exports.property("create_ts", schemas_exports.date()),
      url: schemas_exports.string().optional(),
      contentLength: schemas_exports.property("content_length", schemas_exports.number()),
      complete: schemas_exports.boolean()
    });
  }
});

// src/serialization/resources/cloud/resources/common/types/BuildSummary.ts
var BuildSummary;
var init_BuildSummary = __esm({
  "src/serialization/resources/cloud/resources/common/types/BuildSummary.ts"() {
    "use strict";
    init_core();
    BuildSummary = schemas_exports.object({
      buildId: schemas_exports.property("build_id", schemas_exports.string()),
      uploadId: schemas_exports.property("upload_id", schemas_exports.string()),
      displayName: schemas_exports.property("display_name", schemas_exports.string()),
      createTs: schemas_exports.property("create_ts", schemas_exports.date()),
      contentLength: schemas_exports.property("content_length", schemas_exports.number()),
      complete: schemas_exports.boolean()
    });
  }
});

// src/serialization/resources/cloud/resources/common/types/CdnSiteSummary.ts
var CdnSiteSummary;
var init_CdnSiteSummary = __esm({
  "src/serialization/resources/cloud/resources/common/types/CdnSiteSummary.ts"() {
    "use strict";
    init_core();
    CdnSiteSummary = schemas_exports.object({
      siteId: schemas_exports.property("site_id", schemas_exports.string()),
      uploadId: schemas_exports.property("upload_id", schemas_exports.string()),
      displayName: schemas_exports.property("display_name", schemas_exports.string()),
      createTs: schemas_exports.property("create_ts", schemas_exports.date()),
      contentLength: schemas_exports.property("content_length", schemas_exports.number()),
      complete: schemas_exports.boolean()
    });
  }
});

// src/serialization/resources/cloud/resources/common/types/GameFull.ts
var GameFull;
var init_GameFull = __esm({
  "src/serialization/resources/cloud/resources/common/types/GameFull.ts"() {
    "use strict";
    init_core();
    GameFull = schemas_exports.object({
      gameId: schemas_exports.property("game_id", schemas_exports.string()),
      createTs: schemas_exports.property("create_ts", schemas_exports.date()),
      nameId: schemas_exports.property("name_id", schemas_exports.string()),
      displayName: schemas_exports.property("display_name", schemas_exports.string()),
      developerGroupId: schemas_exports.property("developer_group_id", schemas_exports.string()),
      totalPlayerCount: schemas_exports.property("total_player_count", schemas_exports.number()),
      logoUrl: schemas_exports.property("logo_url", schemas_exports.string().optional()),
      bannerUrl: schemas_exports.property("banner_url", schemas_exports.string().optional()),
      namespaces: schemas_exports.list(
        schemas_exports.lazyObject(async () => (await Promise.resolve().then(() => (init_serialization(), serialization_exports))).cloud.NamespaceSummary)
      ),
      versions: schemas_exports.list(
        schemas_exports.lazyObject(async () => (await Promise.resolve().then(() => (init_serialization(), serialization_exports))).cloud.version.Summary)
      ),
      availableRegions: schemas_exports.property(
        "available_regions",
        schemas_exports.list(
          schemas_exports.lazyObject(async () => (await Promise.resolve().then(() => (init_serialization(), serialization_exports))).cloud.RegionSummary)
        )
      )
    });
  }
});

// src/serialization/resources/cloud/resources/common/types/NamespaceSummary.ts
var NamespaceSummary;
var init_NamespaceSummary = __esm({
  "src/serialization/resources/cloud/resources/common/types/NamespaceSummary.ts"() {
    "use strict";
    init_core();
    NamespaceSummary = schemas_exports.object({
      namespaceId: schemas_exports.property("namespace_id", schemas_exports.string()),
      createTs: schemas_exports.property("create_ts", schemas_exports.date()),
      displayName: schemas_exports.property("display_name", schemas_exports.string()),
      versionId: schemas_exports.property("version_id", schemas_exports.string()),
      nameId: schemas_exports.property("name_id", schemas_exports.string())
    });
  }
});

// src/serialization/resources/cloud/resources/common/types/RegionSummary.ts
var RegionSummary;
var init_RegionSummary = __esm({
  "src/serialization/resources/cloud/resources/common/types/RegionSummary.ts"() {
    "use strict";
    init_core();
    RegionSummary = schemas_exports.object({
      regionId: schemas_exports.property("region_id", schemas_exports.string()),
      regionNameId: schemas_exports.property("region_name_id", schemas_exports.string()),
      provider: schemas_exports.string(),
      universalRegion: schemas_exports.property(
        "universal_region",
        schemas_exports.lazy(async () => (await Promise.resolve().then(() => (init_serialization(), serialization_exports))).cloud.UniversalRegion)
      ),
      providerDisplayName: schemas_exports.property("provider_display_name", schemas_exports.string()),
      regionDisplayName: schemas_exports.property("region_display_name", schemas_exports.string())
    });
  }
});

// src/serialization/resources/cloud/resources/common/types/RegionTier.ts
var RegionTier;
var init_RegionTier = __esm({
  "src/serialization/resources/cloud/resources/common/types/RegionTier.ts"() {
    "use strict";
    init_core();
    RegionTier = schemas_exports.object({
      tierNameId: schemas_exports.property("tier_name_id", schemas_exports.string()),
      rivetCoresNumerator: schemas_exports.property("rivet_cores_numerator", schemas_exports.number()),
      rivetCoresDenominator: schemas_exports.property("rivet_cores_denominator", schemas_exports.number()),
      cpu: schemas_exports.number(),
      memory: schemas_exports.number(),
      disk: schemas_exports.number(),
      bandwidth: schemas_exports.number(),
      pricePerSecond: schemas_exports.property("price_per_second", schemas_exports.number())
    });
  }
});

// src/serialization/resources/cloud/resources/common/types/UniversalRegion.ts
var UniversalRegion2;
var init_UniversalRegion = __esm({
  "src/serialization/resources/cloud/resources/common/types/UniversalRegion.ts"() {
    "use strict";
    init_core();
    UniversalRegion2 = schemas_exports.enum_([
      "unknown",
      "local",
      "amsterdam",
      "atlanta",
      "bangalore",
      "dallas",
      "frankfurt",
      "london",
      "mumbai",
      "newark",
      "new_york_city",
      "san_francisco",
      "singapore",
      "sydney",
      "tokyo",
      "toronto",
      "washington_dc",
      "chicago",
      "paris",
      "seattle",
      "sao_paulo",
      "stockholm",
      "chennai",
      "osaka",
      "milan",
      "miami",
      "jakarta",
      "los_angeles"
    ]);
  }
});

// src/serialization/resources/cloud/resources/common/types/NamespaceFull.ts
var NamespaceFull;
var init_NamespaceFull = __esm({
  "src/serialization/resources/cloud/resources/common/types/NamespaceFull.ts"() {
    "use strict";
    init_core();
    NamespaceFull = schemas_exports.object({
      namespaceId: schemas_exports.property("namespace_id", schemas_exports.string()),
      createTs: schemas_exports.property("create_ts", schemas_exports.date()),
      displayName: schemas_exports.property("display_name", schemas_exports.string()),
      versionId: schemas_exports.property("version_id", schemas_exports.string()),
      nameId: schemas_exports.property("name_id", schemas_exports.string()),
      config: schemas_exports.lazyObject(async () => (await Promise.resolve().then(() => (init_serialization(), serialization_exports))).cloud.NamespaceConfig)
    });
  }
});

// src/serialization/resources/cloud/resources/common/types/NamespaceConfig.ts
var NamespaceConfig;
var init_NamespaceConfig = __esm({
  "src/serialization/resources/cloud/resources/common/types/NamespaceConfig.ts"() {
    "use strict";
    init_core();
    NamespaceConfig = schemas_exports.object({
      cdn: schemas_exports.lazyObject(async () => (await Promise.resolve().then(() => (init_serialization(), serialization_exports))).cloud.CdnNamespaceConfig),
      matchmaker: schemas_exports.lazyObject(
        async () => (await Promise.resolve().then(() => (init_serialization(), serialization_exports))).cloud.MatchmakerNamespaceConfig
      ),
      kv: schemas_exports.lazyObject(async () => (await Promise.resolve().then(() => (init_serialization(), serialization_exports))).cloud.KvNamespaceConfig),
      identity: schemas_exports.lazyObject(async () => (await Promise.resolve().then(() => (init_serialization(), serialization_exports))).cloud.IdentityNamespaceConfig)
    });
  }
});

// src/serialization/resources/cloud/resources/common/types/CdnNamespaceConfig.ts
var CdnNamespaceConfig;
var init_CdnNamespaceConfig = __esm({
  "src/serialization/resources/cloud/resources/common/types/CdnNamespaceConfig.ts"() {
    "use strict";
    init_core();
    CdnNamespaceConfig = schemas_exports.object({
      enableDomainPublicAuth: schemas_exports.property("enable_domain_public_auth", schemas_exports.boolean()),
      domains: schemas_exports.list(
        schemas_exports.lazyObject(async () => (await Promise.resolve().then(() => (init_serialization(), serialization_exports))).cloud.CdnNamespaceDomain)
      ),
      authType: schemas_exports.property(
        "auth_type",
        schemas_exports.lazy(async () => (await Promise.resolve().then(() => (init_serialization(), serialization_exports))).cloud.CdnAuthType)
      ),
      authUserList: schemas_exports.property(
        "auth_user_list",
        schemas_exports.list(
          schemas_exports.lazyObject(async () => (await Promise.resolve().then(() => (init_serialization(), serialization_exports))).cloud.CdnNamespaceAuthUser)
        )
      )
    });
  }
});

// src/serialization/resources/cloud/resources/common/types/MatchmakerNamespaceConfig.ts
var MatchmakerNamespaceConfig;
var init_MatchmakerNamespaceConfig = __esm({
  "src/serialization/resources/cloud/resources/common/types/MatchmakerNamespaceConfig.ts"() {
    "use strict";
    init_core();
    MatchmakerNamespaceConfig = schemas_exports.object({
      lobbyCountMax: schemas_exports.property("lobby_count_max", schemas_exports.number()),
      maxPlayersPerClient: schemas_exports.property("max_players_per_client", schemas_exports.number()),
      maxPlayersPerClientVpn: schemas_exports.property("max_players_per_client_vpn", schemas_exports.number()),
      maxPlayersPerClientProxy: schemas_exports.property("max_players_per_client_proxy", schemas_exports.number()),
      maxPlayersPerClientTor: schemas_exports.property("max_players_per_client_tor", schemas_exports.number()),
      maxPlayersPerClientHosting: schemas_exports.property(
        "max_players_per_client_hosting",
        schemas_exports.number()
      )
    });
  }
});

// src/serialization/resources/cloud/resources/common/types/KvNamespaceConfig.ts
var KvNamespaceConfig;
var init_KvNamespaceConfig = __esm({
  "src/serialization/resources/cloud/resources/common/types/KvNamespaceConfig.ts"() {
    "use strict";
    init_core();
    KvNamespaceConfig = schemas_exports.object({});
  }
});

// src/serialization/resources/cloud/resources/common/types/IdentityNamespaceConfig.ts
var IdentityNamespaceConfig;
var init_IdentityNamespaceConfig = __esm({
  "src/serialization/resources/cloud/resources/common/types/IdentityNamespaceConfig.ts"() {
    "use strict";
    init_core();
    IdentityNamespaceConfig = schemas_exports.object({});
  }
});

// src/serialization/resources/cloud/resources/common/types/CdnAuthType.ts
var CdnAuthType2;
var init_CdnAuthType = __esm({
  "src/serialization/resources/cloud/resources/common/types/CdnAuthType.ts"() {
    "use strict";
    init_core();
    CdnAuthType2 = schemas_exports.enum_(["none", "basic"]);
  }
});

// src/serialization/resources/cloud/resources/common/types/CdnNamespaceDomain.ts
var CdnNamespaceDomain;
var init_CdnNamespaceDomain = __esm({
  "src/serialization/resources/cloud/resources/common/types/CdnNamespaceDomain.ts"() {
    "use strict";
    init_core();
    CdnNamespaceDomain = schemas_exports.object({
      domain: schemas_exports.string(),
      createTs: schemas_exports.property("create_ts", schemas_exports.date()),
      verificationStatus: schemas_exports.property(
        "verification_status",
        schemas_exports.lazy(async () => (await Promise.resolve().then(() => (init_serialization(), serialization_exports))).cloud.CdnNamespaceDomainVerificationStatus)
      ),
      verificationMethod: schemas_exports.property(
        "verification_method",
        schemas_exports.lazyObject(
          async () => (await Promise.resolve().then(() => (init_serialization(), serialization_exports))).cloud.CdnNamespaceDomainVerificationMethod
        )
      ),
      verificationErrors: schemas_exports.property(
        "verification_errors",
        schemas_exports.list(schemas_exports.string())
      )
    });
  }
});

// src/serialization/resources/cloud/resources/common/types/CdnNamespaceDomainVerificationMethod.ts
var CdnNamespaceDomainVerificationMethod;
var init_CdnNamespaceDomainVerificationMethod = __esm({
  "src/serialization/resources/cloud/resources/common/types/CdnNamespaceDomainVerificationMethod.ts"() {
    "use strict";
    init_core();
    CdnNamespaceDomainVerificationMethod = schemas_exports.object({
      invalid: schemas_exports.lazyObject(async () => (await Promise.resolve().then(() => (init_serialization(), serialization_exports))).EmptyObject).optional(),
      http: schemas_exports.lazyObject(async () => (await Promise.resolve().then(() => (init_serialization(), serialization_exports))).cloud.CdnNamespaceDomainVerificationMethodHttp).optional()
    });
  }
});

// src/serialization/resources/cloud/resources/common/types/CdnNamespaceDomainVerificationMethodHttp.ts
var CdnNamespaceDomainVerificationMethodHttp;
var init_CdnNamespaceDomainVerificationMethodHttp = __esm({
  "src/serialization/resources/cloud/resources/common/types/CdnNamespaceDomainVerificationMethodHttp.ts"() {
    "use strict";
    init_core();
    CdnNamespaceDomainVerificationMethodHttp = schemas_exports.object({
      cnameRecord: schemas_exports.property("cname_record", schemas_exports.string())
    });
  }
});

// src/serialization/resources/cloud/resources/common/types/CdnNamespaceDomainVerificationStatus.ts
var CdnNamespaceDomainVerificationStatus2;
var init_CdnNamespaceDomainVerificationStatus = __esm({
  "src/serialization/resources/cloud/resources/common/types/CdnNamespaceDomainVerificationStatus.ts"() {
    "use strict";
    init_core();
    CdnNamespaceDomainVerificationStatus2 = schemas_exports.enum_(["active", "pending", "failed"]);
  }
});

// src/serialization/resources/cloud/resources/common/types/CdnNamespaceAuthUser.ts
var CdnNamespaceAuthUser;
var init_CdnNamespaceAuthUser = __esm({
  "src/serialization/resources/cloud/resources/common/types/CdnNamespaceAuthUser.ts"() {
    "use strict";
    init_core();
    CdnNamespaceAuthUser = schemas_exports.object({
      user: schemas_exports.string()
    });
  }
});

// src/serialization/resources/cloud/resources/common/types/MatchmakerDevelopmentPort.ts
var MatchmakerDevelopmentPort;
var init_MatchmakerDevelopmentPort = __esm({
  "src/serialization/resources/cloud/resources/common/types/MatchmakerDevelopmentPort.ts"() {
    "use strict";
    init_core();
    MatchmakerDevelopmentPort = schemas_exports.object({
      port: schemas_exports.number().optional(),
      portRange: schemas_exports.property(
        "port_range",
        schemas_exports.lazyObject(async () => (await Promise.resolve().then(() => (init_serialization(), serialization_exports))).cloud.version.matchmaker.PortRange).optional()
      ),
      protocol: schemas_exports.lazy(
        async () => (await Promise.resolve().then(() => (init_serialization(), serialization_exports))).cloud.version.matchmaker.PortProtocol
      )
    });
  }
});

// src/serialization/resources/cloud/resources/common/types/NamespaceVersion.ts
var NamespaceVersion;
var init_NamespaceVersion = __esm({
  "src/serialization/resources/cloud/resources/common/types/NamespaceVersion.ts"() {
    "use strict";
    init_core();
    NamespaceVersion = schemas_exports.object({
      namespaceId: schemas_exports.property("namespace_id", schemas_exports.string()),
      versionId: schemas_exports.property("version_id", schemas_exports.string()),
      deployTs: schemas_exports.property("deploy_ts", schemas_exports.date())
    });
  }
});

// src/serialization/resources/cloud/resources/common/types/index.ts
var init_types27 = __esm({
  "src/serialization/resources/cloud/resources/common/types/index.ts"() {
    "use strict";
    init_SvcPerf();
    init_LogsPerfSpan();
    init_LogsPerfMark();
    init_LobbySummaryAnalytics();
    init_LogsLobbySummary();
    init_LogsLobbyStatus();
    init_LogsLobbyStatusStopped();
    init_SvcMetrics();
    init_AuthAgent();
    init_AuthAgentIdentity();
    init_AuthAgentGameCloud();
    init_CustomAvatarSummary();
    init_BuildSummary();
    init_CdnSiteSummary();
    init_GameFull();
    init_NamespaceSummary();
    init_RegionSummary();
    init_RegionTier();
    init_UniversalRegion();
    init_NamespaceFull();
    init_NamespaceConfig();
    init_CdnNamespaceConfig();
    init_MatchmakerNamespaceConfig();
    init_KvNamespaceConfig();
    init_IdentityNamespaceConfig();
    init_CdnAuthType();
    init_CdnNamespaceDomain();
    init_CdnNamespaceDomainVerificationMethod();
    init_CdnNamespaceDomainVerificationMethodHttp();
    init_CdnNamespaceDomainVerificationStatus();
    init_CdnNamespaceAuthUser();
    init_MatchmakerDevelopmentPort();
    init_NamespaceVersion();
  }
});

// src/serialization/resources/cloud/resources/common/index.ts
var common_exports12 = {};
__export(common_exports12, {
  AuthAgent: () => AuthAgent,
  AuthAgentGameCloud: () => AuthAgentGameCloud,
  AuthAgentIdentity: () => AuthAgentIdentity,
  BuildSummary: () => BuildSummary,
  CdnAuthType: () => CdnAuthType2,
  CdnNamespaceAuthUser: () => CdnNamespaceAuthUser,
  CdnNamespaceConfig: () => CdnNamespaceConfig,
  CdnNamespaceDomain: () => CdnNamespaceDomain,
  CdnNamespaceDomainVerificationMethod: () => CdnNamespaceDomainVerificationMethod,
  CdnNamespaceDomainVerificationMethodHttp: () => CdnNamespaceDomainVerificationMethodHttp,
  CdnNamespaceDomainVerificationStatus: () => CdnNamespaceDomainVerificationStatus2,
  CdnSiteSummary: () => CdnSiteSummary,
  CustomAvatarSummary: () => CustomAvatarSummary,
  GameFull: () => GameFull,
  IdentityNamespaceConfig: () => IdentityNamespaceConfig,
  KvNamespaceConfig: () => KvNamespaceConfig,
  LobbySummaryAnalytics: () => LobbySummaryAnalytics,
  LogsLobbyStatus: () => LogsLobbyStatus,
  LogsLobbyStatusStopped: () => LogsLobbyStatusStopped,
  LogsLobbySummary: () => LogsLobbySummary,
  LogsPerfMark: () => LogsPerfMark,
  LogsPerfSpan: () => LogsPerfSpan,
  MatchmakerDevelopmentPort: () => MatchmakerDevelopmentPort,
  MatchmakerNamespaceConfig: () => MatchmakerNamespaceConfig,
  NamespaceConfig: () => NamespaceConfig,
  NamespaceFull: () => NamespaceFull,
  NamespaceSummary: () => NamespaceSummary,
  NamespaceVersion: () => NamespaceVersion,
  RegionSummary: () => RegionSummary,
  RegionTier: () => RegionTier,
  SvcMetrics: () => SvcMetrics,
  SvcPerf: () => SvcPerf,
  UniversalRegion: () => UniversalRegion2
});
var init_common2 = __esm({
  "src/serialization/resources/cloud/resources/common/index.ts"() {
    "use strict";
    init_types27();
  }
});

// src/serialization/resources/cloud/resources/devices/resources/links/types/PrepareDeviceLinkResponse.ts
var PrepareDeviceLinkResponse;
var init_PrepareDeviceLinkResponse = __esm({
  "src/serialization/resources/cloud/resources/devices/resources/links/types/PrepareDeviceLinkResponse.ts"() {
    "use strict";
    init_core();
    PrepareDeviceLinkResponse = schemas_exports.object({
      deviceLinkId: schemas_exports.property("device_link_id", schemas_exports.string()),
      deviceLinkToken: schemas_exports.property("device_link_token", schemas_exports.string()),
      deviceLinkUrl: schemas_exports.property("device_link_url", schemas_exports.string())
    });
  }
});

// src/serialization/resources/cloud/resources/devices/resources/links/types/GetDeviceLinkResponse.ts
var GetDeviceLinkResponse;
var init_GetDeviceLinkResponse = __esm({
  "src/serialization/resources/cloud/resources/devices/resources/links/types/GetDeviceLinkResponse.ts"() {
    "use strict";
    init_core();
    GetDeviceLinkResponse = schemas_exports.object({
      cloudToken: schemas_exports.property("cloud_token", schemas_exports.string().optional()),
      watch: schemas_exports.lazyObject(async () => (await Promise.resolve().then(() => (init_serialization(), serialization_exports))).WatchResponse)
    });
  }
});

// src/serialization/resources/cloud/resources/devices/resources/links/types/index.ts
var init_types28 = __esm({
  "src/serialization/resources/cloud/resources/devices/resources/links/types/index.ts"() {
    "use strict";
    init_PrepareDeviceLinkResponse();
    init_GetDeviceLinkResponse();
  }
});

// src/serialization/resources/cloud/resources/devices/resources/links/index.ts
var links_exports3 = {};
__export(links_exports3, {
  GetDeviceLinkResponse: () => GetDeviceLinkResponse,
  PrepareDeviceLinkResponse: () => PrepareDeviceLinkResponse
});
var init_links = __esm({
  "src/serialization/resources/cloud/resources/devices/resources/links/index.ts"() {
    "use strict";
    init_types28();
  }
});

// src/serialization/resources/cloud/resources/devices/resources/index.ts
var init_resources7 = __esm({
  "src/serialization/resources/cloud/resources/devices/resources/index.ts"() {
    "use strict";
    init_links();
    init_types28();
  }
});

// src/serialization/resources/cloud/resources/devices/index.ts
var devices_exports2 = {};
__export(devices_exports2, {
  GetDeviceLinkResponse: () => GetDeviceLinkResponse,
  PrepareDeviceLinkResponse: () => PrepareDeviceLinkResponse,
  links: () => links_exports3
});
var init_devices = __esm({
  "src/serialization/resources/cloud/resources/devices/index.ts"() {
    "use strict";
    init_resources7();
  }
});

// src/serialization/resources/cloud/resources/groups/types/ValidateGroupRequest.ts
var ValidateGroupRequest;
var init_ValidateGroupRequest = __esm({
  "src/serialization/resources/cloud/resources/groups/types/ValidateGroupRequest.ts"() {
    "use strict";
    init_core();
    ValidateGroupRequest = schemas_exports.object({
      displayName: schemas_exports.property("display_name", schemas_exports.string())
    });
  }
});

// src/serialization/resources/cloud/resources/groups/types/ValidateGroupResponse.ts
var ValidateGroupResponse;
var init_ValidateGroupResponse = __esm({
  "src/serialization/resources/cloud/resources/groups/types/ValidateGroupResponse.ts"() {
    "use strict";
    init_core();
    ValidateGroupResponse = schemas_exports.object({
      errors: schemas_exports.list(
        schemas_exports.lazyObject(async () => (await Promise.resolve().then(() => (init_serialization(), serialization_exports))).ValidationError)
      )
    });
  }
});

// src/serialization/resources/cloud/resources/groups/types/index.ts
var init_types29 = __esm({
  "src/serialization/resources/cloud/resources/groups/types/index.ts"() {
    "use strict";
    init_ValidateGroupRequest();
    init_ValidateGroupResponse();
  }
});

// src/serialization/resources/cloud/resources/groups/index.ts
var groups_exports2 = {};
__export(groups_exports2, {
  ValidateGroupRequest: () => ValidateGroupRequest,
  ValidateGroupResponse: () => ValidateGroupResponse
});
var init_groups = __esm({
  "src/serialization/resources/cloud/resources/groups/index.ts"() {
    "use strict";
    init_types29();
  }
});

// src/serialization/resources/cloud/resources/logs/types/GetRayPerfLogsResponse.ts
var GetRayPerfLogsResponse;
var init_GetRayPerfLogsResponse = __esm({
  "src/serialization/resources/cloud/resources/logs/types/GetRayPerfLogsResponse.ts"() {
    "use strict";
    init_core();
    GetRayPerfLogsResponse = schemas_exports.object({
      perfLists: schemas_exports.property(
        "perf_lists",
        schemas_exports.list(
          schemas_exports.lazyObject(async () => (await Promise.resolve().then(() => (init_serialization(), serialization_exports))).cloud.SvcPerf)
        )
      )
    });
  }
});

// src/serialization/resources/cloud/resources/logs/types/index.ts
var init_types30 = __esm({
  "src/serialization/resources/cloud/resources/logs/types/index.ts"() {
    "use strict";
    init_GetRayPerfLogsResponse();
  }
});

// src/serialization/resources/cloud/resources/logs/index.ts
var logs_exports4 = {};
__export(logs_exports4, {
  GetRayPerfLogsResponse: () => GetRayPerfLogsResponse
});
var init_logs2 = __esm({
  "src/serialization/resources/cloud/resources/logs/index.ts"() {
    "use strict";
    init_types30();
  }
});

// src/serialization/resources/cloud/resources/tiers/types/GetRegionTiersResponse.ts
var GetRegionTiersResponse;
var init_GetRegionTiersResponse = __esm({
  "src/serialization/resources/cloud/resources/tiers/types/GetRegionTiersResponse.ts"() {
    "use strict";
    init_core();
    GetRegionTiersResponse = schemas_exports.object({
      tiers: schemas_exports.list(
        schemas_exports.lazyObject(async () => (await Promise.resolve().then(() => (init_serialization(), serialization_exports))).cloud.RegionTier)
      )
    });
  }
});

// src/serialization/resources/cloud/resources/tiers/types/index.ts
var init_types31 = __esm({
  "src/serialization/resources/cloud/resources/tiers/types/index.ts"() {
    "use strict";
    init_GetRegionTiersResponse();
  }
});

// src/serialization/resources/cloud/resources/tiers/index.ts
var tiers_exports2 = {};
__export(tiers_exports2, {
  GetRegionTiersResponse: () => GetRegionTiersResponse
});
var init_tiers = __esm({
  "src/serialization/resources/cloud/resources/tiers/index.ts"() {
    "use strict";
    init_types31();
  }
});

// src/serialization/resources/cloud/resources/index.ts
var init_resources8 = __esm({
  "src/serialization/resources/cloud/resources/index.ts"() {
    "use strict";
    init_games2();
    init_version();
    init_auth2();
    init_types26();
    init_common2();
    init_types27();
    init_devices();
    init_groups();
    init_types29();
    init_logs2();
    init_types30();
    init_tiers();
    init_types31();
  }
});

// src/serialization/resources/cloud/index.ts
var cloud_exports2 = {};
__export(cloud_exports2, {
  AuthAgent: () => AuthAgent,
  AuthAgentGameCloud: () => AuthAgentGameCloud,
  AuthAgentIdentity: () => AuthAgentIdentity,
  BootstrapCaptcha: () => BootstrapCaptcha,
  BootstrapCaptchaTurnstile: () => BootstrapCaptchaTurnstile,
  BootstrapCluster: () => BootstrapCluster2,
  BootstrapResponse: () => BootstrapResponse,
  BuildSummary: () => BuildSummary,
  CdnAuthType: () => CdnAuthType2,
  CdnNamespaceAuthUser: () => CdnNamespaceAuthUser,
  CdnNamespaceConfig: () => CdnNamespaceConfig,
  CdnNamespaceDomain: () => CdnNamespaceDomain,
  CdnNamespaceDomainVerificationMethod: () => CdnNamespaceDomainVerificationMethod,
  CdnNamespaceDomainVerificationMethodHttp: () => CdnNamespaceDomainVerificationMethodHttp,
  CdnNamespaceDomainVerificationStatus: () => CdnNamespaceDomainVerificationStatus2,
  CdnSiteSummary: () => CdnSiteSummary,
  CustomAvatarSummary: () => CustomAvatarSummary,
  GameFull: () => GameFull,
  GetRayPerfLogsResponse: () => GetRayPerfLogsResponse,
  GetRegionTiersResponse: () => GetRegionTiersResponse,
  IdentityNamespaceConfig: () => IdentityNamespaceConfig,
  InspectResponse: () => InspectResponse,
  KvNamespaceConfig: () => KvNamespaceConfig,
  LobbySummaryAnalytics: () => LobbySummaryAnalytics,
  LogsLobbyStatus: () => LogsLobbyStatus,
  LogsLobbyStatusStopped: () => LogsLobbyStatusStopped,
  LogsLobbySummary: () => LogsLobbySummary,
  LogsPerfMark: () => LogsPerfMark,
  LogsPerfSpan: () => LogsPerfSpan,
  MatchmakerDevelopmentPort: () => MatchmakerDevelopmentPort,
  MatchmakerNamespaceConfig: () => MatchmakerNamespaceConfig,
  NamespaceConfig: () => NamespaceConfig,
  NamespaceFull: () => NamespaceFull,
  NamespaceSummary: () => NamespaceSummary,
  NamespaceVersion: () => NamespaceVersion,
  RegionSummary: () => RegionSummary,
  RegionTier: () => RegionTier,
  SvcMetrics: () => SvcMetrics,
  SvcPerf: () => SvcPerf,
  UniversalRegion: () => UniversalRegion2,
  ValidateGroupRequest: () => ValidateGroupRequest,
  ValidateGroupResponse: () => ValidateGroupResponse,
  auth: () => auth_exports2,
  common: () => common_exports12,
  devices: () => devices_exports2,
  games: () => games_exports4,
  groups: () => groups_exports2,
  logs: () => logs_exports4,
  tiers: () => tiers_exports2,
  version: () => version_exports2
});
var init_cloud = __esm({
  "src/serialization/resources/cloud/index.ts"() {
    "use strict";
    init_types2();
    init_resources8();
  }
});

// src/serialization/resources/group/types/ListSuggestedResponse.ts
var ListSuggestedResponse;
var init_ListSuggestedResponse = __esm({
  "src/serialization/resources/group/types/ListSuggestedResponse.ts"() {
    "use strict";
    init_core();
    ListSuggestedResponse = schemas_exports.object({
      groups: schemas_exports.list(
        schemas_exports.lazyObject(async () => (await Promise.resolve().then(() => (init_serialization(), serialization_exports))).group.Summary)
      ),
      watch: schemas_exports.lazyObject(async () => (await Promise.resolve().then(() => (init_serialization(), serialization_exports))).WatchResponse)
    });
  }
});

// src/serialization/resources/group/types/CreateRequest.ts
var CreateRequest;
var init_CreateRequest = __esm({
  "src/serialization/resources/group/types/CreateRequest.ts"() {
    "use strict";
    init_core();
    CreateRequest = schemas_exports.object({
      displayName: schemas_exports.property("display_name", schemas_exports.string())
    });
  }
});

// src/serialization/resources/group/types/CreateResponse.ts
var CreateResponse;
var init_CreateResponse = __esm({
  "src/serialization/resources/group/types/CreateResponse.ts"() {
    "use strict";
    init_core();
    CreateResponse = schemas_exports.object({
      groupId: schemas_exports.property("group_id", schemas_exports.string())
    });
  }
});

// src/serialization/resources/group/types/PrepareAvatarUploadRequest.ts
var PrepareAvatarUploadRequest;
var init_PrepareAvatarUploadRequest = __esm({
  "src/serialization/resources/group/types/PrepareAvatarUploadRequest.ts"() {
    "use strict";
    init_core();
    PrepareAvatarUploadRequest = schemas_exports.object({
      path: schemas_exports.string(),
      mime: schemas_exports.string().optional(),
      contentLength: schemas_exports.property("content_length", schemas_exports.number())
    });
  }
});

// src/serialization/resources/group/types/PrepareAvatarUploadResponse.ts
var PrepareAvatarUploadResponse;
var init_PrepareAvatarUploadResponse = __esm({
  "src/serialization/resources/group/types/PrepareAvatarUploadResponse.ts"() {
    "use strict";
    init_core();
    PrepareAvatarUploadResponse = schemas_exports.object({
      uploadId: schemas_exports.property("upload_id", schemas_exports.string()),
      presignedRequest: schemas_exports.property(
        "presigned_request",
        schemas_exports.lazyObject(async () => (await Promise.resolve().then(() => (init_serialization(), serialization_exports))).upload.PresignedRequest)
      )
    });
  }
});

// src/serialization/resources/group/types/ValidateProfileRequest.ts
var ValidateProfileRequest;
var init_ValidateProfileRequest = __esm({
  "src/serialization/resources/group/types/ValidateProfileRequest.ts"() {
    "use strict";
    init_core();
    ValidateProfileRequest = schemas_exports.object({
      displayName: schemas_exports.property("display_name", schemas_exports.string().optional()),
      bio: schemas_exports.string().optional(),
      publicity: schemas_exports.lazy(async () => (await Promise.resolve().then(() => (init_serialization(), serialization_exports))).group.Publicity).optional()
    });
  }
});

// src/serialization/resources/group/types/ValidateProfileResponse.ts
var ValidateProfileResponse;
var init_ValidateProfileResponse = __esm({
  "src/serialization/resources/group/types/ValidateProfileResponse.ts"() {
    "use strict";
    init_core();
    ValidateProfileResponse = schemas_exports.object({
      errors: schemas_exports.list(
        schemas_exports.lazyObject(async () => (await Promise.resolve().then(() => (init_serialization(), serialization_exports))).ValidationError)
      )
    });
  }
});

// src/serialization/resources/group/types/SearchResponse.ts
var SearchResponse;
var init_SearchResponse = __esm({
  "src/serialization/resources/group/types/SearchResponse.ts"() {
    "use strict";
    init_core();
    SearchResponse = schemas_exports.object({
      groups: schemas_exports.list(schemas_exports.lazyObject(async () => (await Promise.resolve().then(() => (init_serialization(), serialization_exports))).group.Handle)),
      anchor: schemas_exports.string().optional()
    });
  }
});

// src/serialization/resources/group/types/GetBansResponse.ts
var GetBansResponse;
var init_GetBansResponse = __esm({
  "src/serialization/resources/group/types/GetBansResponse.ts"() {
    "use strict";
    init_core();
    GetBansResponse = schemas_exports.object({
      bannedIdentities: schemas_exports.property(
        "banned_identities",
        schemas_exports.list(
          schemas_exports.lazyObject(async () => (await Promise.resolve().then(() => (init_serialization(), serialization_exports))).group.BannedIdentity)
        )
      ),
      anchor: schemas_exports.string().optional(),
      watch: schemas_exports.lazyObject(async () => (await Promise.resolve().then(() => (init_serialization(), serialization_exports))).WatchResponse)
    });
  }
});

// src/serialization/resources/group/types/GetJoinRequestsResponse.ts
var GetJoinRequestsResponse;
var init_GetJoinRequestsResponse = __esm({
  "src/serialization/resources/group/types/GetJoinRequestsResponse.ts"() {
    "use strict";
    init_core();
    GetJoinRequestsResponse = schemas_exports.object({
      joinRequests: schemas_exports.property(
        "join_requests",
        schemas_exports.list(schemas_exports.lazyObject(async () => (await Promise.resolve().then(() => (init_serialization(), serialization_exports))).group.JoinRequest))
      ),
      anchor: schemas_exports.string().optional(),
      watch: schemas_exports.lazyObject(async () => (await Promise.resolve().then(() => (init_serialization(), serialization_exports))).WatchResponse)
    });
  }
});

// src/serialization/resources/group/types/GetMembersResponse.ts
var GetMembersResponse;
var init_GetMembersResponse = __esm({
  "src/serialization/resources/group/types/GetMembersResponse.ts"() {
    "use strict";
    init_core();
    GetMembersResponse = schemas_exports.object({
      members: schemas_exports.list(
        schemas_exports.lazyObject(async () => (await Promise.resolve().then(() => (init_serialization(), serialization_exports))).group.Member)
      ),
      anchor: schemas_exports.string().optional(),
      watch: schemas_exports.lazyObject(async () => (await Promise.resolve().then(() => (init_serialization(), serialization_exports))).WatchResponse)
    });
  }
});

// src/serialization/resources/group/types/GetProfileResponse.ts
var GetProfileResponse;
var init_GetProfileResponse = __esm({
  "src/serialization/resources/group/types/GetProfileResponse.ts"() {
    "use strict";
    init_core();
    GetProfileResponse = schemas_exports.object({
      group: schemas_exports.lazyObject(async () => (await Promise.resolve().then(() => (init_serialization(), serialization_exports))).group.Profile),
      watch: schemas_exports.lazyObject(async () => (await Promise.resolve().then(() => (init_serialization(), serialization_exports))).WatchResponse)
    });
  }
});

// src/serialization/resources/group/types/UpdateProfileRequest.ts
var UpdateProfileRequest;
var init_UpdateProfileRequest = __esm({
  "src/serialization/resources/group/types/UpdateProfileRequest.ts"() {
    "use strict";
    init_core();
    UpdateProfileRequest = schemas_exports.object({
      displayName: schemas_exports.property("display_name", schemas_exports.string().optional()),
      bio: schemas_exports.string().optional(),
      publicity: schemas_exports.lazy(async () => (await Promise.resolve().then(() => (init_serialization(), serialization_exports))).group.Publicity).optional()
    });
  }
});

// src/serialization/resources/group/types/GetSummaryResponse.ts
var GetSummaryResponse;
var init_GetSummaryResponse = __esm({
  "src/serialization/resources/group/types/GetSummaryResponse.ts"() {
    "use strict";
    init_core();
    GetSummaryResponse = schemas_exports.object({
      group: schemas_exports.lazyObject(async () => (await Promise.resolve().then(() => (init_serialization(), serialization_exports))).group.Summary)
    });
  }
});

// src/serialization/resources/group/types/TransferOwnershipRequest.ts
var TransferOwnershipRequest;
var init_TransferOwnershipRequest = __esm({
  "src/serialization/resources/group/types/TransferOwnershipRequest.ts"() {
    "use strict";
    init_core();
    TransferOwnershipRequest = schemas_exports.object({
      newOwnerIdentityId: schemas_exports.property("new_owner_identity_id", schemas_exports.string())
    });
  }
});

// src/serialization/resources/group/types/index.ts
var init_types32 = __esm({
  "src/serialization/resources/group/types/index.ts"() {
    "use strict";
    init_ListSuggestedResponse();
    init_CreateRequest();
    init_CreateResponse();
    init_PrepareAvatarUploadRequest();
    init_PrepareAvatarUploadResponse();
    init_ValidateProfileRequest();
    init_ValidateProfileResponse();
    init_SearchResponse();
    init_GetBansResponse();
    init_GetJoinRequestsResponse();
    init_GetMembersResponse();
    init_GetProfileResponse();
    init_UpdateProfileRequest();
    init_GetSummaryResponse();
    init_TransferOwnershipRequest();
  }
});

// src/serialization/resources/group/resources/common/types/Summary.ts
var Summary2;
var init_Summary2 = __esm({
  "src/serialization/resources/group/resources/common/types/Summary.ts"() {
    "use strict";
    init_core();
    Summary2 = schemas_exports.object({
      groupId: schemas_exports.property("group_id", schemas_exports.string()),
      displayName: schemas_exports.property(
        "display_name",
        schemas_exports.lazy(async () => (await Promise.resolve().then(() => (init_serialization(), serialization_exports))).DisplayName)
      ),
      avatarUrl: schemas_exports.property("avatar_url", schemas_exports.string().optional()),
      external: schemas_exports.lazyObject(async () => (await Promise.resolve().then(() => (init_serialization(), serialization_exports))).group.ExternalLinks),
      isDeveloper: schemas_exports.property("is_developer", schemas_exports.boolean()),
      bio: schemas_exports.lazy(async () => (await Promise.resolve().then(() => (init_serialization(), serialization_exports))).Bio),
      isCurrentIdentityMember: schemas_exports.property(
        "is_current_identity_member",
        schemas_exports.boolean()
      ),
      publicity: schemas_exports.lazy(async () => (await Promise.resolve().then(() => (init_serialization(), serialization_exports))).group.Publicity),
      memberCount: schemas_exports.property("member_count", schemas_exports.number()),
      ownerIdentityId: schemas_exports.property("owner_identity_id", schemas_exports.string())
    });
  }
});

// src/serialization/resources/group/resources/common/types/Publicity.ts
var Publicity2;
var init_Publicity = __esm({
  "src/serialization/resources/group/resources/common/types/Publicity.ts"() {
    "use strict";
    init_core();
    Publicity2 = schemas_exports.enum_(["open", "closed"]);
  }
});

// src/serialization/resources/group/resources/common/types/Handle.ts
var Handle;
var init_Handle = __esm({
  "src/serialization/resources/group/resources/common/types/Handle.ts"() {
    "use strict";
    init_core();
    Handle = schemas_exports.object({
      groupId: schemas_exports.property("group_id", schemas_exports.string()),
      displayName: schemas_exports.property(
        "display_name",
        schemas_exports.lazy(async () => (await Promise.resolve().then(() => (init_serialization(), serialization_exports))).DisplayName)
      ),
      avatarUrl: schemas_exports.property("avatar_url", schemas_exports.string().optional()),
      external: schemas_exports.lazyObject(async () => (await Promise.resolve().then(() => (init_serialization(), serialization_exports))).group.ExternalLinks),
      isDeveloper: schemas_exports.property("is_developer", schemas_exports.boolean().optional())
    });
  }
});

// src/serialization/resources/group/resources/common/types/ExternalLinks.ts
var ExternalLinks;
var init_ExternalLinks = __esm({
  "src/serialization/resources/group/resources/common/types/ExternalLinks.ts"() {
    "use strict";
    init_core();
    ExternalLinks = schemas_exports.object({
      profile: schemas_exports.string()
    });
  }
});

// src/serialization/resources/group/resources/common/types/JoinRequest.ts
var JoinRequest;
var init_JoinRequest = __esm({
  "src/serialization/resources/group/resources/common/types/JoinRequest.ts"() {
    "use strict";
    init_core();
    JoinRequest = schemas_exports.object({
      identity: schemas_exports.lazyObject(async () => (await Promise.resolve().then(() => (init_serialization(), serialization_exports))).identity.Handle),
      ts: schemas_exports.date()
    });
  }
});

// src/serialization/resources/group/resources/common/types/Member.ts
var Member;
var init_Member = __esm({
  "src/serialization/resources/group/resources/common/types/Member.ts"() {
    "use strict";
    init_core();
    Member = schemas_exports.object({
      identity: schemas_exports.lazyObject(async () => (await Promise.resolve().then(() => (init_serialization(), serialization_exports))).identity.Handle)
    });
  }
});

// src/serialization/resources/group/resources/common/types/Profile.ts
var Profile;
var init_Profile = __esm({
  "src/serialization/resources/group/resources/common/types/Profile.ts"() {
    "use strict";
    init_core();
    Profile = schemas_exports.object({
      groupId: schemas_exports.property("group_id", schemas_exports.string()),
      displayName: schemas_exports.property("display_name", schemas_exports.string()),
      avatarUrl: schemas_exports.property("avatar_url", schemas_exports.string().optional()),
      external: schemas_exports.lazyObject(async () => (await Promise.resolve().then(() => (init_serialization(), serialization_exports))).group.ExternalLinks),
      isDeveloper: schemas_exports.property("is_developer", schemas_exports.boolean().optional()),
      bio: schemas_exports.string(),
      isCurrentIdentityMember: schemas_exports.property(
        "is_current_identity_member",
        schemas_exports.boolean().optional()
      ),
      publicity: schemas_exports.lazy(async () => (await Promise.resolve().then(() => (init_serialization(), serialization_exports))).group.Publicity),
      memberCount: schemas_exports.property("member_count", schemas_exports.number().optional()),
      members: schemas_exports.list(
        schemas_exports.lazyObject(async () => (await Promise.resolve().then(() => (init_serialization(), serialization_exports))).group.Member)
      ),
      joinRequests: schemas_exports.property(
        "join_requests",
        schemas_exports.list(
          schemas_exports.lazyObject(async () => (await Promise.resolve().then(() => (init_serialization(), serialization_exports))).group.JoinRequest)
        )
      ),
      isCurrentIdentityRequestingJoin: schemas_exports.property(
        "is_current_identity_requesting_join",
        schemas_exports.boolean().optional()
      ),
      ownerIdentityId: schemas_exports.property("owner_identity_id", schemas_exports.string())
    });
  }
});

// src/serialization/resources/group/resources/common/types/BannedIdentity.ts
var BannedIdentity;
var init_BannedIdentity = __esm({
  "src/serialization/resources/group/resources/common/types/BannedIdentity.ts"() {
    "use strict";
    init_core();
    BannedIdentity = schemas_exports.object({
      identity: schemas_exports.lazyObject(async () => (await Promise.resolve().then(() => (init_serialization(), serialization_exports))).identity.Handle),
      banTs: schemas_exports.property("ban_ts", schemas_exports.date())
    });
  }
});

// src/serialization/resources/group/resources/common/types/index.ts
var init_types33 = __esm({
  "src/serialization/resources/group/resources/common/types/index.ts"() {
    "use strict";
    init_Summary2();
    init_Publicity();
    init_Handle();
    init_ExternalLinks();
    init_JoinRequest();
    init_Member();
    init_Profile();
    init_BannedIdentity();
  }
});

// src/serialization/resources/group/resources/common/index.ts
var common_exports13 = {};
__export(common_exports13, {
  BannedIdentity: () => BannedIdentity,
  ExternalLinks: () => ExternalLinks,
  Handle: () => Handle,
  JoinRequest: () => JoinRequest,
  Member: () => Member,
  Profile: () => Profile,
  Publicity: () => Publicity2,
  Summary: () => Summary2
});
var init_common3 = __esm({
  "src/serialization/resources/group/resources/common/index.ts"() {
    "use strict";
    init_types33();
  }
});

// src/serialization/resources/group/resources/invites/types/GetInviteResponse.ts
var GetInviteResponse;
var init_GetInviteResponse = __esm({
  "src/serialization/resources/group/resources/invites/types/GetInviteResponse.ts"() {
    "use strict";
    init_core();
    GetInviteResponse = schemas_exports.object({
      group: schemas_exports.lazyObject(async () => (await Promise.resolve().then(() => (init_serialization(), serialization_exports))).group.Handle)
    });
  }
});

// src/serialization/resources/group/resources/invites/types/ConsumeInviteResponse.ts
var ConsumeInviteResponse;
var init_ConsumeInviteResponse = __esm({
  "src/serialization/resources/group/resources/invites/types/ConsumeInviteResponse.ts"() {
    "use strict";
    init_core();
    ConsumeInviteResponse = schemas_exports.object({
      groupId: schemas_exports.property("group_id", schemas_exports.string().optional())
    });
  }
});

// src/serialization/resources/group/resources/invites/types/CreateInviteRequest.ts
var CreateInviteRequest;
var init_CreateInviteRequest = __esm({
  "src/serialization/resources/group/resources/invites/types/CreateInviteRequest.ts"() {
    "use strict";
    init_core();
    CreateInviteRequest = schemas_exports.object({
      ttl: schemas_exports.number().optional(),
      useCount: schemas_exports.property("use_count", schemas_exports.number().optional())
    });
  }
});

// src/serialization/resources/group/resources/invites/types/CreateInviteResponse.ts
var CreateInviteResponse;
var init_CreateInviteResponse = __esm({
  "src/serialization/resources/group/resources/invites/types/CreateInviteResponse.ts"() {
    "use strict";
    init_core();
    CreateInviteResponse = schemas_exports.object({
      code: schemas_exports.string()
    });
  }
});

// src/serialization/resources/group/resources/invites/types/index.ts
var init_types34 = __esm({
  "src/serialization/resources/group/resources/invites/types/index.ts"() {
    "use strict";
    init_GetInviteResponse();
    init_ConsumeInviteResponse();
    init_CreateInviteRequest();
    init_CreateInviteResponse();
  }
});

// src/serialization/resources/group/resources/invites/index.ts
var invites_exports2 = {};
__export(invites_exports2, {
  ConsumeInviteResponse: () => ConsumeInviteResponse,
  CreateInviteRequest: () => CreateInviteRequest,
  CreateInviteResponse: () => CreateInviteResponse,
  GetInviteResponse: () => GetInviteResponse
});
var init_invites = __esm({
  "src/serialization/resources/group/resources/invites/index.ts"() {
    "use strict";
    init_types34();
  }
});

// src/serialization/resources/group/resources/joinRequests/types/ResolveJoinRequestRequest.ts
var ResolveJoinRequestRequest;
var init_ResolveJoinRequestRequest = __esm({
  "src/serialization/resources/group/resources/joinRequests/types/ResolveJoinRequestRequest.ts"() {
    "use strict";
    init_core();
    ResolveJoinRequestRequest = schemas_exports.object({
      resolution: schemas_exports.boolean().optional()
    });
  }
});

// src/serialization/resources/group/resources/joinRequests/types/index.ts
var init_types35 = __esm({
  "src/serialization/resources/group/resources/joinRequests/types/index.ts"() {
    "use strict";
    init_ResolveJoinRequestRequest();
  }
});

// src/serialization/resources/group/resources/joinRequests/index.ts
var joinRequests_exports2 = {};
__export(joinRequests_exports2, {
  ResolveJoinRequestRequest: () => ResolveJoinRequestRequest
});
var init_joinRequests = __esm({
  "src/serialization/resources/group/resources/joinRequests/index.ts"() {
    "use strict";
    init_types35();
  }
});

// src/serialization/resources/group/resources/index.ts
var init_resources9 = __esm({
  "src/serialization/resources/group/resources/index.ts"() {
    "use strict";
    init_common3();
    init_types33();
    init_invites();
    init_types34();
    init_joinRequests();
    init_types35();
  }
});

// src/serialization/resources/group/index.ts
var group_exports2 = {};
__export(group_exports2, {
  BannedIdentity: () => BannedIdentity,
  ConsumeInviteResponse: () => ConsumeInviteResponse,
  CreateInviteRequest: () => CreateInviteRequest,
  CreateInviteResponse: () => CreateInviteResponse,
  CreateRequest: () => CreateRequest,
  CreateResponse: () => CreateResponse,
  ExternalLinks: () => ExternalLinks,
  GetBansResponse: () => GetBansResponse,
  GetInviteResponse: () => GetInviteResponse,
  GetJoinRequestsResponse: () => GetJoinRequestsResponse,
  GetMembersResponse: () => GetMembersResponse,
  GetProfileResponse: () => GetProfileResponse,
  GetSummaryResponse: () => GetSummaryResponse,
  Handle: () => Handle,
  JoinRequest: () => JoinRequest,
  ListSuggestedResponse: () => ListSuggestedResponse,
  Member: () => Member,
  PrepareAvatarUploadRequest: () => PrepareAvatarUploadRequest,
  PrepareAvatarUploadResponse: () => PrepareAvatarUploadResponse,
  Profile: () => Profile,
  Publicity: () => Publicity2,
  ResolveJoinRequestRequest: () => ResolveJoinRequestRequest,
  SearchResponse: () => SearchResponse,
  Summary: () => Summary2,
  TransferOwnershipRequest: () => TransferOwnershipRequest,
  UpdateProfileRequest: () => UpdateProfileRequest,
  ValidateProfileRequest: () => ValidateProfileRequest,
  ValidateProfileResponse: () => ValidateProfileResponse,
  common: () => common_exports13,
  invites: () => invites_exports2,
  joinRequests: () => joinRequests_exports2
});
var init_group = __esm({
  "src/serialization/resources/group/index.ts"() {
    "use strict";
    init_types32();
    init_resources9();
  }
});

// src/serialization/resources/identity/types/SetupResponse.ts
var SetupResponse;
var init_SetupResponse = __esm({
  "src/serialization/resources/identity/types/SetupResponse.ts"() {
    "use strict";
    init_core();
    SetupResponse = schemas_exports.object({
      identityToken: schemas_exports.property(
        "identity_token",
        schemas_exports.lazy(async () => (await Promise.resolve().then(() => (init_serialization(), serialization_exports))).Jwt)
      ),
      identityTokenExpireTs: schemas_exports.property("identity_token_expire_ts", schemas_exports.date()),
      identity: schemas_exports.lazyObject(async () => (await Promise.resolve().then(() => (init_serialization(), serialization_exports))).identity.Profile),
      gameId: schemas_exports.property("game_id", schemas_exports.string())
    });
  }
});

// src/serialization/resources/identity/types/GetProfileResponse.ts
var GetProfileResponse2;
var init_GetProfileResponse2 = __esm({
  "src/serialization/resources/identity/types/GetProfileResponse.ts"() {
    "use strict";
    init_core();
    GetProfileResponse2 = schemas_exports.object({
      identity: schemas_exports.lazyObject(async () => (await Promise.resolve().then(() => (init_serialization(), serialization_exports))).identity.Profile),
      watch: schemas_exports.lazyObject(async () => (await Promise.resolve().then(() => (init_serialization(), serialization_exports))).WatchResponse)
    });
  }
});

// src/serialization/resources/identity/types/GetHandlesResponse.ts
var GetHandlesResponse;
var init_GetHandlesResponse = __esm({
  "src/serialization/resources/identity/types/GetHandlesResponse.ts"() {
    "use strict";
    init_core();
    GetHandlesResponse = schemas_exports.object({
      identities: schemas_exports.list(
        schemas_exports.lazyObject(async () => (await Promise.resolve().then(() => (init_serialization(), serialization_exports))).identity.Handle)
      ),
      watch: schemas_exports.lazyObject(async () => (await Promise.resolve().then(() => (init_serialization(), serialization_exports))).WatchResponse)
    });
  }
});

// src/serialization/resources/identity/types/GetSummariesResponse.ts
var GetSummariesResponse;
var init_GetSummariesResponse = __esm({
  "src/serialization/resources/identity/types/GetSummariesResponse.ts"() {
    "use strict";
    init_core();
    GetSummariesResponse = schemas_exports.object({
      identities: schemas_exports.list(
        schemas_exports.lazyObject(async () => (await Promise.resolve().then(() => (init_serialization(), serialization_exports))).identity.Summary)
      ),
      watch: schemas_exports.lazyObject(async () => (await Promise.resolve().then(() => (init_serialization(), serialization_exports))).WatchResponse)
    });
  }
});

// src/serialization/resources/identity/types/SearchResponse.ts
var SearchResponse2;
var init_SearchResponse2 = __esm({
  "src/serialization/resources/identity/types/SearchResponse.ts"() {
    "use strict";
    init_core();
    SearchResponse2 = schemas_exports.object({
      identities: schemas_exports.list(
        schemas_exports.lazyObject(async () => (await Promise.resolve().then(() => (init_serialization(), serialization_exports))).identity.Handle)
      ),
      anchor: schemas_exports.string().optional()
    });
  }
});

// src/serialization/resources/identity/types/PrepareAvatarUploadResponse.ts
var PrepareAvatarUploadResponse2;
var init_PrepareAvatarUploadResponse2 = __esm({
  "src/serialization/resources/identity/types/PrepareAvatarUploadResponse.ts"() {
    "use strict";
    init_core();
    PrepareAvatarUploadResponse2 = schemas_exports.object({
      uploadId: schemas_exports.property("upload_id", schemas_exports.string()),
      presignedRequest: schemas_exports.property(
        "presigned_request",
        schemas_exports.lazyObject(async () => (await Promise.resolve().then(() => (init_serialization(), serialization_exports))).upload.PresignedRequest)
      )
    });
  }
});

// src/serialization/resources/identity/types/ListFollowersResponse.ts
var ListFollowersResponse;
var init_ListFollowersResponse = __esm({
  "src/serialization/resources/identity/types/ListFollowersResponse.ts"() {
    "use strict";
    init_core();
    ListFollowersResponse = schemas_exports.object({
      identities: schemas_exports.list(
        schemas_exports.lazyObject(async () => (await Promise.resolve().then(() => (init_serialization(), serialization_exports))).identity.Handle)
      ),
      anchor: schemas_exports.string().optional(),
      watch: schemas_exports.lazyObject(async () => (await Promise.resolve().then(() => (init_serialization(), serialization_exports))).WatchResponse)
    });
  }
});

// src/serialization/resources/identity/types/ListFollowingResponse.ts
var ListFollowingResponse;
var init_ListFollowingResponse = __esm({
  "src/serialization/resources/identity/types/ListFollowingResponse.ts"() {
    "use strict";
    init_core();
    ListFollowingResponse = schemas_exports.object({
      identities: schemas_exports.list(
        schemas_exports.lazyObject(async () => (await Promise.resolve().then(() => (init_serialization(), serialization_exports))).identity.Handle)
      ),
      anchor: schemas_exports.string().optional(),
      watch: schemas_exports.lazyObject(async () => (await Promise.resolve().then(() => (init_serialization(), serialization_exports))).WatchResponse)
    });
  }
});

// src/serialization/resources/identity/types/ListRecentFollowersResponse.ts
var ListRecentFollowersResponse;
var init_ListRecentFollowersResponse = __esm({
  "src/serialization/resources/identity/types/ListRecentFollowersResponse.ts"() {
    "use strict";
    init_core();
    ListRecentFollowersResponse = schemas_exports.object({
      identities: schemas_exports.list(
        schemas_exports.lazyObject(async () => (await Promise.resolve().then(() => (init_serialization(), serialization_exports))).identity.Handle)
      ),
      anchor: schemas_exports.string().optional(),
      watch: schemas_exports.lazyObject(async () => (await Promise.resolve().then(() => (init_serialization(), serialization_exports))).WatchResponse)
    });
  }
});

// src/serialization/resources/identity/types/ListFriendsResponse.ts
var ListFriendsResponse;
var init_ListFriendsResponse = __esm({
  "src/serialization/resources/identity/types/ListFriendsResponse.ts"() {
    "use strict";
    init_core();
    ListFriendsResponse = schemas_exports.object({
      identities: schemas_exports.list(
        schemas_exports.lazyObject(async () => (await Promise.resolve().then(() => (init_serialization(), serialization_exports))).identity.Handle)
      ),
      anchor: schemas_exports.string().optional(),
      watch: schemas_exports.lazyObject(async () => (await Promise.resolve().then(() => (init_serialization(), serialization_exports))).WatchResponse)
    });
  }
});

// src/serialization/resources/identity/types/ListMutualFriendsResponse.ts
var ListMutualFriendsResponse;
var init_ListMutualFriendsResponse = __esm({
  "src/serialization/resources/identity/types/ListMutualFriendsResponse.ts"() {
    "use strict";
    init_core();
    ListMutualFriendsResponse = schemas_exports.object({
      identities: schemas_exports.list(
        schemas_exports.lazyObject(async () => (await Promise.resolve().then(() => (init_serialization(), serialization_exports))).identity.Handle)
      ),
      anchor: schemas_exports.string().optional()
    });
  }
});

// src/serialization/resources/identity/types/index.ts
var init_types36 = __esm({
  "src/serialization/resources/identity/types/index.ts"() {
    "use strict";
    init_SetupResponse();
    init_GetProfileResponse2();
    init_GetHandlesResponse();
    init_GetSummariesResponse();
    init_SearchResponse2();
    init_PrepareAvatarUploadResponse2();
    init_ListFollowersResponse();
    init_ListFollowingResponse();
    init_ListRecentFollowersResponse();
    init_ListFriendsResponse();
    init_ListMutualFriendsResponse();
  }
});

// src/serialization/resources/identity/resources/common/types/GlobalEvent.ts
var GlobalEvent;
var init_GlobalEvent = __esm({
  "src/serialization/resources/identity/resources/common/types/GlobalEvent.ts"() {
    "use strict";
    init_core();
    GlobalEvent = schemas_exports.object({
      ts: schemas_exports.date(),
      kind: schemas_exports.lazyObject(async () => (await Promise.resolve().then(() => (init_serialization(), serialization_exports))).identity.GlobalEventKind),
      notification: schemas_exports.lazyObject(async () => (await Promise.resolve().then(() => (init_serialization(), serialization_exports))).identity.GlobalEventNotification).optional()
    });
  }
});

// src/serialization/resources/identity/resources/common/types/GlobalEventKind.ts
var GlobalEventKind;
var init_GlobalEventKind = __esm({
  "src/serialization/resources/identity/resources/common/types/GlobalEventKind.ts"() {
    "use strict";
    init_core();
    GlobalEventKind = schemas_exports.object({
      identityUpdate: schemas_exports.property(
        "identity_update",
        schemas_exports.lazyObject(async () => (await Promise.resolve().then(() => (init_serialization(), serialization_exports))).identity.GlobalEventIdentityUpdate).optional()
      ),
      matchmakerLobbyJoin: schemas_exports.property(
        "matchmaker_lobby_join",
        schemas_exports.lazyObject(async () => (await Promise.resolve().then(() => (init_serialization(), serialization_exports))).identity.GlobalEventMatchmakerLobbyJoin).optional()
      )
    });
  }
});

// src/serialization/resources/identity/resources/common/types/GlobalEventNotification.ts
var GlobalEventNotification;
var init_GlobalEventNotification = __esm({
  "src/serialization/resources/identity/resources/common/types/GlobalEventNotification.ts"() {
    "use strict";
    init_core();
    GlobalEventNotification = schemas_exports.object({
      title: schemas_exports.string(),
      description: schemas_exports.string(),
      thumbnailUrl: schemas_exports.property("thumbnail_url", schemas_exports.string()),
      url: schemas_exports.string()
    });
  }
});

// src/serialization/resources/identity/resources/common/types/GlobalEventIdentityUpdate.ts
var GlobalEventIdentityUpdate;
var init_GlobalEventIdentityUpdate = __esm({
  "src/serialization/resources/identity/resources/common/types/GlobalEventIdentityUpdate.ts"() {
    "use strict";
    init_core();
    GlobalEventIdentityUpdate = schemas_exports.object({
      identity: schemas_exports.lazyObject(async () => (await Promise.resolve().then(() => (init_serialization(), serialization_exports))).identity.Profile)
    });
  }
});

// src/serialization/resources/identity/resources/common/types/GlobalEventMatchmakerLobbyJoin.ts
var GlobalEventMatchmakerLobbyJoin;
var init_GlobalEventMatchmakerLobbyJoin = __esm({
  "src/serialization/resources/identity/resources/common/types/GlobalEventMatchmakerLobbyJoin.ts"() {
    "use strict";
    init_core();
    GlobalEventMatchmakerLobbyJoin = schemas_exports.object({
      lobby: schemas_exports.lazyObject(async () => (await Promise.resolve().then(() => (init_serialization(), serialization_exports))).matchmaker.JoinLobby),
      ports: schemas_exports.record(
        schemas_exports.string(),
        schemas_exports.lazyObject(async () => (await Promise.resolve().then(() => (init_serialization(), serialization_exports))).matchmaker.JoinPort)
      ),
      player: schemas_exports.lazyObject(async () => (await Promise.resolve().then(() => (init_serialization(), serialization_exports))).matchmaker.JoinPlayer)
    });
  }
});

// src/serialization/resources/identity/resources/common/types/UpdateGameActivity.ts
var UpdateGameActivity;
var init_UpdateGameActivity = __esm({
  "src/serialization/resources/identity/resources/common/types/UpdateGameActivity.ts"() {
    "use strict";
    init_core();
    UpdateGameActivity = schemas_exports.object({
      message: schemas_exports.string().optional(),
      publicMetadata: schemas_exports.property("public_metadata", schemas_exports.unknown().optional()),
      mutualMetadata: schemas_exports.property("mutual_metadata", schemas_exports.unknown().optional())
    });
  }
});

// src/serialization/resources/identity/resources/common/types/Handle.ts
var Handle2;
var init_Handle2 = __esm({
  "src/serialization/resources/identity/resources/common/types/Handle.ts"() {
    "use strict";
    init_core();
    Handle2 = schemas_exports.object({
      identityId: schemas_exports.property("identity_id", schemas_exports.string()),
      displayName: schemas_exports.property(
        "display_name",
        schemas_exports.lazy(async () => (await Promise.resolve().then(() => (init_serialization(), serialization_exports))).DisplayName)
      ),
      accountNumber: schemas_exports.property(
        "account_number",
        schemas_exports.lazy(async () => (await Promise.resolve().then(() => (init_serialization(), serialization_exports))).AccountNumber)
      ),
      avatarUrl: schemas_exports.property("avatar_url", schemas_exports.string()),
      presence: schemas_exports.lazyObject(async () => (await Promise.resolve().then(() => (init_serialization(), serialization_exports))).identity.Presence).optional(),
      isRegistered: schemas_exports.property("is_registered", schemas_exports.boolean()),
      external: schemas_exports.lazyObject(async () => (await Promise.resolve().then(() => (init_serialization(), serialization_exports))).identity.ExternalLinks)
    });
  }
});

// src/serialization/resources/identity/resources/common/types/Summary.ts
var Summary3;
var init_Summary3 = __esm({
  "src/serialization/resources/identity/resources/common/types/Summary.ts"() {
    "use strict";
    init_core();
    Summary3 = schemas_exports.object({
      identityId: schemas_exports.property("identity_id", schemas_exports.string()),
      displayName: schemas_exports.property(
        "display_name",
        schemas_exports.lazy(async () => (await Promise.resolve().then(() => (init_serialization(), serialization_exports))).DisplayName)
      ),
      accountNumber: schemas_exports.property(
        "account_number",
        schemas_exports.lazy(async () => (await Promise.resolve().then(() => (init_serialization(), serialization_exports))).AccountNumber)
      ),
      avatarUrl: schemas_exports.property("avatar_url", schemas_exports.string()),
      presence: schemas_exports.lazyObject(async () => (await Promise.resolve().then(() => (init_serialization(), serialization_exports))).identity.Presence).optional(),
      isRegistered: schemas_exports.property("is_registered", schemas_exports.boolean()),
      external: schemas_exports.lazyObject(async () => (await Promise.resolve().then(() => (init_serialization(), serialization_exports))).identity.ExternalLinks),
      following: schemas_exports.boolean(),
      isFollowingMe: schemas_exports.property("is_following_me", schemas_exports.boolean()),
      isMutualFollowing: schemas_exports.property("is_mutual_following", schemas_exports.boolean())
    });
  }
});

// src/serialization/resources/identity/resources/common/types/Profile.ts
var Profile2;
var init_Profile2 = __esm({
  "src/serialization/resources/identity/resources/common/types/Profile.ts"() {
    "use strict";
    init_core();
    Profile2 = schemas_exports.object({
      identityId: schemas_exports.property("identity_id", schemas_exports.string()),
      displayName: schemas_exports.property(
        "display_name",
        schemas_exports.lazy(async () => (await Promise.resolve().then(() => (init_serialization(), serialization_exports))).DisplayName)
      ),
      accountNumber: schemas_exports.property(
        "account_number",
        schemas_exports.lazy(async () => (await Promise.resolve().then(() => (init_serialization(), serialization_exports))).AccountNumber)
      ),
      avatarUrl: schemas_exports.property("avatar_url", schemas_exports.string()),
      presence: schemas_exports.lazyObject(async () => (await Promise.resolve().then(() => (init_serialization(), serialization_exports))).identity.Presence).optional(),
      isRegistered: schemas_exports.property("is_registered", schemas_exports.boolean()),
      external: schemas_exports.lazyObject(async () => (await Promise.resolve().then(() => (init_serialization(), serialization_exports))).identity.ExternalLinks),
      isAdmin: schemas_exports.property("is_admin", schemas_exports.boolean()),
      isGameLinked: schemas_exports.property("is_game_linked", schemas_exports.boolean().optional()),
      devState: schemas_exports.property(
        "dev_state",
        schemas_exports.lazy(async () => (await Promise.resolve().then(() => (init_serialization(), serialization_exports))).identity.DevState).optional()
      ),
      followerCount: schemas_exports.property("follower_count", schemas_exports.number()),
      followingCount: schemas_exports.property("following_count", schemas_exports.number()),
      following: schemas_exports.boolean(),
      isFollowingMe: schemas_exports.property("is_following_me", schemas_exports.boolean()),
      isMutualFollowing: schemas_exports.property("is_mutual_following", schemas_exports.boolean()),
      joinTs: schemas_exports.property("join_ts", schemas_exports.date()),
      bio: schemas_exports.lazy(async () => (await Promise.resolve().then(() => (init_serialization(), serialization_exports))).Bio),
      linkedAccounts: schemas_exports.property(
        "linked_accounts",
        schemas_exports.list(
          schemas_exports.lazyObject(async () => (await Promise.resolve().then(() => (init_serialization(), serialization_exports))).identity.LinkedAccount)
        )
      ),
      groups: schemas_exports.list(
        schemas_exports.lazyObject(async () => (await Promise.resolve().then(() => (init_serialization(), serialization_exports))).identity.Group)
      ),
      games: schemas_exports.list(
        schemas_exports.lazyObject(async () => (await Promise.resolve().then(() => (init_serialization(), serialization_exports))).game.StatSummary)
      ),
      awaitingDeletion: schemas_exports.property("awaiting_deletion", schemas_exports.boolean().optional())
    });
  }
});

// src/serialization/resources/identity/resources/common/types/ExternalLinks.ts
var ExternalLinks2;
var init_ExternalLinks2 = __esm({
  "src/serialization/resources/identity/resources/common/types/ExternalLinks.ts"() {
    "use strict";
    init_core();
    ExternalLinks2 = schemas_exports.object({
      profile: schemas_exports.string(),
      settings: schemas_exports.string().optional()
    });
  }
});

// src/serialization/resources/identity/resources/common/types/Presence.ts
var Presence;
var init_Presence = __esm({
  "src/serialization/resources/identity/resources/common/types/Presence.ts"() {
    "use strict";
    init_core();
    Presence = schemas_exports.object({
      updateTs: schemas_exports.property("update_ts", schemas_exports.date()),
      status: schemas_exports.lazy(async () => (await Promise.resolve().then(() => (init_serialization(), serialization_exports))).identity.Status),
      gameActivity: schemas_exports.property(
        "game_activity",
        schemas_exports.lazyObject(async () => (await Promise.resolve().then(() => (init_serialization(), serialization_exports))).identity.GameActivity).optional()
      )
    });
  }
});

// src/serialization/resources/identity/resources/common/types/Status.ts
var Status2;
var init_Status = __esm({
  "src/serialization/resources/identity/resources/common/types/Status.ts"() {
    "use strict";
    init_core();
    Status2 = schemas_exports.enum_(["online", "away", "offline"]);
  }
});

// src/serialization/resources/identity/resources/common/types/GameActivity.ts
var GameActivity;
var init_GameActivity = __esm({
  "src/serialization/resources/identity/resources/common/types/GameActivity.ts"() {
    "use strict";
    init_core();
    GameActivity = schemas_exports.object({
      game: schemas_exports.lazyObject(async () => (await Promise.resolve().then(() => (init_serialization(), serialization_exports))).game.Handle),
      message: schemas_exports.string(),
      publicMetadata: schemas_exports.property("public_metadata", schemas_exports.unknown().optional()),
      mutualMetadata: schemas_exports.property("mutual_metadata", schemas_exports.unknown().optional())
    });
  }
});

// src/serialization/resources/identity/resources/common/types/Group.ts
var Group;
var init_Group = __esm({
  "src/serialization/resources/identity/resources/common/types/Group.ts"() {
    "use strict";
    init_core();
    Group = schemas_exports.object({
      group: schemas_exports.lazyObject(async () => (await Promise.resolve().then(() => (init_serialization(), serialization_exports))).group.Handle)
    });
  }
});

// src/serialization/resources/identity/resources/common/types/LinkedAccount.ts
var LinkedAccount;
var init_LinkedAccount = __esm({
  "src/serialization/resources/identity/resources/common/types/LinkedAccount.ts"() {
    "use strict";
    init_core();
    LinkedAccount = schemas_exports.object({
      email: schemas_exports.lazyObject(async () => (await Promise.resolve().then(() => (init_serialization(), serialization_exports))).identity.EmailLinkedAccount).optional(),
      accessToken: schemas_exports.property(
        "access_token",
        schemas_exports.lazyObject(async () => (await Promise.resolve().then(() => (init_serialization(), serialization_exports))).identity.AccessTokenLinkedAccount).optional()
      )
    });
  }
});

// src/serialization/resources/identity/resources/common/types/EmailLinkedAccount.ts
var EmailLinkedAccount;
var init_EmailLinkedAccount = __esm({
  "src/serialization/resources/identity/resources/common/types/EmailLinkedAccount.ts"() {
    "use strict";
    init_core();
    EmailLinkedAccount = schemas_exports.object({
      email: schemas_exports.lazy(async () => (await Promise.resolve().then(() => (init_serialization(), serialization_exports))).Email)
    });
  }
});

// src/serialization/resources/identity/resources/common/types/AccessTokenLinkedAccount.ts
var AccessTokenLinkedAccount;
var init_AccessTokenLinkedAccount = __esm({
  "src/serialization/resources/identity/resources/common/types/AccessTokenLinkedAccount.ts"() {
    "use strict";
    init_core();
    AccessTokenLinkedAccount = schemas_exports.object({
      name: schemas_exports.string()
    });
  }
});

// src/serialization/resources/identity/resources/common/types/DevState.ts
var DevState2;
var init_DevState = __esm({
  "src/serialization/resources/identity/resources/common/types/DevState.ts"() {
    "use strict";
    init_core();
    DevState2 = schemas_exports.enum_(["inactive", "pending", "accepted"]);
  }
});

// src/serialization/resources/identity/resources/common/types/GameLinkStatus.ts
var GameLinkStatus2;
var init_GameLinkStatus = __esm({
  "src/serialization/resources/identity/resources/common/types/GameLinkStatus.ts"() {
    "use strict";
    init_core();
    GameLinkStatus2 = schemas_exports.enum_(["incomplete", "complete", "cancelled"]);
  }
});

// src/serialization/resources/identity/resources/common/types/index.ts
var init_types37 = __esm({
  "src/serialization/resources/identity/resources/common/types/index.ts"() {
    "use strict";
    init_GlobalEvent();
    init_GlobalEventKind();
    init_GlobalEventNotification();
    init_GlobalEventIdentityUpdate();
    init_GlobalEventMatchmakerLobbyJoin();
    init_UpdateGameActivity();
    init_Handle2();
    init_Summary3();
    init_Profile2();
    init_ExternalLinks2();
    init_Presence();
    init_Status();
    init_GameActivity();
    init_Group();
    init_LinkedAccount();
    init_EmailLinkedAccount();
    init_AccessTokenLinkedAccount();
    init_DevState();
    init_GameLinkStatus();
  }
});

// src/serialization/resources/identity/resources/common/index.ts
var common_exports14 = {};
__export(common_exports14, {
  AccessTokenLinkedAccount: () => AccessTokenLinkedAccount,
  DevState: () => DevState2,
  EmailLinkedAccount: () => EmailLinkedAccount,
  ExternalLinks: () => ExternalLinks2,
  GameActivity: () => GameActivity,
  GameLinkStatus: () => GameLinkStatus2,
  GlobalEvent: () => GlobalEvent,
  GlobalEventIdentityUpdate: () => GlobalEventIdentityUpdate,
  GlobalEventKind: () => GlobalEventKind,
  GlobalEventMatchmakerLobbyJoin: () => GlobalEventMatchmakerLobbyJoin,
  GlobalEventNotification: () => GlobalEventNotification,
  Group: () => Group,
  Handle: () => Handle2,
  LinkedAccount: () => LinkedAccount,
  Presence: () => Presence,
  Profile: () => Profile2,
  Status: () => Status2,
  Summary: () => Summary3,
  UpdateGameActivity: () => UpdateGameActivity
});
var init_common4 = __esm({
  "src/serialization/resources/identity/resources/common/index.ts"() {
    "use strict";
    init_types37();
  }
});

// src/serialization/resources/identity/resources/events/types/WatchEventsResponse.ts
var WatchEventsResponse;
var init_WatchEventsResponse = __esm({
  "src/serialization/resources/identity/resources/events/types/WatchEventsResponse.ts"() {
    "use strict";
    init_core();
    WatchEventsResponse = schemas_exports.object({
      events: schemas_exports.list(
        schemas_exports.lazyObject(async () => (await Promise.resolve().then(() => (init_serialization(), serialization_exports))).identity.GlobalEvent)
      ),
      watch: schemas_exports.lazyObject(async () => (await Promise.resolve().then(() => (init_serialization(), serialization_exports))).WatchResponse)
    });
  }
});

// src/serialization/resources/identity/resources/events/types/index.ts
var init_types38 = __esm({
  "src/serialization/resources/identity/resources/events/types/index.ts"() {
    "use strict";
    init_WatchEventsResponse();
  }
});

// src/serialization/resources/identity/resources/events/index.ts
var events_exports2 = {};
__export(events_exports2, {
  WatchEventsResponse: () => WatchEventsResponse
});
var init_events = __esm({
  "src/serialization/resources/identity/resources/events/index.ts"() {
    "use strict";
    init_types38();
  }
});

// src/serialization/resources/identity/resources/links/types/PrepareGameLinkResponse.ts
var PrepareGameLinkResponse;
var init_PrepareGameLinkResponse = __esm({
  "src/serialization/resources/identity/resources/links/types/PrepareGameLinkResponse.ts"() {
    "use strict";
    init_core();
    PrepareGameLinkResponse = schemas_exports.object({
      identityLinkToken: schemas_exports.property("identity_link_token", schemas_exports.string()),
      identityLinkUrl: schemas_exports.property("identity_link_url", schemas_exports.string()),
      expireTs: schemas_exports.property("expire_ts", schemas_exports.date())
    });
  }
});

// src/serialization/resources/identity/resources/links/types/GetGameLinkResponse.ts
var GetGameLinkResponse;
var init_GetGameLinkResponse = __esm({
  "src/serialization/resources/identity/resources/links/types/GetGameLinkResponse.ts"() {
    "use strict";
    init_core();
    GetGameLinkResponse = schemas_exports.object({
      status: schemas_exports.lazy(async () => (await Promise.resolve().then(() => (init_serialization(), serialization_exports))).identity.GameLinkStatus),
      game: schemas_exports.lazyObject(async () => (await Promise.resolve().then(() => (init_serialization(), serialization_exports))).game.Handle),
      currentIdentity: schemas_exports.property(
        "current_identity",
        schemas_exports.lazyObject(async () => (await Promise.resolve().then(() => (init_serialization(), serialization_exports))).identity.Handle)
      ),
      newIdentity: schemas_exports.property(
        "new_identity",
        schemas_exports.lazyObject(async () => (await Promise.resolve().then(() => (init_serialization(), serialization_exports))).identity.GetGameLinkNewIdentity).optional()
      ),
      watch: schemas_exports.lazyObject(async () => (await Promise.resolve().then(() => (init_serialization(), serialization_exports))).WatchResponse)
    });
  }
});

// src/serialization/resources/identity/resources/links/types/GetGameLinkNewIdentity.ts
var GetGameLinkNewIdentity;
var init_GetGameLinkNewIdentity = __esm({
  "src/serialization/resources/identity/resources/links/types/GetGameLinkNewIdentity.ts"() {
    "use strict";
    init_core();
    GetGameLinkNewIdentity = schemas_exports.object({
      identityToken: schemas_exports.property(
        "identity_token",
        schemas_exports.lazy(async () => (await Promise.resolve().then(() => (init_serialization(), serialization_exports))).Jwt)
      ),
      identityTokenExpireTs: schemas_exports.property("identity_token_expire_ts", schemas_exports.date()),
      identity: schemas_exports.lazyObject(async () => (await Promise.resolve().then(() => (init_serialization(), serialization_exports))).identity.Profile)
    });
  }
});

// src/serialization/resources/identity/resources/links/types/index.ts
var init_types39 = __esm({
  "src/serialization/resources/identity/resources/links/types/index.ts"() {
    "use strict";
    init_PrepareGameLinkResponse();
    init_GetGameLinkResponse();
    init_GetGameLinkNewIdentity();
  }
});

// src/serialization/resources/identity/resources/links/index.ts
var links_exports4 = {};
__export(links_exports4, {
  GetGameLinkNewIdentity: () => GetGameLinkNewIdentity,
  GetGameLinkResponse: () => GetGameLinkResponse,
  PrepareGameLinkResponse: () => PrepareGameLinkResponse
});
var init_links2 = __esm({
  "src/serialization/resources/identity/resources/links/index.ts"() {
    "use strict";
    init_types39();
  }
});

// src/serialization/resources/identity/resources/index.ts
var init_resources10 = __esm({
  "src/serialization/resources/identity/resources/index.ts"() {
    "use strict";
    init_common4();
    init_types37();
    init_events();
    init_types38();
    init_links2();
    init_types39();
  }
});

// src/serialization/resources/identity/client/requests/SetupRequest.ts
var SetupRequest;
var init_SetupRequest = __esm({
  "src/serialization/resources/identity/client/requests/SetupRequest.ts"() {
    "use strict";
    init_core();
    SetupRequest = schemas_exports.object({
      existingIdentityToken: schemas_exports.property(
        "existing_identity_token",
        schemas_exports.lazy(async () => (await Promise.resolve().then(() => (init_serialization(), serialization_exports))).Jwt).optional()
      )
    });
  }
});

// src/serialization/resources/identity/client/requests/UpdateProfileRequest.ts
var UpdateProfileRequest2;
var init_UpdateProfileRequest2 = __esm({
  "src/serialization/resources/identity/client/requests/UpdateProfileRequest.ts"() {
    "use strict";
    init_core();
    UpdateProfileRequest2 = schemas_exports.object({
      displayName: schemas_exports.property(
        "display_name",
        schemas_exports.lazy(async () => (await Promise.resolve().then(() => (init_serialization(), serialization_exports))).DisplayName).optional()
      ),
      accountNumber: schemas_exports.property(
        "account_number",
        schemas_exports.lazy(async () => (await Promise.resolve().then(() => (init_serialization(), serialization_exports))).AccountNumber).optional()
      ),
      bio: schemas_exports.lazy(async () => (await Promise.resolve().then(() => (init_serialization(), serialization_exports))).Bio).optional()
    });
  }
});

// src/serialization/resources/identity/client/requests/ValidateProfileRequest.ts
var ValidateProfileRequest2;
var init_ValidateProfileRequest2 = __esm({
  "src/serialization/resources/identity/client/requests/ValidateProfileRequest.ts"() {
    "use strict";
    init_core();
    ValidateProfileRequest2 = schemas_exports.object({
      displayName: schemas_exports.property(
        "display_name",
        schemas_exports.lazy(async () => (await Promise.resolve().then(() => (init_serialization(), serialization_exports))).DisplayName).optional()
      ),
      accountNumber: schemas_exports.property(
        "account_number",
        schemas_exports.lazy(async () => (await Promise.resolve().then(() => (init_serialization(), serialization_exports))).AccountNumber).optional()
      ),
      bio: schemas_exports.lazy(async () => (await Promise.resolve().then(() => (init_serialization(), serialization_exports))).Bio).optional()
    });
  }
});

// src/serialization/resources/identity/client/requests/SetGameActivityRequest.ts
var SetGameActivityRequest;
var init_SetGameActivityRequest = __esm({
  "src/serialization/resources/identity/client/requests/SetGameActivityRequest.ts"() {
    "use strict";
    init_core();
    SetGameActivityRequest = schemas_exports.object({
      gameActivity: schemas_exports.property(
        "game_activity",
        schemas_exports.lazyObject(async () => (await Promise.resolve().then(() => (init_serialization(), serialization_exports))).identity.UpdateGameActivity)
      )
    });
  }
});

// src/serialization/resources/identity/client/requests/UpdateStatusRequest.ts
var UpdateStatusRequest;
var init_UpdateStatusRequest = __esm({
  "src/serialization/resources/identity/client/requests/UpdateStatusRequest.ts"() {
    "use strict";
    init_core();
    UpdateStatusRequest = schemas_exports.object({
      status: schemas_exports.lazy(async () => (await Promise.resolve().then(() => (init_serialization(), serialization_exports))).identity.Status)
    });
  }
});

// src/serialization/resources/identity/client/requests/PrepareAvatarUploadRequest.ts
var PrepareAvatarUploadRequest2;
var init_PrepareAvatarUploadRequest2 = __esm({
  "src/serialization/resources/identity/client/requests/PrepareAvatarUploadRequest.ts"() {
    "use strict";
    init_core();
    PrepareAvatarUploadRequest2 = schemas_exports.object({
      path: schemas_exports.string(),
      mime: schemas_exports.string(),
      contentLength: schemas_exports.property("content_length", schemas_exports.number())
    });
  }
});

// src/serialization/resources/identity/client/requests/SignupForBetaRequest.ts
var SignupForBetaRequest;
var init_SignupForBetaRequest = __esm({
  "src/serialization/resources/identity/client/requests/SignupForBetaRequest.ts"() {
    "use strict";
    init_core();
    SignupForBetaRequest = schemas_exports.object({
      name: schemas_exports.string(),
      companyName: schemas_exports.property("company_name", schemas_exports.string().optional()),
      companySize: schemas_exports.property("company_size", schemas_exports.string()),
      preferredTools: schemas_exports.property("preferred_tools", schemas_exports.string()),
      goals: schemas_exports.string()
    });
  }
});

// src/serialization/resources/identity/client/requests/ReportRequest.ts
var ReportRequest;
var init_ReportRequest = __esm({
  "src/serialization/resources/identity/client/requests/ReportRequest.ts"() {
    "use strict";
    init_core();
    ReportRequest = schemas_exports.object({
      reason: schemas_exports.string().optional()
    });
  }
});

// src/serialization/resources/identity/client/requests/index.ts
var init_requests = __esm({
  "src/serialization/resources/identity/client/requests/index.ts"() {
    "use strict";
    init_SetupRequest();
    init_UpdateProfileRequest2();
    init_ValidateProfileRequest2();
    init_SetGameActivityRequest();
    init_UpdateStatusRequest();
    init_PrepareAvatarUploadRequest2();
    init_SignupForBetaRequest();
    init_ReportRequest();
  }
});

// src/serialization/resources/identity/client/index.ts
var init_client = __esm({
  "src/serialization/resources/identity/client/index.ts"() {
    "use strict";
    init_requests();
  }
});

// src/serialization/resources/identity/index.ts
var identity_exports4 = {};
__export(identity_exports4, {
  AccessTokenLinkedAccount: () => AccessTokenLinkedAccount,
  DevState: () => DevState2,
  EmailLinkedAccount: () => EmailLinkedAccount,
  ExternalLinks: () => ExternalLinks2,
  GameActivity: () => GameActivity,
  GameLinkStatus: () => GameLinkStatus2,
  GetGameLinkNewIdentity: () => GetGameLinkNewIdentity,
  GetGameLinkResponse: () => GetGameLinkResponse,
  GetHandlesResponse: () => GetHandlesResponse,
  GetProfileResponse: () => GetProfileResponse2,
  GetSummariesResponse: () => GetSummariesResponse,
  GlobalEvent: () => GlobalEvent,
  GlobalEventIdentityUpdate: () => GlobalEventIdentityUpdate,
  GlobalEventKind: () => GlobalEventKind,
  GlobalEventMatchmakerLobbyJoin: () => GlobalEventMatchmakerLobbyJoin,
  GlobalEventNotification: () => GlobalEventNotification,
  Group: () => Group,
  Handle: () => Handle2,
  LinkedAccount: () => LinkedAccount,
  ListFollowersResponse: () => ListFollowersResponse,
  ListFollowingResponse: () => ListFollowingResponse,
  ListFriendsResponse: () => ListFriendsResponse,
  ListMutualFriendsResponse: () => ListMutualFriendsResponse,
  ListRecentFollowersResponse: () => ListRecentFollowersResponse,
  PrepareAvatarUploadRequest: () => PrepareAvatarUploadRequest2,
  PrepareAvatarUploadResponse: () => PrepareAvatarUploadResponse2,
  PrepareGameLinkResponse: () => PrepareGameLinkResponse,
  Presence: () => Presence,
  Profile: () => Profile2,
  ReportRequest: () => ReportRequest,
  SearchResponse: () => SearchResponse2,
  SetGameActivityRequest: () => SetGameActivityRequest,
  SetupRequest: () => SetupRequest,
  SetupResponse: () => SetupResponse,
  SignupForBetaRequest: () => SignupForBetaRequest,
  Status: () => Status2,
  Summary: () => Summary3,
  UpdateGameActivity: () => UpdateGameActivity,
  UpdateProfileRequest: () => UpdateProfileRequest2,
  UpdateStatusRequest: () => UpdateStatusRequest,
  ValidateProfileRequest: () => ValidateProfileRequest2,
  WatchEventsResponse: () => WatchEventsResponse,
  common: () => common_exports14,
  events: () => events_exports2,
  links: () => links_exports4
});
var init_identity2 = __esm({
  "src/serialization/resources/identity/index.ts"() {
    "use strict";
    init_types36();
    init_resources10();
    init_client();
  }
});

// src/serialization/resources/kv/types/GetResponse.ts
var GetResponse;
var init_GetResponse = __esm({
  "src/serialization/resources/kv/types/GetResponse.ts"() {
    "use strict";
    init_core();
    GetResponse = schemas_exports.object({
      value: schemas_exports.lazy(async () => (await Promise.resolve().then(() => (init_serialization(), serialization_exports))).kv.Value),
      deleted: schemas_exports.boolean().optional(),
      watch: schemas_exports.lazyObject(async () => (await Promise.resolve().then(() => (init_serialization(), serialization_exports))).WatchResponse)
    });
  }
});

// src/serialization/resources/kv/types/PutRequest.ts
var PutRequest;
var init_PutRequest = __esm({
  "src/serialization/resources/kv/types/PutRequest.ts"() {
    "use strict";
    init_core();
    PutRequest = schemas_exports.object({
      namespaceId: schemas_exports.property("namespace_id", schemas_exports.string().optional()),
      key: schemas_exports.lazy(async () => (await Promise.resolve().then(() => (init_serialization(), serialization_exports))).kv.Key),
      value: schemas_exports.lazy(async () => (await Promise.resolve().then(() => (init_serialization(), serialization_exports))).kv.Value)
    });
  }
});

// src/serialization/resources/kv/types/GetBatchResponse.ts
var GetBatchResponse;
var init_GetBatchResponse = __esm({
  "src/serialization/resources/kv/types/GetBatchResponse.ts"() {
    "use strict";
    init_core();
    GetBatchResponse = schemas_exports.object({
      entries: schemas_exports.list(schemas_exports.lazyObject(async () => (await Promise.resolve().then(() => (init_serialization(), serialization_exports))).kv.Entry)),
      watch: schemas_exports.lazyObject(async () => (await Promise.resolve().then(() => (init_serialization(), serialization_exports))).WatchResponse)
    });
  }
});

// src/serialization/resources/kv/types/PutBatchRequest.ts
var PutBatchRequest;
var init_PutBatchRequest = __esm({
  "src/serialization/resources/kv/types/PutBatchRequest.ts"() {
    "use strict";
    init_core();
    PutBatchRequest = schemas_exports.object({
      namespaceId: schemas_exports.property("namespace_id", schemas_exports.string().optional()),
      entries: schemas_exports.list(schemas_exports.lazyObject(async () => (await Promise.resolve().then(() => (init_serialization(), serialization_exports))).kv.PutEntry))
    });
  }
});

// src/serialization/resources/kv/types/index.ts
var init_types40 = __esm({
  "src/serialization/resources/kv/types/index.ts"() {
    "use strict";
    init_GetResponse();
    init_PutRequest();
    init_GetBatchResponse();
    init_PutBatchRequest();
  }
});

// src/serialization/resources/kv/resources/common/types/Key.ts
var Key;
var init_Key = __esm({
  "src/serialization/resources/kv/resources/common/types/Key.ts"() {
    "use strict";
    init_core();
    Key = schemas_exports.string();
  }
});

// src/serialization/resources/kv/resources/common/types/Value.ts
var Value;
var init_Value = __esm({
  "src/serialization/resources/kv/resources/common/types/Value.ts"() {
    "use strict";
    init_core();
    Value = schemas_exports.unknown();
  }
});

// src/serialization/resources/kv/resources/common/types/Entry.ts
var Entry;
var init_Entry = __esm({
  "src/serialization/resources/kv/resources/common/types/Entry.ts"() {
    "use strict";
    init_core();
    Entry = schemas_exports.object({
      key: schemas_exports.lazy(async () => (await Promise.resolve().then(() => (init_serialization(), serialization_exports))).kv.Key),
      value: schemas_exports.lazy(async () => (await Promise.resolve().then(() => (init_serialization(), serialization_exports))).kv.Value),
      deleted: schemas_exports.boolean().optional()
    });
  }
});

// src/serialization/resources/kv/resources/common/types/PutEntry.ts
var PutEntry;
var init_PutEntry = __esm({
  "src/serialization/resources/kv/resources/common/types/PutEntry.ts"() {
    "use strict";
    init_core();
    PutEntry = schemas_exports.object({
      key: schemas_exports.lazy(async () => (await Promise.resolve().then(() => (init_serialization(), serialization_exports))).kv.Key),
      value: schemas_exports.lazy(async () => (await Promise.resolve().then(() => (init_serialization(), serialization_exports))).kv.Value)
    });
  }
});

// src/serialization/resources/kv/resources/common/types/index.ts
var init_types41 = __esm({
  "src/serialization/resources/kv/resources/common/types/index.ts"() {
    "use strict";
    init_Key();
    init_Value();
    init_Entry();
    init_PutEntry();
  }
});

// src/serialization/resources/kv/resources/common/index.ts
var common_exports15 = {};
__export(common_exports15, {
  Entry: () => Entry,
  Key: () => Key,
  PutEntry: () => PutEntry,
  Value: () => Value
});
var init_common5 = __esm({
  "src/serialization/resources/kv/resources/common/index.ts"() {
    "use strict";
    init_types41();
  }
});

// src/serialization/resources/kv/resources/index.ts
var init_resources11 = __esm({
  "src/serialization/resources/kv/resources/index.ts"() {
    "use strict";
    init_common5();
    init_types41();
  }
});

// src/serialization/resources/kv/index.ts
var kv_exports4 = {};
__export(kv_exports4, {
  Entry: () => Entry,
  GetBatchResponse: () => GetBatchResponse,
  GetResponse: () => GetResponse,
  Key: () => Key,
  PutBatchRequest: () => PutBatchRequest,
  PutEntry: () => PutEntry,
  PutRequest: () => PutRequest,
  Value: () => Value,
  common: () => common_exports15
});
var init_kv2 = __esm({
  "src/serialization/resources/kv/index.ts"() {
    "use strict";
    init_types40();
    init_resources11();
  }
});

// src/serialization/resources/module/types/CallResponse.ts
var CallResponse;
var init_CallResponse = __esm({
  "src/serialization/resources/module/types/CallResponse.ts"() {
    "use strict";
    init_core();
    CallResponse = schemas_exports.object({
      data: schemas_exports.unknown()
    });
  }
});

// src/serialization/resources/module/types/index.ts
var init_types42 = __esm({
  "src/serialization/resources/module/types/index.ts"() {
    "use strict";
    init_CallResponse();
  }
});

// src/serialization/resources/module/client/requests/FindLobbyRequest.ts
var FindLobbyRequest;
var init_FindLobbyRequest = __esm({
  "src/serialization/resources/module/client/requests/FindLobbyRequest.ts"() {
    "use strict";
    init_core();
    FindLobbyRequest = schemas_exports.object({
      namespaceId: schemas_exports.property("namespace_id", schemas_exports.string().optional()),
      data: schemas_exports.unknown()
    });
  }
});

// src/serialization/resources/module/client/requests/index.ts
var init_requests2 = __esm({
  "src/serialization/resources/module/client/requests/index.ts"() {
    "use strict";
    init_FindLobbyRequest();
  }
});

// src/serialization/resources/module/client/index.ts
var init_client2 = __esm({
  "src/serialization/resources/module/client/index.ts"() {
    "use strict";
    init_requests2();
  }
});

// src/serialization/resources/module/index.ts
var module_exports2 = {};
__export(module_exports2, {
  CallResponse: () => CallResponse,
  FindLobbyRequest: () => FindLobbyRequest
});
var init_module = __esm({
  "src/serialization/resources/module/index.ts"() {
    "use strict";
    init_types42();
    init_client2();
  }
});

// src/serialization/resources/captcha/resources/config/types/Config.ts
var Config7;
var init_Config7 = __esm({
  "src/serialization/resources/captcha/resources/config/types/Config.ts"() {
    "use strict";
    init_core();
    Config7 = schemas_exports.object({
      hcaptcha: schemas_exports.lazyObject(async () => (await Promise.resolve().then(() => (init_serialization(), serialization_exports))).captcha.ConfigHcaptcha).optional(),
      turnstile: schemas_exports.lazyObject(async () => (await Promise.resolve().then(() => (init_serialization(), serialization_exports))).captcha.ConfigTurnstile).optional()
    });
  }
});

// src/serialization/resources/captcha/resources/config/types/ConfigHcaptcha.ts
var ConfigHcaptcha;
var init_ConfigHcaptcha = __esm({
  "src/serialization/resources/captcha/resources/config/types/ConfigHcaptcha.ts"() {
    "use strict";
    init_core();
    ConfigHcaptcha = schemas_exports.object({
      clientResponse: schemas_exports.property("client_response", schemas_exports.string())
    });
  }
});

// src/serialization/resources/captcha/resources/config/types/ConfigTurnstile.ts
var ConfigTurnstile;
var init_ConfigTurnstile = __esm({
  "src/serialization/resources/captcha/resources/config/types/ConfigTurnstile.ts"() {
    "use strict";
    init_core();
    ConfigTurnstile = schemas_exports.object({
      clientResponse: schemas_exports.property("client_response", schemas_exports.string())
    });
  }
});

// src/serialization/resources/captcha/resources/config/types/index.ts
var init_types43 = __esm({
  "src/serialization/resources/captcha/resources/config/types/index.ts"() {
    "use strict";
    init_Config7();
    init_ConfigHcaptcha();
    init_ConfigTurnstile();
  }
});

// src/serialization/resources/captcha/resources/config/index.ts
var config_exports2 = {};
__export(config_exports2, {
  Config: () => Config7,
  ConfigHcaptcha: () => ConfigHcaptcha,
  ConfigTurnstile: () => ConfigTurnstile
});
var init_config = __esm({
  "src/serialization/resources/captcha/resources/config/index.ts"() {
    "use strict";
    init_types43();
  }
});

// src/serialization/resources/captcha/resources/index.ts
var init_resources12 = __esm({
  "src/serialization/resources/captcha/resources/index.ts"() {
    "use strict";
    init_config();
    init_types43();
  }
});

// src/serialization/resources/captcha/index.ts
var captcha_exports2 = {};
__export(captcha_exports2, {
  Config: () => Config7,
  ConfigHcaptcha: () => ConfigHcaptcha,
  ConfigTurnstile: () => ConfigTurnstile,
  config: () => config_exports2
});
var init_captcha = __esm({
  "src/serialization/resources/captcha/index.ts"() {
    "use strict";
    init_resources12();
  }
});

// src/serialization/resources/common/types/Identifier.ts
var Identifier;
var init_Identifier = __esm({
  "src/serialization/resources/common/types/Identifier.ts"() {
    "use strict";
    init_core();
    Identifier = schemas_exports.string();
  }
});

// src/serialization/resources/common/types/Bio.ts
var Bio;
var init_Bio = __esm({
  "src/serialization/resources/common/types/Bio.ts"() {
    "use strict";
    init_core();
    Bio = schemas_exports.string();
  }
});

// src/serialization/resources/common/types/Email.ts
var Email;
var init_Email = __esm({
  "src/serialization/resources/common/types/Email.ts"() {
    "use strict";
    init_core();
    Email = schemas_exports.string();
  }
});

// src/serialization/resources/common/types/Jwt.ts
var Jwt;
var init_Jwt = __esm({
  "src/serialization/resources/common/types/Jwt.ts"() {
    "use strict";
    init_core();
    Jwt = schemas_exports.string();
  }
});

// src/serialization/resources/common/types/WatchQuery.ts
var WatchQuery;
var init_WatchQuery = __esm({
  "src/serialization/resources/common/types/WatchQuery.ts"() {
    "use strict";
    init_core();
    WatchQuery = schemas_exports.string().optional();
  }
});

// src/serialization/resources/common/types/WatchResponse.ts
var WatchResponse;
var init_WatchResponse = __esm({
  "src/serialization/resources/common/types/WatchResponse.ts"() {
    "use strict";
    init_core();
    WatchResponse = schemas_exports.object({
      index: schemas_exports.string()
    });
  }
});

// src/serialization/resources/common/types/DisplayName.ts
var DisplayName;
var init_DisplayName = __esm({
  "src/serialization/resources/common/types/DisplayName.ts"() {
    "use strict";
    init_core();
    DisplayName = schemas_exports.string();
  }
});

// src/serialization/resources/common/types/AccountNumber.ts
var AccountNumber;
var init_AccountNumber = __esm({
  "src/serialization/resources/common/types/AccountNumber.ts"() {
    "use strict";
    init_core();
    AccountNumber = schemas_exports.number();
  }
});

// src/serialization/resources/common/types/ValidationError.ts
var ValidationError5;
var init_ValidationError = __esm({
  "src/serialization/resources/common/types/ValidationError.ts"() {
    "use strict";
    init_core();
    ValidationError5 = schemas_exports.object({
      path: schemas_exports.list(schemas_exports.string())
    });
  }
});

// src/serialization/resources/common/types/EmptyObject.ts
var EmptyObject;
var init_EmptyObject = __esm({
  "src/serialization/resources/common/types/EmptyObject.ts"() {
    "use strict";
    init_core();
    EmptyObject = schemas_exports.object({});
  }
});

// src/serialization/resources/common/types/ErrorMetadata.ts
var ErrorMetadata;
var init_ErrorMetadata = __esm({
  "src/serialization/resources/common/types/ErrorMetadata.ts"() {
    "use strict";
    init_core();
    ErrorMetadata = schemas_exports.unknown();
  }
});

// src/serialization/resources/common/types/ErrorBody.ts
var ErrorBody;
var init_ErrorBody = __esm({
  "src/serialization/resources/common/types/ErrorBody.ts"() {
    "use strict";
    init_core();
    ErrorBody = schemas_exports.object({
      code: schemas_exports.string(),
      message: schemas_exports.string(),
      documentation: schemas_exports.string().optional(),
      metadata: schemas_exports.lazy(async () => (await Promise.resolve().then(() => (init_serialization(), serialization_exports))).ErrorMetadata).optional()
    });
  }
});

// src/serialization/resources/common/types/index.ts
var init_types44 = __esm({
  "src/serialization/resources/common/types/index.ts"() {
    "use strict";
    init_Identifier();
    init_Bio();
    init_Email();
    init_Jwt();
    init_WatchQuery();
    init_WatchResponse();
    init_DisplayName();
    init_AccountNumber();
    init_ValidationError();
    init_EmptyObject();
    init_ErrorMetadata();
    init_ErrorBody();
  }
});

// src/serialization/resources/common/index.ts
var common_exports16 = {};
__export(common_exports16, {
  AccountNumber: () => AccountNumber,
  Bio: () => Bio,
  DisplayName: () => DisplayName,
  Email: () => Email,
  EmptyObject: () => EmptyObject,
  ErrorBody: () => ErrorBody,
  ErrorMetadata: () => ErrorMetadata,
  Identifier: () => Identifier,
  Jwt: () => Jwt,
  ValidationError: () => ValidationError5,
  WatchQuery: () => WatchQuery,
  WatchResponse: () => WatchResponse
});
var init_common6 = __esm({
  "src/serialization/resources/common/index.ts"() {
    "use strict";
    init_types44();
  }
});

// src/serialization/resources/game/resources/common/types/Handle.ts
var Handle3;
var init_Handle3 = __esm({
  "src/serialization/resources/game/resources/common/types/Handle.ts"() {
    "use strict";
    init_core();
    Handle3 = schemas_exports.object({
      gameId: schemas_exports.property("game_id", schemas_exports.string()),
      nameId: schemas_exports.property(
        "name_id",
        schemas_exports.lazy(async () => (await Promise.resolve().then(() => (init_serialization(), serialization_exports))).Identifier)
      ),
      displayName: schemas_exports.property(
        "display_name",
        schemas_exports.lazy(async () => (await Promise.resolve().then(() => (init_serialization(), serialization_exports))).DisplayName)
      ),
      logoUrl: schemas_exports.property("logo_url", schemas_exports.string().optional()),
      bannerUrl: schemas_exports.property("banner_url", schemas_exports.string().optional())
    });
  }
});

// src/serialization/resources/game/resources/common/types/Summary.ts
var Summary4;
var init_Summary4 = __esm({
  "src/serialization/resources/game/resources/common/types/Summary.ts"() {
    "use strict";
    init_core();
    Summary4 = schemas_exports.object({
      gameId: schemas_exports.property("game_id", schemas_exports.string()),
      nameId: schemas_exports.property(
        "name_id",
        schemas_exports.lazy(async () => (await Promise.resolve().then(() => (init_serialization(), serialization_exports))).Identifier)
      ),
      displayName: schemas_exports.property(
        "display_name",
        schemas_exports.lazy(async () => (await Promise.resolve().then(() => (init_serialization(), serialization_exports))).DisplayName)
      ),
      logoUrl: schemas_exports.property("logo_url", schemas_exports.string().optional()),
      bannerUrl: schemas_exports.property("banner_url", schemas_exports.string().optional()),
      url: schemas_exports.string(),
      developer: schemas_exports.lazyObject(async () => (await Promise.resolve().then(() => (init_serialization(), serialization_exports))).group.Handle),
      totalPlayerCount: schemas_exports.property("total_player_count", schemas_exports.number())
    });
  }
});

// src/serialization/resources/game/resources/common/types/StatSummary.ts
var StatSummary;
var init_StatSummary = __esm({
  "src/serialization/resources/game/resources/common/types/StatSummary.ts"() {
    "use strict";
    init_core();
    StatSummary = schemas_exports.object({
      game: schemas_exports.lazyObject(async () => (await Promise.resolve().then(() => (init_serialization(), serialization_exports))).game.Handle),
      stats: schemas_exports.list(
        schemas_exports.lazyObject(async () => (await Promise.resolve().then(() => (init_serialization(), serialization_exports))).game.Stat)
      )
    });
  }
});

// src/serialization/resources/game/resources/common/types/Stat.ts
var Stat;
var init_Stat = __esm({
  "src/serialization/resources/game/resources/common/types/Stat.ts"() {
    "use strict";
    init_core();
    Stat = schemas_exports.object({
      config: schemas_exports.lazyObject(async () => (await Promise.resolve().then(() => (init_serialization(), serialization_exports))).game.StatConfig),
      overallValue: schemas_exports.property("overall_value", schemas_exports.number())
    });
  }
});

// src/serialization/resources/game/resources/common/types/StatConfig.ts
var StatConfig;
var init_StatConfig = __esm({
  "src/serialization/resources/game/resources/common/types/StatConfig.ts"() {
    "use strict";
    init_core();
    StatConfig = schemas_exports.object({
      recordId: schemas_exports.property("record_id", schemas_exports.string()),
      iconId: schemas_exports.property("icon_id", schemas_exports.string()),
      format: schemas_exports.lazy(async () => (await Promise.resolve().then(() => (init_serialization(), serialization_exports))).game.StatFormatMethod),
      aggregation: schemas_exports.lazy(async () => (await Promise.resolve().then(() => (init_serialization(), serialization_exports))).game.StatAggregationMethod),
      sorting: schemas_exports.lazy(async () => (await Promise.resolve().then(() => (init_serialization(), serialization_exports))).game.StatSortingMethod),
      priority: schemas_exports.number(),
      displayName: schemas_exports.property(
        "display_name",
        schemas_exports.lazy(async () => (await Promise.resolve().then(() => (init_serialization(), serialization_exports))).DisplayName)
      ),
      postfixSingular: schemas_exports.property("postfix_singular", schemas_exports.string().optional()),
      postfixPlural: schemas_exports.property("postfix_plural", schemas_exports.string().optional()),
      prefixSingular: schemas_exports.property("prefix_singular", schemas_exports.string().optional()),
      prefixPlural: schemas_exports.property("prefix_plural", schemas_exports.string().optional())
    });
  }
});

// src/serialization/resources/game/resources/common/types/StatFormatMethod.ts
var StatFormatMethod2;
var init_StatFormatMethod = __esm({
  "src/serialization/resources/game/resources/common/types/StatFormatMethod.ts"() {
    "use strict";
    init_core();
    StatFormatMethod2 = schemas_exports.enum_([
      "integer",
      "float_1",
      "float_2",
      "float_3",
      "duration_minute",
      "duration_second",
      "duration_hundredth_second"
    ]);
  }
});

// src/serialization/resources/game/resources/common/types/StatAggregationMethod.ts
var StatAggregationMethod2;
var init_StatAggregationMethod = __esm({
  "src/serialization/resources/game/resources/common/types/StatAggregationMethod.ts"() {
    "use strict";
    init_core();
    StatAggregationMethod2 = schemas_exports.enum_(["sum", "average", "min", "max"]);
  }
});

// src/serialization/resources/game/resources/common/types/StatSortingMethod.ts
var StatSortingMethod2;
var init_StatSortingMethod = __esm({
  "src/serialization/resources/game/resources/common/types/StatSortingMethod.ts"() {
    "use strict";
    init_core();
    StatSortingMethod2 = schemas_exports.enum_(["desc", "asc"]);
  }
});

// src/serialization/resources/game/resources/common/types/index.ts
var init_types45 = __esm({
  "src/serialization/resources/game/resources/common/types/index.ts"() {
    "use strict";
    init_Handle3();
    init_Summary4();
    init_StatSummary();
    init_Stat();
    init_StatConfig();
    init_StatFormatMethod();
    init_StatAggregationMethod();
    init_StatSortingMethod();
  }
});

// src/serialization/resources/game/resources/common/index.ts
var common_exports17 = {};
__export(common_exports17, {
  Handle: () => Handle3,
  Stat: () => Stat,
  StatAggregationMethod: () => StatAggregationMethod2,
  StatConfig: () => StatConfig,
  StatFormatMethod: () => StatFormatMethod2,
  StatSortingMethod: () => StatSortingMethod2,
  StatSummary: () => StatSummary,
  Summary: () => Summary4
});
var init_common7 = __esm({
  "src/serialization/resources/game/resources/common/index.ts"() {
    "use strict";
    init_types45();
  }
});

// src/serialization/resources/game/resources/index.ts
var init_resources13 = __esm({
  "src/serialization/resources/game/resources/index.ts"() {
    "use strict";
    init_common7();
    init_types45();
  }
});

// src/serialization/resources/game/index.ts
var game_exports2 = {};
__export(game_exports2, {
  Handle: () => Handle3,
  Stat: () => Stat,
  StatAggregationMethod: () => StatAggregationMethod2,
  StatConfig: () => StatConfig,
  StatFormatMethod: () => StatFormatMethod2,
  StatSortingMethod: () => StatSortingMethod2,
  StatSummary: () => StatSummary,
  Summary: () => Summary4,
  common: () => common_exports17
});
var init_game = __esm({
  "src/serialization/resources/game/index.ts"() {
    "use strict";
    init_resources13();
  }
});

// src/serialization/resources/geo/resources/common/types/Coord.ts
var Coord;
var init_Coord = __esm({
  "src/serialization/resources/geo/resources/common/types/Coord.ts"() {
    "use strict";
    init_core();
    Coord = schemas_exports.object({
      latitude: schemas_exports.number(),
      longitude: schemas_exports.number()
    });
  }
});

// src/serialization/resources/geo/resources/common/types/Distance.ts
var Distance;
var init_Distance = __esm({
  "src/serialization/resources/geo/resources/common/types/Distance.ts"() {
    "use strict";
    init_core();
    Distance = schemas_exports.object({
      kilometers: schemas_exports.number(),
      miles: schemas_exports.number()
    });
  }
});

// src/serialization/resources/geo/resources/common/types/index.ts
var init_types46 = __esm({
  "src/serialization/resources/geo/resources/common/types/index.ts"() {
    "use strict";
    init_Coord();
    init_Distance();
  }
});

// src/serialization/resources/geo/resources/common/index.ts
var common_exports18 = {};
__export(common_exports18, {
  Coord: () => Coord,
  Distance: () => Distance
});
var init_common8 = __esm({
  "src/serialization/resources/geo/resources/common/index.ts"() {
    "use strict";
    init_types46();
  }
});

// src/serialization/resources/geo/resources/index.ts
var init_resources14 = __esm({
  "src/serialization/resources/geo/resources/index.ts"() {
    "use strict";
    init_common8();
    init_types46();
  }
});

// src/serialization/resources/geo/index.ts
var geo_exports2 = {};
__export(geo_exports2, {
  Coord: () => Coord,
  Distance: () => Distance,
  common: () => common_exports18
});
var init_geo = __esm({
  "src/serialization/resources/geo/index.ts"() {
    "use strict";
    init_resources14();
  }
});

// src/serialization/resources/matchmaker/resources/common/types/LobbyInfo.ts
var LobbyInfo;
var init_LobbyInfo = __esm({
  "src/serialization/resources/matchmaker/resources/common/types/LobbyInfo.ts"() {
    "use strict";
    init_core();
    LobbyInfo = schemas_exports.object({
      regionId: schemas_exports.property("region_id", schemas_exports.string()),
      gameModeId: schemas_exports.property("game_mode_id", schemas_exports.string()),
      lobbyId: schemas_exports.property("lobby_id", schemas_exports.string()),
      maxPlayersNormal: schemas_exports.property("max_players_normal", schemas_exports.number()),
      maxPlayersDirect: schemas_exports.property("max_players_direct", schemas_exports.number()),
      maxPlayersParty: schemas_exports.property("max_players_party", schemas_exports.number()),
      totalPlayerCount: schemas_exports.property("total_player_count", schemas_exports.number()),
      state: schemas_exports.unknown().optional()
    });
  }
});

// src/serialization/resources/matchmaker/resources/common/types/GameModeInfo.ts
var GameModeInfo;
var init_GameModeInfo = __esm({
  "src/serialization/resources/matchmaker/resources/common/types/GameModeInfo.ts"() {
    "use strict";
    init_core();
    GameModeInfo = schemas_exports.object({
      gameModeId: schemas_exports.property(
        "game_mode_id",
        schemas_exports.lazy(async () => (await Promise.resolve().then(() => (init_serialization(), serialization_exports))).Identifier)
      )
    });
  }
});

// src/serialization/resources/matchmaker/resources/common/types/RegionInfo.ts
var RegionInfo;
var init_RegionInfo = __esm({
  "src/serialization/resources/matchmaker/resources/common/types/RegionInfo.ts"() {
    "use strict";
    init_core();
    RegionInfo = schemas_exports.object({
      regionId: schemas_exports.property(
        "region_id",
        schemas_exports.lazy(async () => (await Promise.resolve().then(() => (init_serialization(), serialization_exports))).Identifier)
      ),
      providerDisplayName: schemas_exports.property("provider_display_name", schemas_exports.string()),
      regionDisplayName: schemas_exports.property("region_display_name", schemas_exports.string()),
      datacenterCoord: schemas_exports.property(
        "datacenter_coord",
        schemas_exports.lazyObject(async () => (await Promise.resolve().then(() => (init_serialization(), serialization_exports))).geo.Coord)
      ),
      datacenterDistanceFromClient: schemas_exports.property(
        "datacenter_distance_from_client",
        schemas_exports.lazyObject(async () => (await Promise.resolve().then(() => (init_serialization(), serialization_exports))).geo.Distance)
      )
    });
  }
});

// src/serialization/resources/matchmaker/resources/common/types/JoinLobby.ts
var JoinLobby;
var init_JoinLobby = __esm({
  "src/serialization/resources/matchmaker/resources/common/types/JoinLobby.ts"() {
    "use strict";
    init_core();
    JoinLobby = schemas_exports.object({
      lobbyId: schemas_exports.property("lobby_id", schemas_exports.string()),
      region: schemas_exports.lazyObject(async () => (await Promise.resolve().then(() => (init_serialization(), serialization_exports))).matchmaker.JoinRegion),
      ports: schemas_exports.record(
        schemas_exports.string(),
        schemas_exports.lazyObject(async () => (await Promise.resolve().then(() => (init_serialization(), serialization_exports))).matchmaker.JoinPort)
      ),
      player: schemas_exports.lazyObject(async () => (await Promise.resolve().then(() => (init_serialization(), serialization_exports))).matchmaker.JoinPlayer)
    });
  }
});

// src/serialization/resources/matchmaker/resources/common/types/JoinRegion.ts
var JoinRegion;
var init_JoinRegion = __esm({
  "src/serialization/resources/matchmaker/resources/common/types/JoinRegion.ts"() {
    "use strict";
    init_core();
    JoinRegion = schemas_exports.object({
      regionId: schemas_exports.property(
        "region_id",
        schemas_exports.lazy(async () => (await Promise.resolve().then(() => (init_serialization(), serialization_exports))).Identifier)
      ),
      displayName: schemas_exports.property(
        "display_name",
        schemas_exports.lazy(async () => (await Promise.resolve().then(() => (init_serialization(), serialization_exports))).DisplayName)
      )
    });
  }
});

// src/serialization/resources/matchmaker/resources/common/types/JoinPort.ts
var JoinPort;
var init_JoinPort = __esm({
  "src/serialization/resources/matchmaker/resources/common/types/JoinPort.ts"() {
    "use strict";
    init_core();
    JoinPort = schemas_exports.object({
      host: schemas_exports.string().optional(),
      hostname: schemas_exports.string(),
      port: schemas_exports.number().optional(),
      portRange: schemas_exports.property(
        "port_range",
        schemas_exports.lazyObject(async () => (await Promise.resolve().then(() => (init_serialization(), serialization_exports))).matchmaker.JoinPortRange).optional()
      ),
      isTls: schemas_exports.property("is_tls", schemas_exports.boolean())
    });
  }
});

// src/serialization/resources/matchmaker/resources/common/types/JoinPortRange.ts
var JoinPortRange;
var init_JoinPortRange = __esm({
  "src/serialization/resources/matchmaker/resources/common/types/JoinPortRange.ts"() {
    "use strict";
    init_core();
    JoinPortRange = schemas_exports.object({
      min: schemas_exports.number(),
      max: schemas_exports.number()
    });
  }
});

// src/serialization/resources/matchmaker/resources/common/types/JoinPlayer.ts
var JoinPlayer;
var init_JoinPlayer = __esm({
  "src/serialization/resources/matchmaker/resources/common/types/JoinPlayer.ts"() {
    "use strict";
    init_core();
    JoinPlayer = schemas_exports.object({
      token: schemas_exports.lazy(async () => (await Promise.resolve().then(() => (init_serialization(), serialization_exports))).Jwt)
    });
  }
});

// src/serialization/resources/matchmaker/resources/common/types/CustomLobbyPublicity.ts
var CustomLobbyPublicity2;
var init_CustomLobbyPublicity = __esm({
  "src/serialization/resources/matchmaker/resources/common/types/CustomLobbyPublicity.ts"() {
    "use strict";
    init_core();
    CustomLobbyPublicity2 = schemas_exports.enum_(["public", "private"]);
  }
});

// src/serialization/resources/matchmaker/resources/common/types/index.ts
var init_types47 = __esm({
  "src/serialization/resources/matchmaker/resources/common/types/index.ts"() {
    "use strict";
    init_LobbyInfo();
    init_GameModeInfo();
    init_RegionInfo();
    init_JoinLobby();
    init_JoinRegion();
    init_JoinPort();
    init_JoinPortRange();
    init_JoinPlayer();
    init_CustomLobbyPublicity();
  }
});

// src/serialization/resources/matchmaker/resources/common/index.ts
var common_exports19 = {};
__export(common_exports19, {
  CustomLobbyPublicity: () => CustomLobbyPublicity2,
  GameModeInfo: () => GameModeInfo,
  JoinLobby: () => JoinLobby,
  JoinPlayer: () => JoinPlayer,
  JoinPort: () => JoinPort,
  JoinPortRange: () => JoinPortRange,
  JoinRegion: () => JoinRegion,
  LobbyInfo: () => LobbyInfo,
  RegionInfo: () => RegionInfo
});
var init_common9 = __esm({
  "src/serialization/resources/matchmaker/resources/common/index.ts"() {
    "use strict";
    init_types47();
  }
});

// src/serialization/resources/matchmaker/resources/lobbies/types/FindLobbyResponse.ts
var FindLobbyResponse;
var init_FindLobbyResponse = __esm({
  "src/serialization/resources/matchmaker/resources/lobbies/types/FindLobbyResponse.ts"() {
    "use strict";
    init_core();
    FindLobbyResponse = schemas_exports.object({
      lobby: schemas_exports.lazyObject(async () => (await Promise.resolve().then(() => (init_serialization(), serialization_exports))).matchmaker.JoinLobby),
      ports: schemas_exports.record(
        schemas_exports.string(),
        schemas_exports.lazyObject(async () => (await Promise.resolve().then(() => (init_serialization(), serialization_exports))).matchmaker.JoinPort)
      ),
      player: schemas_exports.lazyObject(async () => (await Promise.resolve().then(() => (init_serialization(), serialization_exports))).matchmaker.JoinPlayer)
    });
  }
});

// src/serialization/resources/matchmaker/resources/lobbies/types/JoinLobbyResponse.ts
var JoinLobbyResponse;
var init_JoinLobbyResponse = __esm({
  "src/serialization/resources/matchmaker/resources/lobbies/types/JoinLobbyResponse.ts"() {
    "use strict";
    init_core();
    JoinLobbyResponse = schemas_exports.object({
      lobby: schemas_exports.lazyObject(async () => (await Promise.resolve().then(() => (init_serialization(), serialization_exports))).matchmaker.JoinLobby),
      ports: schemas_exports.record(
        schemas_exports.string(),
        schemas_exports.lazyObject(async () => (await Promise.resolve().then(() => (init_serialization(), serialization_exports))).matchmaker.JoinPort)
      ),
      player: schemas_exports.lazyObject(async () => (await Promise.resolve().then(() => (init_serialization(), serialization_exports))).matchmaker.JoinPlayer)
    });
  }
});

// src/serialization/resources/matchmaker/resources/lobbies/types/CreateLobbyResponse.ts
var CreateLobbyResponse;
var init_CreateLobbyResponse = __esm({
  "src/serialization/resources/matchmaker/resources/lobbies/types/CreateLobbyResponse.ts"() {
    "use strict";
    init_core();
    CreateLobbyResponse = schemas_exports.object({
      lobby: schemas_exports.lazyObject(async () => (await Promise.resolve().then(() => (init_serialization(), serialization_exports))).matchmaker.JoinLobby),
      ports: schemas_exports.record(
        schemas_exports.string(),
        schemas_exports.lazyObject(async () => (await Promise.resolve().then(() => (init_serialization(), serialization_exports))).matchmaker.JoinPort)
      ),
      player: schemas_exports.lazyObject(async () => (await Promise.resolve().then(() => (init_serialization(), serialization_exports))).matchmaker.JoinPlayer)
    });
  }
});

// src/serialization/resources/matchmaker/resources/lobbies/types/ListLobbiesResponse.ts
var ListLobbiesResponse;
var init_ListLobbiesResponse = __esm({
  "src/serialization/resources/matchmaker/resources/lobbies/types/ListLobbiesResponse.ts"() {
    "use strict";
    init_core();
    ListLobbiesResponse = schemas_exports.object({
      gameModes: schemas_exports.property(
        "game_modes",
        schemas_exports.list(
          schemas_exports.lazyObject(async () => (await Promise.resolve().then(() => (init_serialization(), serialization_exports))).matchmaker.GameModeInfo)
        )
      ),
      regions: schemas_exports.list(
        schemas_exports.lazyObject(async () => (await Promise.resolve().then(() => (init_serialization(), serialization_exports))).matchmaker.RegionInfo)
      ),
      lobbies: schemas_exports.list(
        schemas_exports.lazyObject(async () => (await Promise.resolve().then(() => (init_serialization(), serialization_exports))).matchmaker.LobbyInfo)
      )
    });
  }
});

// src/serialization/resources/matchmaker/resources/lobbies/types/index.ts
var init_types48 = __esm({
  "src/serialization/resources/matchmaker/resources/lobbies/types/index.ts"() {
    "use strict";
    init_FindLobbyResponse();
    init_JoinLobbyResponse();
    init_CreateLobbyResponse();
    init_ListLobbiesResponse();
  }
});

// src/serialization/resources/matchmaker/resources/lobbies/client/setState.ts
var setState_exports = {};
__export(setState_exports, {
  Request: () => Request
});
var Request;
var init_setState = __esm({
  "src/serialization/resources/matchmaker/resources/lobbies/client/setState.ts"() {
    "use strict";
    init_core();
    Request = schemas_exports.unknown().optional();
  }
});

// src/serialization/resources/matchmaker/resources/lobbies/client/getState.ts
var getState_exports = {};
__export(getState_exports, {
  Response: () => Response
});
var Response;
var init_getState = __esm({
  "src/serialization/resources/matchmaker/resources/lobbies/client/getState.ts"() {
    "use strict";
    init_core();
    Response = schemas_exports.unknown().optional();
  }
});

// src/serialization/resources/matchmaker/resources/lobbies/client/requests/SetLobbyClosedRequest.ts
var SetLobbyClosedRequest;
var init_SetLobbyClosedRequest = __esm({
  "src/serialization/resources/matchmaker/resources/lobbies/client/requests/SetLobbyClosedRequest.ts"() {
    "use strict";
    init_core();
    SetLobbyClosedRequest = schemas_exports.object({
      isClosed: schemas_exports.property("is_closed", schemas_exports.boolean())
    });
  }
});

// src/serialization/resources/matchmaker/resources/lobbies/client/requests/FindLobbyRequest.ts
var FindLobbyRequest2;
var init_FindLobbyRequest2 = __esm({
  "src/serialization/resources/matchmaker/resources/lobbies/client/requests/FindLobbyRequest.ts"() {
    "use strict";
    init_core();
    FindLobbyRequest2 = schemas_exports.object({
      gameModes: schemas_exports.property("game_modes", schemas_exports.list(schemas_exports.string())),
      regions: schemas_exports.list(schemas_exports.string()).optional(),
      preventAutoCreateLobby: schemas_exports.property(
        "prevent_auto_create_lobby",
        schemas_exports.boolean().optional()
      ),
      tags: schemas_exports.record(schemas_exports.string(), schemas_exports.string()).optional(),
      maxPlayers: schemas_exports.property("max_players", schemas_exports.number().optional()),
      captcha: schemas_exports.lazyObject(async () => (await Promise.resolve().then(() => (init_serialization(), serialization_exports))).captcha.Config).optional(),
      verificationData: schemas_exports.property("verification_data", schemas_exports.unknown().optional())
    });
  }
});

// src/serialization/resources/matchmaker/resources/lobbies/client/requests/JoinLobbyRequest.ts
var JoinLobbyRequest;
var init_JoinLobbyRequest = __esm({
  "src/serialization/resources/matchmaker/resources/lobbies/client/requests/JoinLobbyRequest.ts"() {
    "use strict";
    init_core();
    JoinLobbyRequest = schemas_exports.object({
      lobbyId: schemas_exports.property("lobby_id", schemas_exports.string()),
      captcha: schemas_exports.lazyObject(async () => (await Promise.resolve().then(() => (init_serialization(), serialization_exports))).captcha.Config).optional(),
      verificationData: schemas_exports.property("verification_data", schemas_exports.unknown().optional())
    });
  }
});

// src/serialization/resources/matchmaker/resources/lobbies/client/requests/CreateLobbyRequest.ts
var CreateLobbyRequest;
var init_CreateLobbyRequest = __esm({
  "src/serialization/resources/matchmaker/resources/lobbies/client/requests/CreateLobbyRequest.ts"() {
    "use strict";
    init_core();
    CreateLobbyRequest = schemas_exports.object({
      gameMode: schemas_exports.property("game_mode", schemas_exports.string()),
      region: schemas_exports.string().optional(),
      publicity: schemas_exports.lazy(async () => (await Promise.resolve().then(() => (init_serialization(), serialization_exports))).matchmaker.CustomLobbyPublicity).optional(),
      tags: schemas_exports.record(schemas_exports.string(), schemas_exports.string()).optional(),
      maxPlayers: schemas_exports.property("max_players", schemas_exports.number().optional()),
      lobbyConfig: schemas_exports.property("lobby_config", schemas_exports.unknown().optional()),
      captcha: schemas_exports.lazyObject(async () => (await Promise.resolve().then(() => (init_serialization(), serialization_exports))).captcha.Config).optional(),
      verificationData: schemas_exports.property("verification_data", schemas_exports.unknown().optional())
    });
  }
});

// src/serialization/resources/matchmaker/resources/lobbies/client/requests/index.ts
var init_requests3 = __esm({
  "src/serialization/resources/matchmaker/resources/lobbies/client/requests/index.ts"() {
    "use strict";
    init_SetLobbyClosedRequest();
    init_FindLobbyRequest2();
    init_JoinLobbyRequest();
    init_CreateLobbyRequest();
  }
});

// src/serialization/resources/matchmaker/resources/lobbies/client/index.ts
var init_client3 = __esm({
  "src/serialization/resources/matchmaker/resources/lobbies/client/index.ts"() {
    "use strict";
    init_setState();
    init_getState();
    init_requests3();
  }
});

// src/serialization/resources/matchmaker/resources/lobbies/index.ts
var lobbies_exports2 = {};
__export(lobbies_exports2, {
  CreateLobbyRequest: () => CreateLobbyRequest,
  CreateLobbyResponse: () => CreateLobbyResponse,
  FindLobbyRequest: () => FindLobbyRequest2,
  FindLobbyResponse: () => FindLobbyResponse,
  JoinLobbyRequest: () => JoinLobbyRequest,
  JoinLobbyResponse: () => JoinLobbyResponse,
  ListLobbiesResponse: () => ListLobbiesResponse,
  SetLobbyClosedRequest: () => SetLobbyClosedRequest,
  getState: () => getState_exports,
  setState: () => setState_exports
});
var init_lobbies = __esm({
  "src/serialization/resources/matchmaker/resources/lobbies/index.ts"() {
    "use strict";
    init_types48();
    init_client3();
  }
});

// src/serialization/resources/matchmaker/resources/players/types/GetStatisticsResponse.ts
var GetStatisticsResponse;
var init_GetStatisticsResponse = __esm({
  "src/serialization/resources/matchmaker/resources/players/types/GetStatisticsResponse.ts"() {
    "use strict";
    init_core();
    GetStatisticsResponse = schemas_exports.object({
      playerCount: schemas_exports.property("player_count", schemas_exports.number()),
      gameModes: schemas_exports.property(
        "game_modes",
        schemas_exports.record(
          schemas_exports.lazy(async () => (await Promise.resolve().then(() => (init_serialization(), serialization_exports))).Identifier),
          schemas_exports.lazyObject(async () => (await Promise.resolve().then(() => (init_serialization(), serialization_exports))).matchmaker.GameModeStatistics)
        )
      )
    });
  }
});

// src/serialization/resources/matchmaker/resources/players/types/GameModeStatistics.ts
var GameModeStatistics;
var init_GameModeStatistics = __esm({
  "src/serialization/resources/matchmaker/resources/players/types/GameModeStatistics.ts"() {
    "use strict";
    init_core();
    GameModeStatistics = schemas_exports.object({
      playerCount: schemas_exports.property("player_count", schemas_exports.number()),
      regions: schemas_exports.record(
        schemas_exports.lazy(async () => (await Promise.resolve().then(() => (init_serialization(), serialization_exports))).Identifier),
        schemas_exports.lazyObject(async () => (await Promise.resolve().then(() => (init_serialization(), serialization_exports))).matchmaker.RegionStatistics)
      )
    });
  }
});

// src/serialization/resources/matchmaker/resources/players/types/RegionStatistics.ts
var RegionStatistics;
var init_RegionStatistics = __esm({
  "src/serialization/resources/matchmaker/resources/players/types/RegionStatistics.ts"() {
    "use strict";
    init_core();
    RegionStatistics = schemas_exports.object({
      playerCount: schemas_exports.property("player_count", schemas_exports.number())
    });
  }
});

// src/serialization/resources/matchmaker/resources/players/types/index.ts
var init_types49 = __esm({
  "src/serialization/resources/matchmaker/resources/players/types/index.ts"() {
    "use strict";
    init_GetStatisticsResponse();
    init_GameModeStatistics();
    init_RegionStatistics();
  }
});

// src/serialization/resources/matchmaker/resources/players/client/requests/PlayerConnectedRequest.ts
var PlayerConnectedRequest;
var init_PlayerConnectedRequest = __esm({
  "src/serialization/resources/matchmaker/resources/players/client/requests/PlayerConnectedRequest.ts"() {
    "use strict";
    init_core();
    PlayerConnectedRequest = schemas_exports.object({
      playerToken: schemas_exports.property("player_token", schemas_exports.string())
    });
  }
});

// src/serialization/resources/matchmaker/resources/players/client/requests/PlayerDisconnectedRequest.ts
var PlayerDisconnectedRequest;
var init_PlayerDisconnectedRequest = __esm({
  "src/serialization/resources/matchmaker/resources/players/client/requests/PlayerDisconnectedRequest.ts"() {
    "use strict";
    init_core();
    PlayerDisconnectedRequest = schemas_exports.object({
      playerToken: schemas_exports.property("player_token", schemas_exports.string())
    });
  }
});

// src/serialization/resources/matchmaker/resources/players/client/requests/index.ts
var init_requests4 = __esm({
  "src/serialization/resources/matchmaker/resources/players/client/requests/index.ts"() {
    "use strict";
    init_PlayerConnectedRequest();
    init_PlayerDisconnectedRequest();
  }
});

// src/serialization/resources/matchmaker/resources/players/client/index.ts
var init_client4 = __esm({
  "src/serialization/resources/matchmaker/resources/players/client/index.ts"() {
    "use strict";
    init_requests4();
  }
});

// src/serialization/resources/matchmaker/resources/players/index.ts
var players_exports2 = {};
__export(players_exports2, {
  GameModeStatistics: () => GameModeStatistics,
  GetStatisticsResponse: () => GetStatisticsResponse,
  PlayerConnectedRequest: () => PlayerConnectedRequest,
  PlayerDisconnectedRequest: () => PlayerDisconnectedRequest,
  RegionStatistics: () => RegionStatistics
});
var init_players = __esm({
  "src/serialization/resources/matchmaker/resources/players/index.ts"() {
    "use strict";
    init_types49();
    init_client4();
  }
});

// src/serialization/resources/matchmaker/resources/regions/types/ListRegionsResponse.ts
var ListRegionsResponse;
var init_ListRegionsResponse = __esm({
  "src/serialization/resources/matchmaker/resources/regions/types/ListRegionsResponse.ts"() {
    "use strict";
    init_core();
    ListRegionsResponse = schemas_exports.object({
      regions: schemas_exports.list(
        schemas_exports.lazyObject(async () => (await Promise.resolve().then(() => (init_serialization(), serialization_exports))).matchmaker.RegionInfo)
      )
    });
  }
});

// src/serialization/resources/matchmaker/resources/regions/types/index.ts
var init_types50 = __esm({
  "src/serialization/resources/matchmaker/resources/regions/types/index.ts"() {
    "use strict";
    init_ListRegionsResponse();
  }
});

// src/serialization/resources/matchmaker/resources/regions/index.ts
var regions_exports2 = {};
__export(regions_exports2, {
  ListRegionsResponse: () => ListRegionsResponse
});
var init_regions = __esm({
  "src/serialization/resources/matchmaker/resources/regions/index.ts"() {
    "use strict";
    init_types50();
  }
});

// src/serialization/resources/matchmaker/resources/index.ts
var init_resources15 = __esm({
  "src/serialization/resources/matchmaker/resources/index.ts"() {
    "use strict";
    init_common9();
    init_types47();
    init_lobbies();
    init_types48();
    init_players();
    init_types49();
    init_regions();
    init_types50();
    init_requests3();
    init_requests4();
  }
});

// src/serialization/resources/matchmaker/index.ts
var matchmaker_exports6 = {};
__export(matchmaker_exports6, {
  CreateLobbyRequest: () => CreateLobbyRequest,
  CreateLobbyResponse: () => CreateLobbyResponse,
  CustomLobbyPublicity: () => CustomLobbyPublicity2,
  FindLobbyRequest: () => FindLobbyRequest2,
  FindLobbyResponse: () => FindLobbyResponse,
  GameModeInfo: () => GameModeInfo,
  GameModeStatistics: () => GameModeStatistics,
  GetStatisticsResponse: () => GetStatisticsResponse,
  JoinLobby: () => JoinLobby,
  JoinLobbyRequest: () => JoinLobbyRequest,
  JoinLobbyResponse: () => JoinLobbyResponse,
  JoinPlayer: () => JoinPlayer,
  JoinPort: () => JoinPort,
  JoinPortRange: () => JoinPortRange,
  JoinRegion: () => JoinRegion,
  ListLobbiesResponse: () => ListLobbiesResponse,
  ListRegionsResponse: () => ListRegionsResponse,
  LobbyInfo: () => LobbyInfo,
  PlayerConnectedRequest: () => PlayerConnectedRequest,
  PlayerDisconnectedRequest: () => PlayerDisconnectedRequest,
  RegionInfo: () => RegionInfo,
  RegionStatistics: () => RegionStatistics,
  SetLobbyClosedRequest: () => SetLobbyClosedRequest,
  common: () => common_exports19,
  lobbies: () => lobbies_exports2,
  players: () => players_exports2,
  regions: () => regions_exports2
});
var init_matchmaker3 = __esm({
  "src/serialization/resources/matchmaker/index.ts"() {
    "use strict";
    init_resources15();
  }
});

// src/serialization/resources/upload/resources/common/types/PresignedRequest.ts
var PresignedRequest;
var init_PresignedRequest = __esm({
  "src/serialization/resources/upload/resources/common/types/PresignedRequest.ts"() {
    "use strict";
    init_core();
    PresignedRequest = schemas_exports.object({
      path: schemas_exports.string(),
      url: schemas_exports.string(),
      byteOffset: schemas_exports.property("byte_offset", schemas_exports.number()),
      contentLength: schemas_exports.property("content_length", schemas_exports.number())
    });
  }
});

// src/serialization/resources/upload/resources/common/types/PrepareFile.ts
var PrepareFile;
var init_PrepareFile = __esm({
  "src/serialization/resources/upload/resources/common/types/PrepareFile.ts"() {
    "use strict";
    init_core();
    PrepareFile = schemas_exports.object({
      path: schemas_exports.string(),
      contentType: schemas_exports.property("content_type", schemas_exports.string().optional()),
      contentLength: schemas_exports.property("content_length", schemas_exports.number())
    });
  }
});

// src/serialization/resources/upload/resources/common/types/index.ts
var init_types51 = __esm({
  "src/serialization/resources/upload/resources/common/types/index.ts"() {
    "use strict";
    init_PresignedRequest();
    init_PrepareFile();
  }
});

// src/serialization/resources/upload/resources/common/index.ts
var common_exports20 = {};
__export(common_exports20, {
  PrepareFile: () => PrepareFile,
  PresignedRequest: () => PresignedRequest
});
var init_common10 = __esm({
  "src/serialization/resources/upload/resources/common/index.ts"() {
    "use strict";
    init_types51();
  }
});

// src/serialization/resources/upload/resources/index.ts
var init_resources16 = __esm({
  "src/serialization/resources/upload/resources/index.ts"() {
    "use strict";
    init_common10();
    init_types51();
  }
});

// src/serialization/resources/upload/index.ts
var upload_exports2 = {};
__export(upload_exports2, {
  PrepareFile: () => PrepareFile,
  PresignedRequest: () => PresignedRequest,
  common: () => common_exports20
});
var init_upload = __esm({
  "src/serialization/resources/upload/index.ts"() {
    "use strict";
    init_resources16();
  }
});

// src/serialization/resources/index.ts
var init_resources17 = __esm({
  "src/serialization/resources/index.ts"() {
    "use strict";
    init_admin();
    init_cloud();
    init_group();
    init_identity2();
    init_kv2();
    init_module();
    init_captcha();
    init_common6();
    init_types44();
    init_game();
    init_geo();
    init_matchmaker3();
    init_upload();
  }
});

// src/serialization/index.ts
var serialization_exports = {};
__export(serialization_exports, {
  AccountNumber: () => AccountNumber,
  Bio: () => Bio,
  DisplayName: () => DisplayName,
  Email: () => Email,
  EmptyObject: () => EmptyObject,
  ErrorBody: () => ErrorBody,
  ErrorMetadata: () => ErrorMetadata,
  Identifier: () => Identifier,
  Jwt: () => Jwt,
  ValidationError: () => ValidationError5,
  WatchQuery: () => WatchQuery,
  WatchResponse: () => WatchResponse,
  admin: () => admin_exports2,
  captcha: () => captcha_exports2,
  cloud: () => cloud_exports2,
  common: () => common_exports16,
  game: () => game_exports2,
  geo: () => geo_exports2,
  group: () => group_exports2,
  identity: () => identity_exports4,
  kv: () => kv_exports4,
  matchmaker: () => matchmaker_exports6,
  module_: () => module_exports2,
  upload: () => upload_exports2
});
var init_serialization = __esm({
  "src/serialization/index.ts"() {
    "use strict";
    init_resources17();
  }
});

// src/index.ts
var src_exports = {};
__export(src_exports, {
  Rivet: () => api_exports,
  RivetClient: () => RivetClient,
  RivetEnvironment: () => RivetEnvironment,
  RivetError: () => RivetError,
  RivetTimeoutError: () => RivetTimeoutError
});
module.exports = __toCommonJS(src_exports);

// src/api/index.ts
var api_exports = {};
__export(api_exports, {
  BadRequestError: () => BadRequestError,
  ForbiddenError: () => ForbiddenError,
  InternalError: () => InternalError,
  NotFoundError: () => NotFoundError,
  RateLimitError: () => RateLimitError,
  UnauthorizedError: () => UnauthorizedError,
  admin: () => admin_exports,
  captcha: () => captcha_exports,
  cloud: () => cloud_exports,
  common: () => common_exports6,
  game: () => game_exports,
  geo: () => geo_exports,
  group: () => group_exports,
  identity: () => identity_exports2,
  kv: () => kv_exports2,
  matchmaker: () => matchmaker_exports3,
  module_: () => module_exports,
  upload: () => upload_exports
});

// src/api/resources/admin/index.ts
var admin_exports = {};

// src/api/resources/cloud/index.ts
var cloud_exports = {};
__export(cloud_exports, {
  BootstrapCluster: () => BootstrapCluster,
  CdnAuthType: () => CdnAuthType,
  CdnNamespaceDomainVerificationStatus: () => CdnNamespaceDomainVerificationStatus,
  UniversalRegion: () => UniversalRegion,
  auth: () => auth_exports,
  common: () => common_exports2,
  devices: () => devices_exports,
  games: () => games_exports2,
  groups: () => groups_exports,
  logs: () => logs_exports2,
  tiers: () => tiers_exports,
  uploads: () => uploads_exports,
  version: () => version_exports
});

// src/api/resources/cloud/types/BootstrapCluster.ts
var BootstrapCluster = {
  Enterprise: "enterprise",
  Oss: "oss"
};

// src/api/resources/cloud/resources/games/index.ts
var games_exports2 = {};
__export(games_exports2, {
  BuildCompression: () => BuildCompression,
  BuildKind: () => BuildKind,
  LogStream: () => LogStream,
  avatars: () => avatars_exports,
  builds: () => builds_exports,
  cdn: () => cdn_exports,
  games: () => games_exports,
  matchmaker: () => matchmaker_exports,
  namespaces: () => namespaces_exports,
  tokens: () => tokens_exports,
  versions: () => versions_exports
});

// src/api/resources/cloud/resources/games/resources/namespaces/index.ts
var namespaces_exports = {};
__export(namespaces_exports, {
  analytics: () => analytics_exports,
  logs: () => logs_exports
});

// src/api/resources/cloud/resources/games/resources/namespaces/resources/analytics/index.ts
var analytics_exports = {};

// src/api/resources/cloud/resources/games/resources/namespaces/resources/logs/index.ts
var logs_exports = {};

// src/api/resources/cloud/resources/games/resources/avatars/index.ts
var avatars_exports = {};

// src/api/resources/cloud/resources/games/resources/builds/index.ts
var builds_exports = {};
__export(builds_exports, {
  BuildCompression: () => BuildCompression,
  BuildKind: () => BuildKind
});

// src/api/resources/cloud/resources/games/resources/builds/types/BuildKind.ts
var BuildKind = {
  DockerImage: "docker_image",
  OciBundle: "oci_bundle"
};

// src/api/resources/cloud/resources/games/resources/builds/types/BuildCompression.ts
var BuildCompression = {
  None: "none",
  Lz4: "lz4"
};

// src/api/resources/cloud/resources/games/resources/cdn/index.ts
var cdn_exports = {};

// src/api/resources/cloud/resources/games/resources/games/index.ts
var games_exports = {};

// src/api/resources/cloud/resources/games/resources/matchmaker/index.ts
var matchmaker_exports = {};
__export(matchmaker_exports, {
  LogStream: () => LogStream
});

// src/api/resources/cloud/resources/games/resources/matchmaker/types/LogStream.ts
var LogStream = {
  StdOut: "std_out",
  StdErr: "std_err"
};

// src/api/resources/cloud/resources/games/resources/tokens/index.ts
var tokens_exports = {};

// src/api/resources/cloud/resources/games/resources/versions/index.ts
var versions_exports = {};

// src/api/resources/cloud/resources/version/index.ts
var version_exports = {};
__export(version_exports, {
  cdn: () => cdn_exports2,
  engine: () => engine_exports,
  identity: () => identity_exports,
  kv: () => kv_exports,
  matchmaker: () => matchmaker_exports2
});

// src/api/resources/cloud/resources/version/resources/cdn/index.ts
var cdn_exports2 = {};

// src/api/resources/cloud/resources/version/resources/engine/index.ts
var engine_exports = {};
__export(engine_exports, {
  godot: () => godot_exports,
  html5: () => html5_exports,
  unity: () => unity_exports,
  unreal: () => unreal_exports
});

// src/api/resources/cloud/resources/version/resources/engine/resources/godot/index.ts
var godot_exports = {};

// src/api/resources/cloud/resources/version/resources/engine/resources/html5/index.ts
var html5_exports = {};

// src/api/resources/cloud/resources/version/resources/engine/resources/unity/index.ts
var unity_exports = {};

// src/api/resources/cloud/resources/version/resources/engine/resources/unreal/index.ts
var unreal_exports = {};

// src/api/resources/cloud/resources/version/resources/kv/index.ts
var kv_exports = {};

// src/api/resources/cloud/resources/version/resources/matchmaker/index.ts
var matchmaker_exports2 = {};
__export(matchmaker_exports2, {
  CaptchaHcaptchaLevel: () => CaptchaHcaptchaLevel,
  GameModeIdentityRequirement: () => GameModeIdentityRequirement,
  NetworkMode: () => NetworkMode,
  PortProtocol: () => PortProtocol,
  ProxyKind: () => ProxyKind,
  common: () => common_exports,
  gameMode: () => gameMode_exports,
  lobbyGroup: () => lobbyGroup_exports
});

// src/api/resources/cloud/resources/version/resources/matchmaker/resources/common/index.ts
var common_exports = {};
__export(common_exports, {
  CaptchaHcaptchaLevel: () => CaptchaHcaptchaLevel,
  NetworkMode: () => NetworkMode,
  PortProtocol: () => PortProtocol,
  ProxyKind: () => ProxyKind
});

// src/api/resources/cloud/resources/version/resources/matchmaker/resources/common/types/PortProtocol.ts
var PortProtocol = {
  Http: "http",
  Https: "https",
  Tcp: "tcp",
  TcpTls: "tcp_tls",
  Udp: "udp"
};

// src/api/resources/cloud/resources/version/resources/matchmaker/resources/common/types/ProxyKind.ts
var ProxyKind = {
  None: "none",
  GameGuard: "game_guard"
};

// src/api/resources/cloud/resources/version/resources/matchmaker/resources/common/types/CaptchaHcaptchaLevel.ts
var CaptchaHcaptchaLevel = {
  Easy: "easy",
  Moderate: "moderate",
  Difficult: "difficult",
  AlwaysOn: "always_on"
};

// src/api/resources/cloud/resources/version/resources/matchmaker/resources/common/types/NetworkMode.ts
var NetworkMode = {
  Bridge: "bridge",
  Host: "host"
};

// src/api/resources/cloud/resources/version/resources/matchmaker/resources/gameMode/index.ts
var gameMode_exports = {};
__export(gameMode_exports, {
  GameModeIdentityRequirement: () => GameModeIdentityRequirement
});

// src/api/resources/cloud/resources/version/resources/matchmaker/resources/gameMode/types/GameModeIdentityRequirement.ts
var GameModeIdentityRequirement = {
  None: "none",
  Guest: "guest",
  Registered: "registered"
};

// src/api/resources/cloud/resources/version/resources/matchmaker/resources/lobbyGroup/index.ts
var lobbyGroup_exports = {};

// src/api/resources/cloud/resources/version/resources/identity/index.ts
var identity_exports = {};
__export(identity_exports, {
  pacakge: () => pacakge_exports
});

// src/api/resources/cloud/resources/version/resources/identity/resources/pacakge/index.ts
var pacakge_exports = {};

// src/api/resources/cloud/resources/auth/index.ts
var auth_exports = {};

// src/api/resources/cloud/resources/common/index.ts
var common_exports2 = {};
__export(common_exports2, {
  CdnAuthType: () => CdnAuthType,
  CdnNamespaceDomainVerificationStatus: () => CdnNamespaceDomainVerificationStatus,
  UniversalRegion: () => UniversalRegion
});

// src/api/resources/cloud/resources/common/types/UniversalRegion.ts
var UniversalRegion = {
  Unknown: "unknown",
  Local: "local",
  Amsterdam: "amsterdam",
  Atlanta: "atlanta",
  Bangalore: "bangalore",
  Dallas: "dallas",
  Frankfurt: "frankfurt",
  London: "london",
  Mumbai: "mumbai",
  Newark: "newark",
  NewYorkCity: "new_york_city",
  SanFrancisco: "san_francisco",
  Singapore: "singapore",
  Sydney: "sydney",
  Tokyo: "tokyo",
  Toronto: "toronto",
  WashingtonDc: "washington_dc",
  Chicago: "chicago",
  Paris: "paris",
  Seattle: "seattle",
  SaoPaulo: "sao_paulo",
  Stockholm: "stockholm",
  Chennai: "chennai",
  Osaka: "osaka",
  Milan: "milan",
  Miami: "miami",
  Jakarta: "jakarta",
  LosAngeles: "los_angeles"
};

// src/api/resources/cloud/resources/common/types/CdnAuthType.ts
var CdnAuthType = {
  None: "none",
  Basic: "basic"
};

// src/api/resources/cloud/resources/common/types/CdnNamespaceDomainVerificationStatus.ts
var CdnNamespaceDomainVerificationStatus = {
  Active: "active",
  Pending: "pending",
  Failed: "failed"
};

// src/api/resources/cloud/resources/devices/index.ts
var devices_exports = {};
__export(devices_exports, {
  links: () => links_exports
});

// src/api/resources/cloud/resources/devices/resources/links/index.ts
var links_exports = {};

// src/api/resources/cloud/resources/groups/index.ts
var groups_exports = {};

// src/api/resources/cloud/resources/logs/index.ts
var logs_exports2 = {};

// src/api/resources/cloud/resources/tiers/index.ts
var tiers_exports = {};

// src/api/resources/cloud/resources/uploads/index.ts
var uploads_exports = {};

// src/api/resources/group/index.ts
var group_exports = {};
__export(group_exports, {
  Publicity: () => Publicity,
  common: () => common_exports3,
  invites: () => invites_exports,
  joinRequests: () => joinRequests_exports
});

// src/api/resources/group/resources/common/index.ts
var common_exports3 = {};
__export(common_exports3, {
  Publicity: () => Publicity
});

// src/api/resources/group/resources/common/types/Publicity.ts
var Publicity = {
  Open: "open",
  Closed: "closed"
};

// src/api/resources/group/resources/invites/index.ts
var invites_exports = {};

// src/api/resources/group/resources/joinRequests/index.ts
var joinRequests_exports = {};

// src/api/resources/identity/index.ts
var identity_exports2 = {};
__export(identity_exports2, {
  DevState: () => DevState,
  GameLinkStatus: () => GameLinkStatus,
  Status: () => Status,
  common: () => common_exports4,
  events: () => events_exports,
  links: () => links_exports2
});

// src/api/resources/identity/resources/common/index.ts
var common_exports4 = {};
__export(common_exports4, {
  DevState: () => DevState,
  GameLinkStatus: () => GameLinkStatus,
  Status: () => Status
});

// src/api/resources/identity/resources/common/types/Status.ts
var Status = {
  Online: "online",
  Away: "away",
  Offline: "offline"
};

// src/api/resources/identity/resources/common/types/DevState.ts
var DevState = {
  Inactive: "inactive",
  Pending: "pending",
  Accepted: "accepted"
};

// src/api/resources/identity/resources/common/types/GameLinkStatus.ts
var GameLinkStatus = {
  Incomplete: "incomplete",
  Complete: "complete",
  Cancelled: "cancelled"
};

// src/api/resources/identity/resources/events/index.ts
var events_exports = {};

// src/api/resources/identity/resources/links/index.ts
var links_exports2 = {};

// src/api/resources/kv/index.ts
var kv_exports2 = {};
__export(kv_exports2, {
  common: () => common_exports5
});

// src/api/resources/kv/resources/common/index.ts
var common_exports5 = {};

// src/api/resources/module/index.ts
var module_exports = {};

// src/api/resources/captcha/index.ts
var captcha_exports = {};
__export(captcha_exports, {
  config: () => config_exports
});

// src/api/resources/captcha/resources/config/index.ts
var config_exports = {};

// src/api/resources/common/index.ts
var common_exports6 = {};
__export(common_exports6, {
  BadRequestError: () => BadRequestError,
  ForbiddenError: () => ForbiddenError,
  InternalError: () => InternalError,
  NotFoundError: () => NotFoundError,
  RateLimitError: () => RateLimitError,
  UnauthorizedError: () => UnauthorizedError
});

// src/errors/RivetError.ts
var RivetError = class extends Error {
  statusCode;
  body;
  constructor({ message, statusCode, body }) {
    super(message);
    Object.setPrototypeOf(this, RivetError.prototype);
    if (statusCode != null) {
      this.statusCode = statusCode;
    }
    if (body !== void 0) {
      this.body = body;
    }
  }
};

// src/errors/RivetTimeoutError.ts
var RivetTimeoutError = class extends Error {
  constructor() {
    super("Timeout");
    Object.setPrototypeOf(this, RivetTimeoutError.prototype);
  }
};

// src/api/resources/common/errors/InternalError.ts
var InternalError = class extends RivetError {
  constructor(body) {
    super({
      message: "InternalError",
      statusCode: 500,
      body
    });
    Object.setPrototypeOf(this, InternalError.prototype);
  }
};

// src/api/resources/common/errors/RateLimitError.ts
var RateLimitError = class extends RivetError {
  constructor(body) {
    super({
      message: "RateLimitError",
      statusCode: 429,
      body
    });
    Object.setPrototypeOf(this, RateLimitError.prototype);
  }
};

// src/api/resources/common/errors/ForbiddenError.ts
var ForbiddenError = class extends RivetError {
  constructor(body) {
    super({
      message: "ForbiddenError",
      statusCode: 403,
      body
    });
    Object.setPrototypeOf(this, ForbiddenError.prototype);
  }
};

// src/api/resources/common/errors/UnauthorizedError.ts
var UnauthorizedError = class extends RivetError {
  constructor(body) {
    super({
      message: "UnauthorizedError",
      statusCode: 408,
      body
    });
    Object.setPrototypeOf(this, UnauthorizedError.prototype);
  }
};

// src/api/resources/common/errors/NotFoundError.ts
var NotFoundError = class extends RivetError {
  constructor(body) {
    super({
      message: "NotFoundError",
      statusCode: 404,
      body
    });
    Object.setPrototypeOf(this, NotFoundError.prototype);
  }
};

// src/api/resources/common/errors/BadRequestError.ts
var BadRequestError = class extends RivetError {
  constructor(body) {
    super({
      message: "BadRequestError",
      statusCode: 400,
      body
    });
    Object.setPrototypeOf(this, BadRequestError.prototype);
  }
};

// src/api/resources/game/index.ts
var game_exports = {};
__export(game_exports, {
  StatAggregationMethod: () => StatAggregationMethod,
  StatFormatMethod: () => StatFormatMethod,
  StatSortingMethod: () => StatSortingMethod,
  common: () => common_exports7
});

// src/api/resources/game/resources/common/index.ts
var common_exports7 = {};
__export(common_exports7, {
  StatAggregationMethod: () => StatAggregationMethod,
  StatFormatMethod: () => StatFormatMethod,
  StatSortingMethod: () => StatSortingMethod
});

// src/api/resources/game/resources/common/types/StatFormatMethod.ts
var StatFormatMethod = {
  Integer: "integer",
  Float1: "float_1",
  Float2: "float_2",
  Float3: "float_3",
  DurationMinute: "duration_minute",
  DurationSecond: "duration_second",
  DurationHundredthSecond: "duration_hundredth_second"
};

// src/api/resources/game/resources/common/types/StatAggregationMethod.ts
var StatAggregationMethod = {
  Sum: "sum",
  Average: "average",
  Min: "min",
  Max: "max"
};

// src/api/resources/game/resources/common/types/StatSortingMethod.ts
var StatSortingMethod = {
  Desc: "desc",
  Asc: "asc"
};

// src/api/resources/geo/index.ts
var geo_exports = {};
__export(geo_exports, {
  common: () => common_exports8
});

// src/api/resources/geo/resources/common/index.ts
var common_exports8 = {};

// src/api/resources/matchmaker/index.ts
var matchmaker_exports3 = {};
__export(matchmaker_exports3, {
  CustomLobbyPublicity: () => CustomLobbyPublicity,
  common: () => common_exports9,
  lobbies: () => lobbies_exports,
  players: () => players_exports,
  regions: () => regions_exports
});

// src/api/resources/matchmaker/resources/common/index.ts
var common_exports9 = {};
__export(common_exports9, {
  CustomLobbyPublicity: () => CustomLobbyPublicity
});

// src/api/resources/matchmaker/resources/common/types/CustomLobbyPublicity.ts
var CustomLobbyPublicity = {
  Public: "public",
  Private: "private"
};

// src/api/resources/matchmaker/resources/lobbies/index.ts
var lobbies_exports = {};

// src/api/resources/matchmaker/resources/players/index.ts
var players_exports = {};

// src/api/resources/matchmaker/resources/regions/index.ts
var regions_exports = {};

// src/api/resources/upload/index.ts
var upload_exports = {};
__export(upload_exports, {
  common: () => common_exports10
});

// src/api/resources/upload/resources/common/index.ts
var common_exports10 = {};

// src/environments.ts
var RivetEnvironment = {
  Production: "https://api.rivet.gg",
  Staging: "https://api.staging.gameinc.io"
};

// src/api/resources/admin/client/Client.ts
init_core();
var import_url_join = __toESM(require_url_join());
init_serialization();
var Admin = class {
  constructor(options) {
    this.options = options;
  }
  /**
   * @throws {Rivet.InternalError}
   * @throws {Rivet.RateLimitError}
   * @throws {Rivet.ForbiddenError}
   * @throws {Rivet.UnauthorizedError}
   * @throws {Rivet.NotFoundError}
   * @throws {Rivet.BadRequestError}
   */
  async login(request) {
    const _response = await fetcher({
      url: (0, import_url_join.default)(this.options.environment ?? RivetEnvironment.Production, "/admin/login"),
      method: "POST",
      headers: {
        Authorization: await this._getAuthorizationHeader()
      },
      contentType: "application/json",
      body: await admin_exports2.LoginRequest.jsonOrThrow(request, { unrecognizedObjectKeys: "strip" })
    });
    if (_response.ok) {
      return await admin_exports2.LoginResponse.parseOrThrow(_response.body, {
        unrecognizedObjectKeys: "passthrough",
        allowUnrecognizedUnionMembers: true,
        allowUnrecognizedEnumValues: true
      });
    }
    if (_response.error.reason === "status-code") {
      switch (_response.error.statusCode) {
        case 500:
          throw new api_exports.InternalError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 429:
          throw new api_exports.RateLimitError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 403:
          throw new api_exports.ForbiddenError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 408:
          throw new api_exports.UnauthorizedError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 404:
          throw new api_exports.NotFoundError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 400:
          throw new api_exports.BadRequestError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        default:
          throw new RivetError({
            statusCode: _response.error.statusCode,
            body: _response.error.body
          });
      }
    }
    switch (_response.error.reason) {
      case "non-json":
        throw new RivetError({
          statusCode: _response.error.statusCode,
          body: _response.error.rawBody
        });
      case "timeout":
        throw new RivetTimeoutError();
      case "unknown":
        throw new RivetError({
          message: _response.error.errorMessage
        });
    }
  }
  async _getAuthorizationHeader() {
    const bearer = await Supplier.get(this.options.token);
    if (bearer != null) {
      return `Bearer ${bearer}`;
    }
    return void 0;
  }
};

// src/api/resources/cloud/client/Client.ts
init_core();
var import_url_join18 = __toESM(require_url_join());
init_serialization();

// src/api/resources/cloud/resources/games/resources/namespaces/client/Client.ts
init_core();
var import_url_join4 = __toESM(require_url_join());
init_serialization();

// src/api/resources/cloud/resources/games/resources/namespaces/resources/analytics/client/Client.ts
init_core();
var import_url_join2 = __toESM(require_url_join());
init_serialization();
var Analytics = class {
  constructor(options) {
    this.options = options;
  }
  /**
   * Returns live information about all active lobbies for a given namespace.
   * @throws {Rivet.InternalError}
   * @throws {Rivet.RateLimitError}
   * @throws {Rivet.ForbiddenError}
   * @throws {Rivet.UnauthorizedError}
   * @throws {Rivet.NotFoundError}
   * @throws {Rivet.BadRequestError}
   */
  async getAnalyticsMatchmakerLive(gameId, namespaceId) {
    const _response = await fetcher({
      url: (0, import_url_join2.default)(
        this.options.environment ?? RivetEnvironment.Production,
        `/cloud/games/${gameId}/namespaces/${namespaceId}/analytics/matchmaker/live`
      ),
      method: "GET",
      headers: {
        Authorization: await this._getAuthorizationHeader()
      },
      contentType: "application/json"
    });
    if (_response.ok) {
      return await cloud_exports2.games.namespaces.GetAnalyticsMatchmakerLiveResponse.parseOrThrow(
        _response.body,
        {
          unrecognizedObjectKeys: "passthrough",
          allowUnrecognizedUnionMembers: true,
          allowUnrecognizedEnumValues: true
        }
      );
    }
    if (_response.error.reason === "status-code") {
      switch (_response.error.statusCode) {
        case 500:
          throw new api_exports.InternalError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 429:
          throw new api_exports.RateLimitError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 403:
          throw new api_exports.ForbiddenError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 408:
          throw new api_exports.UnauthorizedError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 404:
          throw new api_exports.NotFoundError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 400:
          throw new api_exports.BadRequestError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        default:
          throw new RivetError({
            statusCode: _response.error.statusCode,
            body: _response.error.body
          });
      }
    }
    switch (_response.error.reason) {
      case "non-json":
        throw new RivetError({
          statusCode: _response.error.statusCode,
          body: _response.error.rawBody
        });
      case "timeout":
        throw new RivetTimeoutError();
      case "unknown":
        throw new RivetError({
          message: _response.error.errorMessage
        });
    }
  }
  async _getAuthorizationHeader() {
    const bearer = await Supplier.get(this.options.token);
    if (bearer != null) {
      return `Bearer ${bearer}`;
    }
    return void 0;
  }
};

// src/api/resources/cloud/resources/games/resources/namespaces/resources/logs/client/Client.ts
init_core();
var import_url_join3 = __toESM(require_url_join());
init_serialization();
var Logs = class {
  constructor(options) {
    this.options = options;
  }
  /**
   * Returns a list of lobbies for the given game namespace.
   * @throws {Rivet.InternalError}
   * @throws {Rivet.RateLimitError}
   * @throws {Rivet.ForbiddenError}
   * @throws {Rivet.UnauthorizedError}
   * @throws {Rivet.NotFoundError}
   * @throws {Rivet.BadRequestError}
   */
  async listNamespaceLobbies(gameId, namespaceId, request = {}) {
    const { beforeCreateTs } = request;
    const _queryParams = new URLSearchParams();
    if (beforeCreateTs != null) {
      _queryParams.append("before_create_ts", beforeCreateTs.toISOString());
    }
    const _response = await fetcher({
      url: (0, import_url_join3.default)(
        this.options.environment ?? RivetEnvironment.Production,
        `/cloud/games/${gameId}/namespaces/${namespaceId}/logs/lobbies`
      ),
      method: "GET",
      headers: {
        Authorization: await this._getAuthorizationHeader()
      },
      contentType: "application/json",
      queryParameters: _queryParams
    });
    if (_response.ok) {
      return await cloud_exports2.games.namespaces.ListNamespaceLobbiesResponse.parseOrThrow(_response.body, {
        unrecognizedObjectKeys: "passthrough",
        allowUnrecognizedUnionMembers: true,
        allowUnrecognizedEnumValues: true
      });
    }
    if (_response.error.reason === "status-code") {
      switch (_response.error.statusCode) {
        case 500:
          throw new api_exports.InternalError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 429:
          throw new api_exports.RateLimitError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 403:
          throw new api_exports.ForbiddenError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 408:
          throw new api_exports.UnauthorizedError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 404:
          throw new api_exports.NotFoundError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 400:
          throw new api_exports.BadRequestError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        default:
          throw new RivetError({
            statusCode: _response.error.statusCode,
            body: _response.error.body
          });
      }
    }
    switch (_response.error.reason) {
      case "non-json":
        throw new RivetError({
          statusCode: _response.error.statusCode,
          body: _response.error.rawBody
        });
      case "timeout":
        throw new RivetTimeoutError();
      case "unknown":
        throw new RivetError({
          message: _response.error.errorMessage
        });
    }
  }
  /**
   * Returns a lobby from the given game namespace.
   * @throws {Rivet.InternalError}
   * @throws {Rivet.RateLimitError}
   * @throws {Rivet.ForbiddenError}
   * @throws {Rivet.UnauthorizedError}
   * @throws {Rivet.NotFoundError}
   * @throws {Rivet.BadRequestError}
   */
  async getNamespaceLobby(gameId, namespaceId, lobbyId) {
    const _response = await fetcher({
      url: (0, import_url_join3.default)(
        this.options.environment ?? RivetEnvironment.Production,
        `/cloud/games/${gameId}/namespaces/${namespaceId}/logs/lobbies/${lobbyId}`
      ),
      method: "GET",
      headers: {
        Authorization: await this._getAuthorizationHeader()
      },
      contentType: "application/json"
    });
    if (_response.ok) {
      return await cloud_exports2.games.namespaces.GetNamespaceLobbyResponse.parseOrThrow(_response.body, {
        unrecognizedObjectKeys: "passthrough",
        allowUnrecognizedUnionMembers: true,
        allowUnrecognizedEnumValues: true
      });
    }
    if (_response.error.reason === "status-code") {
      switch (_response.error.statusCode) {
        case 500:
          throw new api_exports.InternalError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 429:
          throw new api_exports.RateLimitError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 403:
          throw new api_exports.ForbiddenError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 408:
          throw new api_exports.UnauthorizedError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 404:
          throw new api_exports.NotFoundError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 400:
          throw new api_exports.BadRequestError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        default:
          throw new RivetError({
            statusCode: _response.error.statusCode,
            body: _response.error.body
          });
      }
    }
    switch (_response.error.reason) {
      case "non-json":
        throw new RivetError({
          statusCode: _response.error.statusCode,
          body: _response.error.rawBody
        });
      case "timeout":
        throw new RivetTimeoutError();
      case "unknown":
        throw new RivetError({
          message: _response.error.errorMessage
        });
    }
  }
  async _getAuthorizationHeader() {
    const bearer = await Supplier.get(this.options.token);
    if (bearer != null) {
      return `Bearer ${bearer}`;
    }
    return void 0;
  }
};

// src/api/resources/cloud/resources/games/resources/namespaces/client/Client.ts
var Namespaces = class {
  constructor(options) {
    this.options = options;
  }
  /**
   * Creates a new namespace for the given game.
   * @throws {Rivet.InternalError}
   * @throws {Rivet.RateLimitError}
   * @throws {Rivet.ForbiddenError}
   * @throws {Rivet.UnauthorizedError}
   * @throws {Rivet.NotFoundError}
   * @throws {Rivet.BadRequestError}
   */
  async createGameNamespace(gameId, request) {
    const _response = await fetcher({
      url: (0, import_url_join4.default)(
        this.options.environment ?? RivetEnvironment.Production,
        `/cloud/games/${gameId}/namespaces`
      ),
      method: "POST",
      headers: {
        Authorization: await this._getAuthorizationHeader()
      },
      contentType: "application/json",
      body: await cloud_exports2.games.namespaces.CreateGameNamespaceRequest.jsonOrThrow(request, {
        unrecognizedObjectKeys: "strip"
      })
    });
    if (_response.ok) {
      return await cloud_exports2.games.namespaces.CreateGameNamespaceResponse.parseOrThrow(_response.body, {
        unrecognizedObjectKeys: "passthrough",
        allowUnrecognizedUnionMembers: true,
        allowUnrecognizedEnumValues: true
      });
    }
    if (_response.error.reason === "status-code") {
      switch (_response.error.statusCode) {
        case 500:
          throw new api_exports.InternalError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 429:
          throw new api_exports.RateLimitError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 403:
          throw new api_exports.ForbiddenError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 408:
          throw new api_exports.UnauthorizedError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 404:
          throw new api_exports.NotFoundError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 400:
          throw new api_exports.BadRequestError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        default:
          throw new RivetError({
            statusCode: _response.error.statusCode,
            body: _response.error.body
          });
      }
    }
    switch (_response.error.reason) {
      case "non-json":
        throw new RivetError({
          statusCode: _response.error.statusCode,
          body: _response.error.rawBody
        });
      case "timeout":
        throw new RivetTimeoutError();
      case "unknown":
        throw new RivetError({
          message: _response.error.errorMessage
        });
    }
  }
  /**
   * Validates information used to create a new game namespace.
   * @throws {Rivet.InternalError}
   * @throws {Rivet.RateLimitError}
   * @throws {Rivet.ForbiddenError}
   * @throws {Rivet.UnauthorizedError}
   * @throws {Rivet.NotFoundError}
   * @throws {Rivet.BadRequestError}
   */
  async validateGameNamespace(gameId, request) {
    const _response = await fetcher({
      url: (0, import_url_join4.default)(
        this.options.environment ?? RivetEnvironment.Production,
        `/cloud/games/${gameId}/namespaces/validate`
      ),
      method: "POST",
      headers: {
        Authorization: await this._getAuthorizationHeader()
      },
      contentType: "application/json",
      body: await cloud_exports2.games.namespaces.ValidateGameNamespaceRequest.jsonOrThrow(request, {
        unrecognizedObjectKeys: "strip"
      })
    });
    if (_response.ok) {
      return await cloud_exports2.games.namespaces.ValidateGameNamespaceResponse.parseOrThrow(_response.body, {
        unrecognizedObjectKeys: "passthrough",
        allowUnrecognizedUnionMembers: true,
        allowUnrecognizedEnumValues: true
      });
    }
    if (_response.error.reason === "status-code") {
      switch (_response.error.statusCode) {
        case 500:
          throw new api_exports.InternalError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 429:
          throw new api_exports.RateLimitError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 403:
          throw new api_exports.ForbiddenError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 408:
          throw new api_exports.UnauthorizedError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 404:
          throw new api_exports.NotFoundError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 400:
          throw new api_exports.BadRequestError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        default:
          throw new RivetError({
            statusCode: _response.error.statusCode,
            body: _response.error.body
          });
      }
    }
    switch (_response.error.reason) {
      case "non-json":
        throw new RivetError({
          statusCode: _response.error.statusCode,
          body: _response.error.rawBody
        });
      case "timeout":
        throw new RivetTimeoutError();
      case "unknown":
        throw new RivetError({
          message: _response.error.errorMessage
        });
    }
  }
  /**
   * Gets a game namespace by namespace ID.
   * @throws {Rivet.InternalError}
   * @throws {Rivet.RateLimitError}
   * @throws {Rivet.ForbiddenError}
   * @throws {Rivet.UnauthorizedError}
   * @throws {Rivet.NotFoundError}
   * @throws {Rivet.BadRequestError}
   */
  async getGameNamespaceById(gameId, namespaceId) {
    const _response = await fetcher({
      url: (0, import_url_join4.default)(
        this.options.environment ?? RivetEnvironment.Production,
        `/cloud/games/${gameId}/namespaces/${namespaceId}`
      ),
      method: "GET",
      headers: {
        Authorization: await this._getAuthorizationHeader()
      },
      contentType: "application/json"
    });
    if (_response.ok) {
      return await cloud_exports2.games.namespaces.GetGameNamespaceByIdResponse.parseOrThrow(_response.body, {
        unrecognizedObjectKeys: "passthrough",
        allowUnrecognizedUnionMembers: true,
        allowUnrecognizedEnumValues: true
      });
    }
    if (_response.error.reason === "status-code") {
      switch (_response.error.statusCode) {
        case 500:
          throw new api_exports.InternalError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 429:
          throw new api_exports.RateLimitError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 403:
          throw new api_exports.ForbiddenError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 408:
          throw new api_exports.UnauthorizedError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 404:
          throw new api_exports.NotFoundError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 400:
          throw new api_exports.BadRequestError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        default:
          throw new RivetError({
            statusCode: _response.error.statusCode,
            body: _response.error.body
          });
      }
    }
    switch (_response.error.reason) {
      case "non-json":
        throw new RivetError({
          statusCode: _response.error.statusCode,
          body: _response.error.rawBody
        });
      case "timeout":
        throw new RivetTimeoutError();
      case "unknown":
        throw new RivetError({
          message: _response.error.errorMessage
        });
    }
  }
  /**
   * Adds an authenticated user to the given game namespace.
   * @throws {Rivet.InternalError}
   * @throws {Rivet.RateLimitError}
   * @throws {Rivet.ForbiddenError}
   * @throws {Rivet.UnauthorizedError}
   * @throws {Rivet.NotFoundError}
   * @throws {Rivet.BadRequestError}
   */
  async updateNamespaceCdnAuthUser(gameId, namespaceId, request) {
    const _response = await fetcher({
      url: (0, import_url_join4.default)(
        this.options.environment ?? RivetEnvironment.Production,
        `/cloud/games/${gameId}/namespaces/${namespaceId}/auth-user`
      ),
      method: "POST",
      headers: {
        Authorization: await this._getAuthorizationHeader()
      },
      contentType: "application/json",
      body: await cloud_exports2.games.namespaces.UpdateNamespaceCdnAuthUserRequest.jsonOrThrow(request, {
        unrecognizedObjectKeys: "strip"
      })
    });
    if (_response.ok) {
      return;
    }
    if (_response.error.reason === "status-code") {
      switch (_response.error.statusCode) {
        case 500:
          throw new api_exports.InternalError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 429:
          throw new api_exports.RateLimitError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 403:
          throw new api_exports.ForbiddenError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 408:
          throw new api_exports.UnauthorizedError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 404:
          throw new api_exports.NotFoundError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 400:
          throw new api_exports.BadRequestError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        default:
          throw new RivetError({
            statusCode: _response.error.statusCode,
            body: _response.error.body
          });
      }
    }
    switch (_response.error.reason) {
      case "non-json":
        throw new RivetError({
          statusCode: _response.error.statusCode,
          body: _response.error.rawBody
        });
      case "timeout":
        throw new RivetTimeoutError();
      case "unknown":
        throw new RivetError({
          message: _response.error.errorMessage
        });
    }
  }
  /**
   * Removes an authenticated user from the given game namespace.
   * @throws {Rivet.InternalError}
   * @throws {Rivet.RateLimitError}
   * @throws {Rivet.ForbiddenError}
   * @throws {Rivet.UnauthorizedError}
   * @throws {Rivet.NotFoundError}
   * @throws {Rivet.BadRequestError}
   */
  async removeNamespaceCdnAuthUser(gameId, namespaceId, user) {
    const _response = await fetcher({
      url: (0, import_url_join4.default)(
        this.options.environment ?? RivetEnvironment.Production,
        `/cloud/games/${gameId}/namespaces/${namespaceId}/auth-user/${user}`
      ),
      method: "DELETE",
      headers: {
        Authorization: await this._getAuthorizationHeader()
      },
      contentType: "application/json"
    });
    if (_response.ok) {
      return;
    }
    if (_response.error.reason === "status-code") {
      switch (_response.error.statusCode) {
        case 500:
          throw new api_exports.InternalError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 429:
          throw new api_exports.RateLimitError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 403:
          throw new api_exports.ForbiddenError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 408:
          throw new api_exports.UnauthorizedError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 404:
          throw new api_exports.NotFoundError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 400:
          throw new api_exports.BadRequestError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        default:
          throw new RivetError({
            statusCode: _response.error.statusCode,
            body: _response.error.body
          });
      }
    }
    switch (_response.error.reason) {
      case "non-json":
        throw new RivetError({
          statusCode: _response.error.statusCode,
          body: _response.error.rawBody
        });
      case "timeout":
        throw new RivetTimeoutError();
      case "unknown":
        throw new RivetError({
          message: _response.error.errorMessage
        });
    }
  }
  /**
   * Updates the CDN authentication type of the given game namesapce.
   * @throws {Rivet.InternalError}
   * @throws {Rivet.RateLimitError}
   * @throws {Rivet.ForbiddenError}
   * @throws {Rivet.UnauthorizedError}
   * @throws {Rivet.NotFoundError}
   * @throws {Rivet.BadRequestError}
   */
  async setNamespaceCdnAuthType(gameId, namespaceId, request) {
    const _response = await fetcher({
      url: (0, import_url_join4.default)(
        this.options.environment ?? RivetEnvironment.Production,
        `/cloud/games/${gameId}/namespaces/${namespaceId}/cdn-auth`
      ),
      method: "PUT",
      headers: {
        Authorization: await this._getAuthorizationHeader()
      },
      contentType: "application/json",
      body: await cloud_exports2.games.namespaces.SetNamespaceCdnAuthTypeRequest.jsonOrThrow(request, {
        unrecognizedObjectKeys: "strip"
      })
    });
    if (_response.ok) {
      return;
    }
    if (_response.error.reason === "status-code") {
      switch (_response.error.statusCode) {
        case 500:
          throw new api_exports.InternalError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 429:
          throw new api_exports.RateLimitError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 403:
          throw new api_exports.ForbiddenError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 408:
          throw new api_exports.UnauthorizedError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 404:
          throw new api_exports.NotFoundError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 400:
          throw new api_exports.BadRequestError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        default:
          throw new RivetError({
            statusCode: _response.error.statusCode,
            body: _response.error.body
          });
      }
    }
    switch (_response.error.reason) {
      case "non-json":
        throw new RivetError({
          statusCode: _response.error.statusCode,
          body: _response.error.rawBody
        });
      case "timeout":
        throw new RivetTimeoutError();
      case "unknown":
        throw new RivetError({
          message: _response.error.errorMessage
        });
    }
  }
  /**
   * Toggles whether or not to allow authentication based on domain for the given game namesapce.
   * @throws {Rivet.InternalError}
   * @throws {Rivet.RateLimitError}
   * @throws {Rivet.ForbiddenError}
   * @throws {Rivet.UnauthorizedError}
   * @throws {Rivet.NotFoundError}
   * @throws {Rivet.BadRequestError}
   */
  async toggleNamespaceDomainPublicAuth(gameId, namespaceId, request) {
    const _response = await fetcher({
      url: (0, import_url_join4.default)(
        this.options.environment ?? RivetEnvironment.Production,
        `/cloud/games/${gameId}/namespaces/${namespaceId}/domain-public-auth`
      ),
      method: "PUT",
      headers: {
        Authorization: await this._getAuthorizationHeader()
      },
      contentType: "application/json",
      body: await cloud_exports2.games.namespaces.ToggleNamespaceDomainPublicAuthRequest.jsonOrThrow(request, {
        unrecognizedObjectKeys: "strip"
      })
    });
    if (_response.ok) {
      return;
    }
    if (_response.error.reason === "status-code") {
      switch (_response.error.statusCode) {
        case 500:
          throw new api_exports.InternalError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 429:
          throw new api_exports.RateLimitError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 403:
          throw new api_exports.ForbiddenError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 408:
          throw new api_exports.UnauthorizedError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 404:
          throw new api_exports.NotFoundError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 400:
          throw new api_exports.BadRequestError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        default:
          throw new RivetError({
            statusCode: _response.error.statusCode,
            body: _response.error.body
          });
      }
    }
    switch (_response.error.reason) {
      case "non-json":
        throw new RivetError({
          statusCode: _response.error.statusCode,
          body: _response.error.rawBody
        });
      case "timeout":
        throw new RivetTimeoutError();
      case "unknown":
        throw new RivetError({
          message: _response.error.errorMessage
        });
    }
  }
  /**
   * Adds a domain to the given game namespace.
   * @throws {Rivet.InternalError}
   * @throws {Rivet.RateLimitError}
   * @throws {Rivet.ForbiddenError}
   * @throws {Rivet.UnauthorizedError}
   * @throws {Rivet.NotFoundError}
   * @throws {Rivet.BadRequestError}
   */
  async addNamespaceDomain(gameId, namespaceId, request) {
    const _response = await fetcher({
      url: (0, import_url_join4.default)(
        this.options.environment ?? RivetEnvironment.Production,
        `/cloud/games/${gameId}/namespaces/${namespaceId}/domains`
      ),
      method: "POST",
      headers: {
        Authorization: await this._getAuthorizationHeader()
      },
      contentType: "application/json",
      body: await cloud_exports2.games.namespaces.AddNamespaceDomainRequest.jsonOrThrow(request, {
        unrecognizedObjectKeys: "strip"
      })
    });
    if (_response.ok) {
      return;
    }
    if (_response.error.reason === "status-code") {
      switch (_response.error.statusCode) {
        case 500:
          throw new api_exports.InternalError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 429:
          throw new api_exports.RateLimitError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 403:
          throw new api_exports.ForbiddenError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 408:
          throw new api_exports.UnauthorizedError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 404:
          throw new api_exports.NotFoundError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 400:
          throw new api_exports.BadRequestError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        default:
          throw new RivetError({
            statusCode: _response.error.statusCode,
            body: _response.error.body
          });
      }
    }
    switch (_response.error.reason) {
      case "non-json":
        throw new RivetError({
          statusCode: _response.error.statusCode,
          body: _response.error.rawBody
        });
      case "timeout":
        throw new RivetTimeoutError();
      case "unknown":
        throw new RivetError({
          message: _response.error.errorMessage
        });
    }
  }
  /**
   * Removes a domain from the given game namespace.
   * @throws {Rivet.InternalError}
   * @throws {Rivet.RateLimitError}
   * @throws {Rivet.ForbiddenError}
   * @throws {Rivet.UnauthorizedError}
   * @throws {Rivet.NotFoundError}
   * @throws {Rivet.BadRequestError}
   */
  async removeNamespaceDomain(gameId, namespaceId, domain) {
    const _response = await fetcher({
      url: (0, import_url_join4.default)(
        this.options.environment ?? RivetEnvironment.Production,
        `/cloud/games/${gameId}/namespaces/${namespaceId}/domains/${domain}`
      ),
      method: "DELETE",
      headers: {
        Authorization: await this._getAuthorizationHeader()
      },
      contentType: "application/json"
    });
    if (_response.ok) {
      return;
    }
    if (_response.error.reason === "status-code") {
      switch (_response.error.statusCode) {
        case 500:
          throw new api_exports.InternalError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 429:
          throw new api_exports.RateLimitError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 403:
          throw new api_exports.ForbiddenError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 408:
          throw new api_exports.UnauthorizedError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 404:
          throw new api_exports.NotFoundError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 400:
          throw new api_exports.BadRequestError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        default:
          throw new RivetError({
            statusCode: _response.error.statusCode,
            body: _response.error.body
          });
      }
    }
    switch (_response.error.reason) {
      case "non-json":
        throw new RivetError({
          statusCode: _response.error.statusCode,
          body: _response.error.rawBody
        });
      case "timeout":
        throw new RivetTimeoutError();
      case "unknown":
        throw new RivetError({
          message: _response.error.errorMessage
        });
    }
  }
  /**
   * Updates matchmaker config for the given game namespace.
   * @throws {Rivet.InternalError}
   * @throws {Rivet.RateLimitError}
   * @throws {Rivet.ForbiddenError}
   * @throws {Rivet.UnauthorizedError}
   * @throws {Rivet.NotFoundError}
   * @throws {Rivet.BadRequestError}
   */
  async updateGameNamespaceMatchmakerConfig(gameId, namespaceId, request) {
    const _response = await fetcher({
      url: (0, import_url_join4.default)(
        this.options.environment ?? RivetEnvironment.Production,
        `/cloud/games/${gameId}/namespaces/${namespaceId}/mm-config`
      ),
      method: "POST",
      headers: {
        Authorization: await this._getAuthorizationHeader()
      },
      contentType: "application/json",
      body: await cloud_exports2.games.namespaces.UpdateGameNamespaceMatchmakerConfigRequest.jsonOrThrow(
        request,
        { unrecognizedObjectKeys: "strip" }
      )
    });
    if (_response.ok) {
      return;
    }
    if (_response.error.reason === "status-code") {
      switch (_response.error.statusCode) {
        case 500:
          throw new api_exports.InternalError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 429:
          throw new api_exports.RateLimitError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 403:
          throw new api_exports.ForbiddenError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 408:
          throw new api_exports.UnauthorizedError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 404:
          throw new api_exports.NotFoundError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 400:
          throw new api_exports.BadRequestError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        default:
          throw new RivetError({
            statusCode: _response.error.statusCode,
            body: _response.error.body
          });
      }
    }
    switch (_response.error.reason) {
      case "non-json":
        throw new RivetError({
          statusCode: _response.error.statusCode,
          body: _response.error.rawBody
        });
      case "timeout":
        throw new RivetTimeoutError();
      case "unknown":
        throw new RivetError({
          message: _response.error.errorMessage
        });
    }
  }
  /**
   * Gets the version history for a given namespace.
   * @throws {Rivet.InternalError}
   * @throws {Rivet.RateLimitError}
   * @throws {Rivet.ForbiddenError}
   * @throws {Rivet.UnauthorizedError}
   * @throws {Rivet.NotFoundError}
   * @throws {Rivet.BadRequestError}
   */
  async getGameNamespaceVersionHistoryList(gameId, namespaceId, request = {}) {
    const { anchor, limit } = request;
    const _queryParams = new URLSearchParams();
    if (anchor != null) {
      _queryParams.append("anchor", anchor);
    }
    if (limit != null) {
      _queryParams.append("limit", limit.toString());
    }
    const _response = await fetcher({
      url: (0, import_url_join4.default)(
        this.options.environment ?? RivetEnvironment.Production,
        `/cloud/games/${gameId}/namespaces/${namespaceId}/version-history`
      ),
      method: "GET",
      headers: {
        Authorization: await this._getAuthorizationHeader()
      },
      contentType: "application/json",
      queryParameters: _queryParams
    });
    if (_response.ok) {
      return await cloud_exports2.games.namespaces.GetGameNamespaceVersionHistoryResponse.parseOrThrow(
        _response.body,
        {
          unrecognizedObjectKeys: "passthrough",
          allowUnrecognizedUnionMembers: true,
          allowUnrecognizedEnumValues: true
        }
      );
    }
    if (_response.error.reason === "status-code") {
      switch (_response.error.statusCode) {
        case 500:
          throw new api_exports.InternalError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 429:
          throw new api_exports.RateLimitError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 403:
          throw new api_exports.ForbiddenError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 408:
          throw new api_exports.UnauthorizedError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 404:
          throw new api_exports.NotFoundError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 400:
          throw new api_exports.BadRequestError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        default:
          throw new RivetError({
            statusCode: _response.error.statusCode,
            body: _response.error.body
          });
      }
    }
    switch (_response.error.reason) {
      case "non-json":
        throw new RivetError({
          statusCode: _response.error.statusCode,
          body: _response.error.rawBody
        });
      case "timeout":
        throw new RivetTimeoutError();
      case "unknown":
        throw new RivetError({
          message: _response.error.errorMessage
        });
    }
  }
  /**
   * Validates information used to update a game namespace's matchmaker config.
   * @throws {Rivet.InternalError}
   * @throws {Rivet.RateLimitError}
   * @throws {Rivet.ForbiddenError}
   * @throws {Rivet.UnauthorizedError}
   * @throws {Rivet.NotFoundError}
   * @throws {Rivet.BadRequestError}
   */
  async validateGameNamespaceMatchmakerConfig(gameId, namespaceId, request) {
    const _response = await fetcher({
      url: (0, import_url_join4.default)(
        this.options.environment ?? RivetEnvironment.Production,
        `/cloud/games/${gameId}/namespaces/${namespaceId}/mm-config/validate`
      ),
      method: "POST",
      headers: {
        Authorization: await this._getAuthorizationHeader()
      },
      contentType: "application/json",
      body: await cloud_exports2.games.namespaces.ValidateGameNamespaceMatchmakerConfigRequest.jsonOrThrow(
        request,
        { unrecognizedObjectKeys: "strip" }
      )
    });
    if (_response.ok) {
      return await cloud_exports2.games.namespaces.ValidateGameNamespaceMatchmakerConfigResponse.parseOrThrow(
        _response.body,
        {
          unrecognizedObjectKeys: "passthrough",
          allowUnrecognizedUnionMembers: true,
          allowUnrecognizedEnumValues: true
        }
      );
    }
    if (_response.error.reason === "status-code") {
      switch (_response.error.statusCode) {
        case 500:
          throw new api_exports.InternalError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 429:
          throw new api_exports.RateLimitError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 403:
          throw new api_exports.ForbiddenError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 408:
          throw new api_exports.UnauthorizedError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 404:
          throw new api_exports.NotFoundError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 400:
          throw new api_exports.BadRequestError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        default:
          throw new RivetError({
            statusCode: _response.error.statusCode,
            body: _response.error.body
          });
      }
    }
    switch (_response.error.reason) {
      case "non-json":
        throw new RivetError({
          statusCode: _response.error.statusCode,
          body: _response.error.rawBody
        });
      case "timeout":
        throw new RivetTimeoutError();
      case "unknown":
        throw new RivetError({
          message: _response.error.errorMessage
        });
    }
  }
  /**
   * Creates a development token for the given namespace.
   * @throws {Rivet.InternalError}
   * @throws {Rivet.RateLimitError}
   * @throws {Rivet.ForbiddenError}
   * @throws {Rivet.UnauthorizedError}
   * @throws {Rivet.NotFoundError}
   * @throws {Rivet.BadRequestError}
   */
  async createGameNamespaceTokenDevelopment(gameId, namespaceId, request) {
    const _response = await fetcher({
      url: (0, import_url_join4.default)(
        this.options.environment ?? RivetEnvironment.Production,
        `/cloud/games/${gameId}/namespaces/${namespaceId}/tokens/development`
      ),
      method: "POST",
      headers: {
        Authorization: await this._getAuthorizationHeader()
      },
      contentType: "application/json",
      body: await cloud_exports2.games.namespaces.CreateGameNamespaceTokenDevelopmentRequest.jsonOrThrow(
        request,
        { unrecognizedObjectKeys: "strip" }
      )
    });
    if (_response.ok) {
      return await cloud_exports2.games.namespaces.CreateGameNamespaceTokenDevelopmentResponse.parseOrThrow(
        _response.body,
        {
          unrecognizedObjectKeys: "passthrough",
          allowUnrecognizedUnionMembers: true,
          allowUnrecognizedEnumValues: true
        }
      );
    }
    if (_response.error.reason === "status-code") {
      switch (_response.error.statusCode) {
        case 500:
          throw new api_exports.InternalError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 429:
          throw new api_exports.RateLimitError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 403:
          throw new api_exports.ForbiddenError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 408:
          throw new api_exports.UnauthorizedError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 404:
          throw new api_exports.NotFoundError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 400:
          throw new api_exports.BadRequestError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        default:
          throw new RivetError({
            statusCode: _response.error.statusCode,
            body: _response.error.body
          });
      }
    }
    switch (_response.error.reason) {
      case "non-json":
        throw new RivetError({
          statusCode: _response.error.statusCode,
          body: _response.error.rawBody
        });
      case "timeout":
        throw new RivetTimeoutError();
      case "unknown":
        throw new RivetError({
          message: _response.error.errorMessage
        });
    }
  }
  /**
   * Validates information used to create a new game namespace development token.
   * @throws {Rivet.InternalError}
   * @throws {Rivet.RateLimitError}
   * @throws {Rivet.ForbiddenError}
   * @throws {Rivet.UnauthorizedError}
   * @throws {Rivet.NotFoundError}
   * @throws {Rivet.BadRequestError}
   */
  async validateGameNamespaceTokenDevelopment(gameId, namespaceId, request) {
    const _response = await fetcher({
      url: (0, import_url_join4.default)(
        this.options.environment ?? RivetEnvironment.Production,
        `/cloud/games/${gameId}/namespaces/${namespaceId}/tokens/development/validate`
      ),
      method: "POST",
      headers: {
        Authorization: await this._getAuthorizationHeader()
      },
      contentType: "application/json",
      body: await cloud_exports2.games.namespaces.ValidateGameNamespaceTokenDevelopmentRequest.jsonOrThrow(
        request,
        { unrecognizedObjectKeys: "strip" }
      )
    });
    if (_response.ok) {
      return await cloud_exports2.games.namespaces.ValidateGameNamespaceTokenDevelopmentResponse.parseOrThrow(
        _response.body,
        {
          unrecognizedObjectKeys: "passthrough",
          allowUnrecognizedUnionMembers: true,
          allowUnrecognizedEnumValues: true
        }
      );
    }
    if (_response.error.reason === "status-code") {
      switch (_response.error.statusCode) {
        case 500:
          throw new api_exports.InternalError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 429:
          throw new api_exports.RateLimitError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 403:
          throw new api_exports.ForbiddenError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 408:
          throw new api_exports.UnauthorizedError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 404:
          throw new api_exports.NotFoundError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 400:
          throw new api_exports.BadRequestError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        default:
          throw new RivetError({
            statusCode: _response.error.statusCode,
            body: _response.error.body
          });
      }
    }
    switch (_response.error.reason) {
      case "non-json":
        throw new RivetError({
          statusCode: _response.error.statusCode,
          body: _response.error.rawBody
        });
      case "timeout":
        throw new RivetTimeoutError();
      case "unknown":
        throw new RivetError({
          message: _response.error.errorMessage
        });
    }
  }
  /**
   * Creates a public token for the given namespace.
   * @throws {Rivet.InternalError}
   * @throws {Rivet.RateLimitError}
   * @throws {Rivet.ForbiddenError}
   * @throws {Rivet.UnauthorizedError}
   * @throws {Rivet.NotFoundError}
   * @throws {Rivet.BadRequestError}
   */
  async createGameNamespaceTokenPublic(gameId, namespaceId) {
    const _response = await fetcher({
      url: (0, import_url_join4.default)(
        this.options.environment ?? RivetEnvironment.Production,
        `/cloud/games/${gameId}/namespaces/${namespaceId}/tokens/public`
      ),
      method: "POST",
      headers: {
        Authorization: await this._getAuthorizationHeader()
      },
      contentType: "application/json"
    });
    if (_response.ok) {
      return await cloud_exports2.games.namespaces.CreateGameNamespaceTokenPublicResponse.parseOrThrow(
        _response.body,
        {
          unrecognizedObjectKeys: "passthrough",
          allowUnrecognizedUnionMembers: true,
          allowUnrecognizedEnumValues: true
        }
      );
    }
    if (_response.error.reason === "status-code") {
      switch (_response.error.statusCode) {
        case 500:
          throw new api_exports.InternalError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 429:
          throw new api_exports.RateLimitError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 403:
          throw new api_exports.ForbiddenError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 408:
          throw new api_exports.UnauthorizedError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 404:
          throw new api_exports.NotFoundError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 400:
          throw new api_exports.BadRequestError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        default:
          throw new RivetError({
            statusCode: _response.error.statusCode,
            body: _response.error.body
          });
      }
    }
    switch (_response.error.reason) {
      case "non-json":
        throw new RivetError({
          statusCode: _response.error.statusCode,
          body: _response.error.rawBody
        });
      case "timeout":
        throw new RivetTimeoutError();
      case "unknown":
        throw new RivetError({
          message: _response.error.errorMessage
        });
    }
  }
  /**
   * Updates the version of a game namespace.
   * @throws {Rivet.InternalError}
   * @throws {Rivet.RateLimitError}
   * @throws {Rivet.ForbiddenError}
   * @throws {Rivet.UnauthorizedError}
   * @throws {Rivet.NotFoundError}
   * @throws {Rivet.BadRequestError}
   */
  async updateGameNamespaceVersion(gameId, namespaceId, request) {
    const _response = await fetcher({
      url: (0, import_url_join4.default)(
        this.options.environment ?? RivetEnvironment.Production,
        `/cloud/games/${gameId}/namespaces/${namespaceId}/version`
      ),
      method: "PUT",
      headers: {
        Authorization: await this._getAuthorizationHeader()
      },
      contentType: "application/json",
      body: await cloud_exports2.games.namespaces.UpdateGameNamespaceVersionRequest.jsonOrThrow(request, {
        unrecognizedObjectKeys: "strip"
      })
    });
    if (_response.ok) {
      return;
    }
    if (_response.error.reason === "status-code") {
      switch (_response.error.statusCode) {
        case 500:
          throw new api_exports.InternalError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 429:
          throw new api_exports.RateLimitError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 403:
          throw new api_exports.ForbiddenError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 408:
          throw new api_exports.UnauthorizedError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 404:
          throw new api_exports.NotFoundError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 400:
          throw new api_exports.BadRequestError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        default:
          throw new RivetError({
            statusCode: _response.error.statusCode,
            body: _response.error.body
          });
      }
    }
    switch (_response.error.reason) {
      case "non-json":
        throw new RivetError({
          statusCode: _response.error.statusCode,
          body: _response.error.rawBody
        });
      case "timeout":
        throw new RivetTimeoutError();
      case "unknown":
        throw new RivetError({
          message: _response.error.errorMessage
        });
    }
  }
  _analytics;
  get analytics() {
    return this._analytics ?? (this._analytics = new Analytics(this.options));
  }
  _logs;
  get logs() {
    return this._logs ?? (this._logs = new Logs(this.options));
  }
  async _getAuthorizationHeader() {
    const bearer = await Supplier.get(this.options.token);
    if (bearer != null) {
      return `Bearer ${bearer}`;
    }
    return void 0;
  }
};

// src/api/resources/cloud/resources/games/resources/avatars/client/Client.ts
init_core();
var import_url_join5 = __toESM(require_url_join());
init_serialization();
var Avatars = class {
  constructor(options) {
    this.options = options;
  }
  /**
   * Lists custom avatars for the given game.
   * @throws {Rivet.InternalError}
   * @throws {Rivet.RateLimitError}
   * @throws {Rivet.ForbiddenError}
   * @throws {Rivet.UnauthorizedError}
   * @throws {Rivet.NotFoundError}
   * @throws {Rivet.BadRequestError}
   */
  async listGameCustomAvatars(gameId) {
    const _response = await fetcher({
      url: (0, import_url_join5.default)(
        this.options.environment ?? RivetEnvironment.Production,
        `/cloud/games/${gameId}/avatars`
      ),
      method: "GET",
      headers: {
        Authorization: await this._getAuthorizationHeader()
      },
      contentType: "application/json"
    });
    if (_response.ok) {
      return await cloud_exports2.games.ListGameCustomAvatarsResponse.parseOrThrow(_response.body, {
        unrecognizedObjectKeys: "passthrough",
        allowUnrecognizedUnionMembers: true,
        allowUnrecognizedEnumValues: true
      });
    }
    if (_response.error.reason === "status-code") {
      switch (_response.error.statusCode) {
        case 500:
          throw new api_exports.InternalError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 429:
          throw new api_exports.RateLimitError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 403:
          throw new api_exports.ForbiddenError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 408:
          throw new api_exports.UnauthorizedError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 404:
          throw new api_exports.NotFoundError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 400:
          throw new api_exports.BadRequestError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        default:
          throw new RivetError({
            statusCode: _response.error.statusCode,
            body: _response.error.body
          });
      }
    }
    switch (_response.error.reason) {
      case "non-json":
        throw new RivetError({
          statusCode: _response.error.statusCode,
          body: _response.error.rawBody
        });
      case "timeout":
        throw new RivetTimeoutError();
      case "unknown":
        throw new RivetError({
          message: _response.error.errorMessage
        });
    }
  }
  /**
   * Prepares a custom avatar image upload.
   * Complete upload with `rivet.api.cloud#CompleteCustomAvatarUpload`.
   * @throws {Rivet.InternalError}
   * @throws {Rivet.RateLimitError}
   * @throws {Rivet.ForbiddenError}
   * @throws {Rivet.UnauthorizedError}
   * @throws {Rivet.NotFoundError}
   * @throws {Rivet.BadRequestError}
   */
  async prepareCustomAvatarUpload(gameId, request) {
    const _response = await fetcher({
      url: (0, import_url_join5.default)(
        this.options.environment ?? RivetEnvironment.Production,
        `/cloud/games/${gameId}/prepare`
      ),
      method: "POST",
      headers: {
        Authorization: await this._getAuthorizationHeader()
      },
      contentType: "application/json",
      body: await cloud_exports2.games.PrepareCustomAvatarUploadRequest.jsonOrThrow(request, {
        unrecognizedObjectKeys: "strip"
      })
    });
    if (_response.ok) {
      return await cloud_exports2.games.PrepareCustomAvatarUploadResponse.parseOrThrow(_response.body, {
        unrecognizedObjectKeys: "passthrough",
        allowUnrecognizedUnionMembers: true,
        allowUnrecognizedEnumValues: true
      });
    }
    if (_response.error.reason === "status-code") {
      switch (_response.error.statusCode) {
        case 500:
          throw new api_exports.InternalError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 429:
          throw new api_exports.RateLimitError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 403:
          throw new api_exports.ForbiddenError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 408:
          throw new api_exports.UnauthorizedError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 404:
          throw new api_exports.NotFoundError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 400:
          throw new api_exports.BadRequestError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        default:
          throw new RivetError({
            statusCode: _response.error.statusCode,
            body: _response.error.body
          });
      }
    }
    switch (_response.error.reason) {
      case "non-json":
        throw new RivetError({
          statusCode: _response.error.statusCode,
          body: _response.error.rawBody
        });
      case "timeout":
        throw new RivetTimeoutError();
      case "unknown":
        throw new RivetError({
          message: _response.error.errorMessage
        });
    }
  }
  /**
   * Completes a custom avatar image upload. Must be called after the file upload process completes.
   * @throws {Rivet.InternalError}
   * @throws {Rivet.RateLimitError}
   * @throws {Rivet.ForbiddenError}
   * @throws {Rivet.UnauthorizedError}
   * @throws {Rivet.NotFoundError}
   * @throws {Rivet.BadRequestError}
   */
  async completeCustomAvatarUpload(gameId, uploadId) {
    const _response = await fetcher({
      url: (0, import_url_join5.default)(
        this.options.environment ?? RivetEnvironment.Production,
        `/cloud/games/${gameId}/avatar-upload/${uploadId}/complete`
      ),
      method: "POST",
      headers: {
        Authorization: await this._getAuthorizationHeader()
      },
      contentType: "application/json"
    });
    if (_response.ok) {
      return;
    }
    if (_response.error.reason === "status-code") {
      switch (_response.error.statusCode) {
        case 500:
          throw new api_exports.InternalError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 429:
          throw new api_exports.RateLimitError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 403:
          throw new api_exports.ForbiddenError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 408:
          throw new api_exports.UnauthorizedError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 404:
          throw new api_exports.NotFoundError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 400:
          throw new api_exports.BadRequestError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        default:
          throw new RivetError({
            statusCode: _response.error.statusCode,
            body: _response.error.body
          });
      }
    }
    switch (_response.error.reason) {
      case "non-json":
        throw new RivetError({
          statusCode: _response.error.statusCode,
          body: _response.error.rawBody
        });
      case "timeout":
        throw new RivetTimeoutError();
      case "unknown":
        throw new RivetError({
          message: _response.error.errorMessage
        });
    }
  }
  async _getAuthorizationHeader() {
    const bearer = await Supplier.get(this.options.token);
    if (bearer != null) {
      return `Bearer ${bearer}`;
    }
    return void 0;
  }
};

// src/api/resources/cloud/resources/games/resources/builds/client/Client.ts
init_core();
var import_url_join6 = __toESM(require_url_join());
init_serialization();
var Builds = class {
  constructor(options) {
    this.options = options;
  }
  /**
   * Lists game builds for the given game.
   * @throws {Rivet.InternalError}
   * @throws {Rivet.RateLimitError}
   * @throws {Rivet.ForbiddenError}
   * @throws {Rivet.UnauthorizedError}
   * @throws {Rivet.NotFoundError}
   * @throws {Rivet.BadRequestError}
   */
  async listGameBuilds(gameId) {
    const _response = await fetcher({
      url: (0, import_url_join6.default)(
        this.options.environment ?? RivetEnvironment.Production,
        `/cloud/games/${gameId}/builds`
      ),
      method: "GET",
      headers: {
        Authorization: await this._getAuthorizationHeader()
      },
      contentType: "application/json"
    });
    if (_response.ok) {
      return await cloud_exports2.games.ListGameBuildsResponse.parseOrThrow(_response.body, {
        unrecognizedObjectKeys: "passthrough",
        allowUnrecognizedUnionMembers: true,
        allowUnrecognizedEnumValues: true
      });
    }
    if (_response.error.reason === "status-code") {
      switch (_response.error.statusCode) {
        case 500:
          throw new api_exports.InternalError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 429:
          throw new api_exports.RateLimitError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 403:
          throw new api_exports.ForbiddenError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 408:
          throw new api_exports.UnauthorizedError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 404:
          throw new api_exports.NotFoundError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 400:
          throw new api_exports.BadRequestError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        default:
          throw new RivetError({
            statusCode: _response.error.statusCode,
            body: _response.error.body
          });
      }
    }
    switch (_response.error.reason) {
      case "non-json":
        throw new RivetError({
          statusCode: _response.error.statusCode,
          body: _response.error.rawBody
        });
      case "timeout":
        throw new RivetTimeoutError();
      case "unknown":
        throw new RivetError({
          message: _response.error.errorMessage
        });
    }
  }
  /**
   * Creates a new game build for the given game.
   * @throws {Rivet.InternalError}
   * @throws {Rivet.RateLimitError}
   * @throws {Rivet.ForbiddenError}
   * @throws {Rivet.UnauthorizedError}
   * @throws {Rivet.NotFoundError}
   * @throws {Rivet.BadRequestError}
   */
  async createGameBuild(gameId, request) {
    const _response = await fetcher({
      url: (0, import_url_join6.default)(
        this.options.environment ?? RivetEnvironment.Production,
        `/cloud/games/${gameId}/builds`
      ),
      method: "POST",
      headers: {
        Authorization: await this._getAuthorizationHeader()
      },
      contentType: "application/json",
      body: await cloud_exports2.games.CreateGameBuildRequest.jsonOrThrow(request, {
        unrecognizedObjectKeys: "strip"
      })
    });
    if (_response.ok) {
      return await cloud_exports2.games.CreateGameBuildResponse.parseOrThrow(_response.body, {
        unrecognizedObjectKeys: "passthrough",
        allowUnrecognizedUnionMembers: true,
        allowUnrecognizedEnumValues: true
      });
    }
    if (_response.error.reason === "status-code") {
      switch (_response.error.statusCode) {
        case 500:
          throw new api_exports.InternalError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 429:
          throw new api_exports.RateLimitError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 403:
          throw new api_exports.ForbiddenError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 408:
          throw new api_exports.UnauthorizedError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 404:
          throw new api_exports.NotFoundError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 400:
          throw new api_exports.BadRequestError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        default:
          throw new RivetError({
            statusCode: _response.error.statusCode,
            body: _response.error.body
          });
      }
    }
    switch (_response.error.reason) {
      case "non-json":
        throw new RivetError({
          statusCode: _response.error.statusCode,
          body: _response.error.rawBody
        });
      case "timeout":
        throw new RivetTimeoutError();
      case "unknown":
        throw new RivetError({
          message: _response.error.errorMessage
        });
    }
  }
  async _getAuthorizationHeader() {
    const bearer = await Supplier.get(this.options.token);
    if (bearer != null) {
      return `Bearer ${bearer}`;
    }
    return void 0;
  }
};

// src/api/resources/cloud/resources/games/resources/cdn/client/Client.ts
init_core();
var import_url_join7 = __toESM(require_url_join());
init_serialization();
var Cdn = class {
  constructor(options) {
    this.options = options;
  }
  /**
   * Lists CDN sites for a game.
   * @throws {Rivet.InternalError}
   * @throws {Rivet.RateLimitError}
   * @throws {Rivet.ForbiddenError}
   * @throws {Rivet.UnauthorizedError}
   * @throws {Rivet.NotFoundError}
   * @throws {Rivet.BadRequestError}
   */
  async listGameCdnSites(gameId) {
    const _response = await fetcher({
      url: (0, import_url_join7.default)(
        this.options.environment ?? RivetEnvironment.Production,
        `/cloud/games/${gameId}/cdn/sites`
      ),
      method: "GET",
      headers: {
        Authorization: await this._getAuthorizationHeader()
      },
      contentType: "application/json"
    });
    if (_response.ok) {
      return await cloud_exports2.games.ListGameCdnSitesResponse.parseOrThrow(_response.body, {
        unrecognizedObjectKeys: "passthrough",
        allowUnrecognizedUnionMembers: true,
        allowUnrecognizedEnumValues: true
      });
    }
    if (_response.error.reason === "status-code") {
      switch (_response.error.statusCode) {
        case 500:
          throw new api_exports.InternalError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 429:
          throw new api_exports.RateLimitError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 403:
          throw new api_exports.ForbiddenError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 408:
          throw new api_exports.UnauthorizedError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 404:
          throw new api_exports.NotFoundError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 400:
          throw new api_exports.BadRequestError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        default:
          throw new RivetError({
            statusCode: _response.error.statusCode,
            body: _response.error.body
          });
      }
    }
    switch (_response.error.reason) {
      case "non-json":
        throw new RivetError({
          statusCode: _response.error.statusCode,
          body: _response.error.rawBody
        });
      case "timeout":
        throw new RivetTimeoutError();
      case "unknown":
        throw new RivetError({
          message: _response.error.errorMessage
        });
    }
  }
  /**
   * Creates a new CDN site for the given game.
   * @throws {Rivet.InternalError}
   * @throws {Rivet.RateLimitError}
   * @throws {Rivet.ForbiddenError}
   * @throws {Rivet.UnauthorizedError}
   * @throws {Rivet.NotFoundError}
   * @throws {Rivet.BadRequestError}
   */
  async createGameCdnSite(gameId, request) {
    const _response = await fetcher({
      url: (0, import_url_join7.default)(
        this.options.environment ?? RivetEnvironment.Production,
        `/cloud/games/${gameId}/cdn/sites`
      ),
      method: "POST",
      headers: {
        Authorization: await this._getAuthorizationHeader()
      },
      contentType: "application/json",
      body: await cloud_exports2.games.CreateGameCdnSiteRequest.jsonOrThrow(request, {
        unrecognizedObjectKeys: "strip"
      })
    });
    if (_response.ok) {
      return await cloud_exports2.games.CreateGameCdnSiteResponse.parseOrThrow(_response.body, {
        unrecognizedObjectKeys: "passthrough",
        allowUnrecognizedUnionMembers: true,
        allowUnrecognizedEnumValues: true
      });
    }
    if (_response.error.reason === "status-code") {
      switch (_response.error.statusCode) {
        case 500:
          throw new api_exports.InternalError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 429:
          throw new api_exports.RateLimitError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 403:
          throw new api_exports.ForbiddenError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 408:
          throw new api_exports.UnauthorizedError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 404:
          throw new api_exports.NotFoundError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 400:
          throw new api_exports.BadRequestError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        default:
          throw new RivetError({
            statusCode: _response.error.statusCode,
            body: _response.error.body
          });
      }
    }
    switch (_response.error.reason) {
      case "non-json":
        throw new RivetError({
          statusCode: _response.error.statusCode,
          body: _response.error.rawBody
        });
      case "timeout":
        throw new RivetTimeoutError();
      case "unknown":
        throw new RivetError({
          message: _response.error.errorMessage
        });
    }
  }
  async _getAuthorizationHeader() {
    const bearer = await Supplier.get(this.options.token);
    if (bearer != null) {
      return `Bearer ${bearer}`;
    }
    return void 0;
  }
};

// src/api/resources/cloud/resources/games/resources/games/client/Client.ts
init_core();
var import_url_join8 = __toESM(require_url_join());
init_serialization();
var Games = class {
  constructor(options) {
    this.options = options;
  }
  /**
   * Returns a list of games in which the current identity is a group member of its development team.
   * @throws {Rivet.InternalError}
   * @throws {Rivet.RateLimitError}
   * @throws {Rivet.ForbiddenError}
   * @throws {Rivet.UnauthorizedError}
   * @throws {Rivet.NotFoundError}
   * @throws {Rivet.BadRequestError}
   */
  async getGames(request = {}) {
    const { watchIndex } = request;
    const _queryParams = new URLSearchParams();
    if (watchIndex != null) {
      _queryParams.append("watch_index", watchIndex);
    }
    const _response = await fetcher({
      url: (0, import_url_join8.default)(this.options.environment ?? RivetEnvironment.Production, "/cloud/games"),
      method: "GET",
      headers: {
        Authorization: await this._getAuthorizationHeader()
      },
      contentType: "application/json",
      queryParameters: _queryParams
    });
    if (_response.ok) {
      return await cloud_exports2.games.GetGamesResponse.parseOrThrow(_response.body, {
        unrecognizedObjectKeys: "passthrough",
        allowUnrecognizedUnionMembers: true,
        allowUnrecognizedEnumValues: true
      });
    }
    if (_response.error.reason === "status-code") {
      switch (_response.error.statusCode) {
        case 500:
          throw new api_exports.InternalError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 429:
          throw new api_exports.RateLimitError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 403:
          throw new api_exports.ForbiddenError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 408:
          throw new api_exports.UnauthorizedError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 404:
          throw new api_exports.NotFoundError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 400:
          throw new api_exports.BadRequestError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        default:
          throw new RivetError({
            statusCode: _response.error.statusCode,
            body: _response.error.body
          });
      }
    }
    switch (_response.error.reason) {
      case "non-json":
        throw new RivetError({
          statusCode: _response.error.statusCode,
          body: _response.error.rawBody
        });
      case "timeout":
        throw new RivetTimeoutError();
      case "unknown":
        throw new RivetError({
          message: _response.error.errorMessage
        });
    }
  }
  /**
   * Creates a new game.
   * @throws {Rivet.InternalError}
   * @throws {Rivet.RateLimitError}
   * @throws {Rivet.ForbiddenError}
   * @throws {Rivet.UnauthorizedError}
   * @throws {Rivet.NotFoundError}
   * @throws {Rivet.BadRequestError}
   */
  async createGame(request) {
    const _response = await fetcher({
      url: (0, import_url_join8.default)(this.options.environment ?? RivetEnvironment.Production, "/cloud/games"),
      method: "POST",
      headers: {
        Authorization: await this._getAuthorizationHeader()
      },
      contentType: "application/json",
      body: await cloud_exports2.games.CreateGameRequest.jsonOrThrow(request, {
        unrecognizedObjectKeys: "strip"
      })
    });
    if (_response.ok) {
      return await cloud_exports2.games.CreateGameResponse.parseOrThrow(_response.body, {
        unrecognizedObjectKeys: "passthrough",
        allowUnrecognizedUnionMembers: true,
        allowUnrecognizedEnumValues: true
      });
    }
    if (_response.error.reason === "status-code") {
      switch (_response.error.statusCode) {
        case 500:
          throw new api_exports.InternalError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 429:
          throw new api_exports.RateLimitError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 403:
          throw new api_exports.ForbiddenError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 408:
          throw new api_exports.UnauthorizedError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 404:
          throw new api_exports.NotFoundError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 400:
          throw new api_exports.BadRequestError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        default:
          throw new RivetError({
            statusCode: _response.error.statusCode,
            body: _response.error.body
          });
      }
    }
    switch (_response.error.reason) {
      case "non-json":
        throw new RivetError({
          statusCode: _response.error.statusCode,
          body: _response.error.rawBody
        });
      case "timeout":
        throw new RivetTimeoutError();
      case "unknown":
        throw new RivetError({
          message: _response.error.errorMessage
        });
    }
  }
  /**
   * Validates information used to create a new game.
   * @throws {Rivet.InternalError}
   * @throws {Rivet.RateLimitError}
   * @throws {Rivet.ForbiddenError}
   * @throws {Rivet.UnauthorizedError}
   * @throws {Rivet.NotFoundError}
   * @throws {Rivet.BadRequestError}
   */
  async validateGame(request) {
    const _response = await fetcher({
      url: (0, import_url_join8.default)(this.options.environment ?? RivetEnvironment.Production, "/cloud/games/validate"),
      method: "POST",
      headers: {
        Authorization: await this._getAuthorizationHeader()
      },
      contentType: "application/json",
      body: await cloud_exports2.games.ValidateGameRequest.jsonOrThrow(request, {
        unrecognizedObjectKeys: "strip"
      })
    });
    if (_response.ok) {
      return await cloud_exports2.games.ValidateGameResponse.parseOrThrow(_response.body, {
        unrecognizedObjectKeys: "passthrough",
        allowUnrecognizedUnionMembers: true,
        allowUnrecognizedEnumValues: true
      });
    }
    if (_response.error.reason === "status-code") {
      switch (_response.error.statusCode) {
        case 500:
          throw new api_exports.InternalError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 429:
          throw new api_exports.RateLimitError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 403:
          throw new api_exports.ForbiddenError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 408:
          throw new api_exports.UnauthorizedError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 404:
          throw new api_exports.NotFoundError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 400:
          throw new api_exports.BadRequestError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        default:
          throw new RivetError({
            statusCode: _response.error.statusCode,
            body: _response.error.body
          });
      }
    }
    switch (_response.error.reason) {
      case "non-json":
        throw new RivetError({
          statusCode: _response.error.statusCode,
          body: _response.error.rawBody
        });
      case "timeout":
        throw new RivetTimeoutError();
      case "unknown":
        throw new RivetError({
          message: _response.error.errorMessage
        });
    }
  }
  /**
   * Returns a game by its game id.
   * @throws {Rivet.InternalError}
   * @throws {Rivet.RateLimitError}
   * @throws {Rivet.ForbiddenError}
   * @throws {Rivet.UnauthorizedError}
   * @throws {Rivet.NotFoundError}
   * @throws {Rivet.BadRequestError}
   */
  async getGameById(gameId, request = {}) {
    const { watchIndex } = request;
    const _queryParams = new URLSearchParams();
    if (watchIndex != null) {
      _queryParams.append("watch_index", watchIndex);
    }
    const _response = await fetcher({
      url: (0, import_url_join8.default)(
        this.options.environment ?? RivetEnvironment.Production,
        `/cloud/games/${gameId}`
      ),
      method: "GET",
      headers: {
        Authorization: await this._getAuthorizationHeader()
      },
      contentType: "application/json",
      queryParameters: _queryParams
    });
    if (_response.ok) {
      return await cloud_exports2.games.GetGameByIdResponse.parseOrThrow(_response.body, {
        unrecognizedObjectKeys: "passthrough",
        allowUnrecognizedUnionMembers: true,
        allowUnrecognizedEnumValues: true
      });
    }
    if (_response.error.reason === "status-code") {
      switch (_response.error.statusCode) {
        case 500:
          throw new api_exports.InternalError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 429:
          throw new api_exports.RateLimitError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 403:
          throw new api_exports.ForbiddenError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 408:
          throw new api_exports.UnauthorizedError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 404:
          throw new api_exports.NotFoundError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 400:
          throw new api_exports.BadRequestError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        default:
          throw new RivetError({
            statusCode: _response.error.statusCode,
            body: _response.error.body
          });
      }
    }
    switch (_response.error.reason) {
      case "non-json":
        throw new RivetError({
          statusCode: _response.error.statusCode,
          body: _response.error.rawBody
        });
      case "timeout":
        throw new RivetTimeoutError();
      case "unknown":
        throw new RivetError({
          message: _response.error.errorMessage
        });
    }
  }
  /**
   * Prepares a game banner image upload.
   * @throws {Rivet.InternalError}
   * @throws {Rivet.RateLimitError}
   * @throws {Rivet.ForbiddenError}
   * @throws {Rivet.UnauthorizedError}
   * @throws {Rivet.NotFoundError}
   * @throws {Rivet.BadRequestError}
   */
  async gameBannerUploadPrepare(gameId, request) {
    const _response = await fetcher({
      url: (0, import_url_join8.default)(
        this.options.environment ?? RivetEnvironment.Production,
        `/cloud/games/${gameId}/banner-upload/prepare`
      ),
      method: "POST",
      headers: {
        Authorization: await this._getAuthorizationHeader()
      },
      contentType: "application/json",
      body: await cloud_exports2.games.GameBannerUploadPrepareRequest.jsonOrThrow(request, {
        unrecognizedObjectKeys: "strip"
      })
    });
    if (_response.ok) {
      return await cloud_exports2.games.GameBannerUploadPrepareResponse.parseOrThrow(_response.body, {
        unrecognizedObjectKeys: "passthrough",
        allowUnrecognizedUnionMembers: true,
        allowUnrecognizedEnumValues: true
      });
    }
    if (_response.error.reason === "status-code") {
      switch (_response.error.statusCode) {
        case 500:
          throw new api_exports.InternalError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 429:
          throw new api_exports.RateLimitError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 403:
          throw new api_exports.ForbiddenError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 408:
          throw new api_exports.UnauthorizedError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 404:
          throw new api_exports.NotFoundError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 400:
          throw new api_exports.BadRequestError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        default:
          throw new RivetError({
            statusCode: _response.error.statusCode,
            body: _response.error.body
          });
      }
    }
    switch (_response.error.reason) {
      case "non-json":
        throw new RivetError({
          statusCode: _response.error.statusCode,
          body: _response.error.rawBody
        });
      case "timeout":
        throw new RivetTimeoutError();
      case "unknown":
        throw new RivetError({
          message: _response.error.errorMessage
        });
    }
  }
  /**
   * Completes an game banner image upload. Must be called after the file upload process completes.
   * @throws {Rivet.InternalError}
   * @throws {Rivet.RateLimitError}
   * @throws {Rivet.ForbiddenError}
   * @throws {Rivet.UnauthorizedError}
   * @throws {Rivet.NotFoundError}
   * @throws {Rivet.BadRequestError}
   */
  async gameBannerUploadComplete(gameId, uploadId) {
    const _response = await fetcher({
      url: (0, import_url_join8.default)(
        this.options.environment ?? RivetEnvironment.Production,
        `/cloud/games/${gameId}/banner-upload/${uploadId}/complete`
      ),
      method: "POST",
      headers: {
        Authorization: await this._getAuthorizationHeader()
      },
      contentType: "application/json"
    });
    if (_response.ok) {
      return;
    }
    if (_response.error.reason === "status-code") {
      switch (_response.error.statusCode) {
        case 500:
          throw new api_exports.InternalError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 429:
          throw new api_exports.RateLimitError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 403:
          throw new api_exports.ForbiddenError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 408:
          throw new api_exports.UnauthorizedError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 404:
          throw new api_exports.NotFoundError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 400:
          throw new api_exports.BadRequestError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        default:
          throw new RivetError({
            statusCode: _response.error.statusCode,
            body: _response.error.body
          });
      }
    }
    switch (_response.error.reason) {
      case "non-json":
        throw new RivetError({
          statusCode: _response.error.statusCode,
          body: _response.error.rawBody
        });
      case "timeout":
        throw new RivetTimeoutError();
      case "unknown":
        throw new RivetError({
          message: _response.error.errorMessage
        });
    }
  }
  /**
   * Prepares a game logo image upload.
   * @throws {Rivet.InternalError}
   * @throws {Rivet.RateLimitError}
   * @throws {Rivet.ForbiddenError}
   * @throws {Rivet.UnauthorizedError}
   * @throws {Rivet.NotFoundError}
   * @throws {Rivet.BadRequestError}
   */
  async gameLogoUploadPrepare(gameId, request) {
    const _response = await fetcher({
      url: (0, import_url_join8.default)(
        this.options.environment ?? RivetEnvironment.Production,
        `/cloud/games/${gameId}/logo-upload/prepare`
      ),
      method: "POST",
      headers: {
        Authorization: await this._getAuthorizationHeader()
      },
      contentType: "application/json",
      body: await cloud_exports2.games.GameLogoUploadPrepareRequest.jsonOrThrow(request, {
        unrecognizedObjectKeys: "strip"
      })
    });
    if (_response.ok) {
      return await cloud_exports2.games.GameLogoUploadPrepareResponse.parseOrThrow(_response.body, {
        unrecognizedObjectKeys: "passthrough",
        allowUnrecognizedUnionMembers: true,
        allowUnrecognizedEnumValues: true
      });
    }
    if (_response.error.reason === "status-code") {
      switch (_response.error.statusCode) {
        case 500:
          throw new api_exports.InternalError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 429:
          throw new api_exports.RateLimitError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 403:
          throw new api_exports.ForbiddenError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 408:
          throw new api_exports.UnauthorizedError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 404:
          throw new api_exports.NotFoundError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 400:
          throw new api_exports.BadRequestError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        default:
          throw new RivetError({
            statusCode: _response.error.statusCode,
            body: _response.error.body
          });
      }
    }
    switch (_response.error.reason) {
      case "non-json":
        throw new RivetError({
          statusCode: _response.error.statusCode,
          body: _response.error.rawBody
        });
      case "timeout":
        throw new RivetTimeoutError();
      case "unknown":
        throw new RivetError({
          message: _response.error.errorMessage
        });
    }
  }
  /**
   * Completes a game logo image upload. Must be called after the file upload process completes.
   * @throws {Rivet.InternalError}
   * @throws {Rivet.RateLimitError}
   * @throws {Rivet.ForbiddenError}
   * @throws {Rivet.UnauthorizedError}
   * @throws {Rivet.NotFoundError}
   * @throws {Rivet.BadRequestError}
   */
  async gameLogoUploadComplete(gameId, uploadId) {
    const _response = await fetcher({
      url: (0, import_url_join8.default)(
        this.options.environment ?? RivetEnvironment.Production,
        `/cloud/games/${gameId}/logo-upload/${uploadId}/complete`
      ),
      method: "POST",
      headers: {
        Authorization: await this._getAuthorizationHeader()
      },
      contentType: "application/json"
    });
    if (_response.ok) {
      return;
    }
    if (_response.error.reason === "status-code") {
      switch (_response.error.statusCode) {
        case 500:
          throw new api_exports.InternalError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 429:
          throw new api_exports.RateLimitError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 403:
          throw new api_exports.ForbiddenError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 408:
          throw new api_exports.UnauthorizedError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 404:
          throw new api_exports.NotFoundError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 400:
          throw new api_exports.BadRequestError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        default:
          throw new RivetError({
            statusCode: _response.error.statusCode,
            body: _response.error.body
          });
      }
    }
    switch (_response.error.reason) {
      case "non-json":
        throw new RivetError({
          statusCode: _response.error.statusCode,
          body: _response.error.rawBody
        });
      case "timeout":
        throw new RivetTimeoutError();
      case "unknown":
        throw new RivetError({
          message: _response.error.errorMessage
        });
    }
  }
  async _getAuthorizationHeader() {
    const bearer = await Supplier.get(this.options.token);
    if (bearer != null) {
      return `Bearer ${bearer}`;
    }
    return void 0;
  }
};

// src/api/resources/cloud/resources/games/resources/matchmaker/client/Client.ts
init_core();
var import_url_join9 = __toESM(require_url_join());
init_serialization();
var Matchmaker = class {
  constructor(options) {
    this.options = options;
  }
  /**
   * Exports lobby history over a given query time span.
   * @throws {Rivet.InternalError}
   * @throws {Rivet.RateLimitError}
   * @throws {Rivet.ForbiddenError}
   * @throws {Rivet.UnauthorizedError}
   * @throws {Rivet.NotFoundError}
   * @throws {Rivet.BadRequestError}
   */
  async exportMatchmakerLobbyHistory(gameId, request) {
    const _response = await fetcher({
      url: (0, import_url_join9.default)(
        this.options.environment ?? RivetEnvironment.Production,
        `/cloud/games/${gameId}/matchmaker/lobbies/export-history`
      ),
      method: "POST",
      headers: {
        Authorization: await this._getAuthorizationHeader()
      },
      contentType: "application/json",
      body: await cloud_exports2.games.ExportMatchmakerLobbyHistoryRequest.jsonOrThrow(request, {
        unrecognizedObjectKeys: "strip"
      })
    });
    if (_response.ok) {
      return await cloud_exports2.games.ExportMatchmakerLobbyHistoryResponse.parseOrThrow(_response.body, {
        unrecognizedObjectKeys: "passthrough",
        allowUnrecognizedUnionMembers: true,
        allowUnrecognizedEnumValues: true
      });
    }
    if (_response.error.reason === "status-code") {
      switch (_response.error.statusCode) {
        case 500:
          throw new api_exports.InternalError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 429:
          throw new api_exports.RateLimitError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 403:
          throw new api_exports.ForbiddenError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 408:
          throw new api_exports.UnauthorizedError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 404:
          throw new api_exports.NotFoundError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 400:
          throw new api_exports.BadRequestError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        default:
          throw new RivetError({
            statusCode: _response.error.statusCode,
            body: _response.error.body
          });
      }
    }
    switch (_response.error.reason) {
      case "non-json":
        throw new RivetError({
          statusCode: _response.error.statusCode,
          body: _response.error.rawBody
        });
      case "timeout":
        throw new RivetTimeoutError();
      case "unknown":
        throw new RivetError({
          message: _response.error.errorMessage
        });
    }
  }
  /**
   * Deletes a matchmaker lobby, stopping it immediately.
   * @throws {Rivet.InternalError}
   * @throws {Rivet.RateLimitError}
   * @throws {Rivet.ForbiddenError}
   * @throws {Rivet.UnauthorizedError}
   * @throws {Rivet.NotFoundError}
   * @throws {Rivet.BadRequestError}
   */
  async deleteMatchmakerLobby(gameId, lobbyId) {
    const _response = await fetcher({
      url: (0, import_url_join9.default)(
        this.options.environment ?? RivetEnvironment.Production,
        `/cloud/games/${gameId}/matchmaker/lobbies/${lobbyId}`
      ),
      method: "DELETE",
      headers: {
        Authorization: await this._getAuthorizationHeader()
      },
      contentType: "application/json"
    });
    if (_response.ok) {
      return await cloud_exports2.games.DeleteMatchmakerLobbyResponse.parseOrThrow(_response.body, {
        unrecognizedObjectKeys: "passthrough",
        allowUnrecognizedUnionMembers: true,
        allowUnrecognizedEnumValues: true
      });
    }
    if (_response.error.reason === "status-code") {
      switch (_response.error.statusCode) {
        case 500:
          throw new api_exports.InternalError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 429:
          throw new api_exports.RateLimitError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 403:
          throw new api_exports.ForbiddenError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 408:
          throw new api_exports.UnauthorizedError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 404:
          throw new api_exports.NotFoundError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 400:
          throw new api_exports.BadRequestError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        default:
          throw new RivetError({
            statusCode: _response.error.statusCode,
            body: _response.error.body
          });
      }
    }
    switch (_response.error.reason) {
      case "non-json":
        throw new RivetError({
          statusCode: _response.error.statusCode,
          body: _response.error.rawBody
        });
      case "timeout":
        throw new RivetTimeoutError();
      case "unknown":
        throw new RivetError({
          message: _response.error.errorMessage
        });
    }
  }
  /**
   * Returns the logs for a given lobby.
   * @throws {Rivet.InternalError}
   * @throws {Rivet.RateLimitError}
   * @throws {Rivet.ForbiddenError}
   * @throws {Rivet.UnauthorizedError}
   * @throws {Rivet.NotFoundError}
   * @throws {Rivet.BadRequestError}
   */
  async getLobbyLogs(gameId, lobbyId, request) {
    const { stream, watchIndex } = request;
    const _queryParams = new URLSearchParams();
    _queryParams.append("stream", stream);
    if (watchIndex != null) {
      _queryParams.append("watch_index", watchIndex);
    }
    const _response = await fetcher({
      url: (0, import_url_join9.default)(
        this.options.environment ?? RivetEnvironment.Production,
        `/cloud/games/${gameId}/matchmaker/lobbies/${lobbyId}/logs`
      ),
      method: "GET",
      headers: {
        Authorization: await this._getAuthorizationHeader()
      },
      contentType: "application/json",
      queryParameters: _queryParams
    });
    if (_response.ok) {
      return await cloud_exports2.games.GetLobbyLogsResponse.parseOrThrow(_response.body, {
        unrecognizedObjectKeys: "passthrough",
        allowUnrecognizedUnionMembers: true,
        allowUnrecognizedEnumValues: true
      });
    }
    if (_response.error.reason === "status-code") {
      switch (_response.error.statusCode) {
        case 500:
          throw new api_exports.InternalError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 429:
          throw new api_exports.RateLimitError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 403:
          throw new api_exports.ForbiddenError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 408:
          throw new api_exports.UnauthorizedError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 404:
          throw new api_exports.NotFoundError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 400:
          throw new api_exports.BadRequestError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        default:
          throw new RivetError({
            statusCode: _response.error.statusCode,
            body: _response.error.body
          });
      }
    }
    switch (_response.error.reason) {
      case "non-json":
        throw new RivetError({
          statusCode: _response.error.statusCode,
          body: _response.error.rawBody
        });
      case "timeout":
        throw new RivetTimeoutError();
      case "unknown":
        throw new RivetError({
          message: _response.error.errorMessage
        });
    }
  }
  /**
   * Generates a download URL for logs.
   * @throws {Rivet.InternalError}
   * @throws {Rivet.RateLimitError}
   * @throws {Rivet.ForbiddenError}
   * @throws {Rivet.UnauthorizedError}
   * @throws {Rivet.NotFoundError}
   * @throws {Rivet.BadRequestError}
   */
  async exportLobbyLogs(gameId, lobbyId, request) {
    const _response = await fetcher({
      url: (0, import_url_join9.default)(
        this.options.environment ?? RivetEnvironment.Production,
        `/cloud/games/${gameId}/matchmaker/lobbies/${lobbyId}/logs/export`
      ),
      method: "POST",
      headers: {
        Authorization: await this._getAuthorizationHeader()
      },
      contentType: "application/json",
      body: await cloud_exports2.games.ExportLobbyLogsRequest.jsonOrThrow(request, {
        unrecognizedObjectKeys: "strip"
      })
    });
    if (_response.ok) {
      return await cloud_exports2.games.ExportLobbyLogsResponse.parseOrThrow(_response.body, {
        unrecognizedObjectKeys: "passthrough",
        allowUnrecognizedUnionMembers: true,
        allowUnrecognizedEnumValues: true
      });
    }
    if (_response.error.reason === "status-code") {
      switch (_response.error.statusCode) {
        case 500:
          throw new api_exports.InternalError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 429:
          throw new api_exports.RateLimitError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 403:
          throw new api_exports.ForbiddenError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 408:
          throw new api_exports.UnauthorizedError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 404:
          throw new api_exports.NotFoundError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 400:
          throw new api_exports.BadRequestError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        default:
          throw new RivetError({
            statusCode: _response.error.statusCode,
            body: _response.error.body
          });
      }
    }
    switch (_response.error.reason) {
      case "non-json":
        throw new RivetError({
          statusCode: _response.error.statusCode,
          body: _response.error.rawBody
        });
      case "timeout":
        throw new RivetTimeoutError();
      case "unknown":
        throw new RivetError({
          message: _response.error.errorMessage
        });
    }
  }
  async _getAuthorizationHeader() {
    const bearer = await Supplier.get(this.options.token);
    if (bearer != null) {
      return `Bearer ${bearer}`;
    }
    return void 0;
  }
};

// src/api/resources/cloud/resources/games/resources/tokens/client/Client.ts
init_core();
var import_url_join10 = __toESM(require_url_join());
init_serialization();
var Tokens = class {
  constructor(options) {
    this.options = options;
  }
  /**
   * Creates a new game cloud token.
   * @throws {Rivet.InternalError}
   * @throws {Rivet.RateLimitError}
   * @throws {Rivet.ForbiddenError}
   * @throws {Rivet.UnauthorizedError}
   * @throws {Rivet.NotFoundError}
   * @throws {Rivet.BadRequestError}
   */
  async createCloudToken(gameId) {
    const _response = await fetcher({
      url: (0, import_url_join10.default)(
        this.options.environment ?? RivetEnvironment.Production,
        `/cloud/games/${gameId}/tokens/cloud`
      ),
      method: "POST",
      headers: {
        Authorization: await this._getAuthorizationHeader()
      },
      contentType: "application/json"
    });
    if (_response.ok) {
      return await cloud_exports2.games.CreateCloudTokenResponse.parseOrThrow(_response.body, {
        unrecognizedObjectKeys: "passthrough",
        allowUnrecognizedUnionMembers: true,
        allowUnrecognizedEnumValues: true
      });
    }
    if (_response.error.reason === "status-code") {
      switch (_response.error.statusCode) {
        case 500:
          throw new api_exports.InternalError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 429:
          throw new api_exports.RateLimitError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 403:
          throw new api_exports.ForbiddenError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 408:
          throw new api_exports.UnauthorizedError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 404:
          throw new api_exports.NotFoundError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 400:
          throw new api_exports.BadRequestError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        default:
          throw new RivetError({
            statusCode: _response.error.statusCode,
            body: _response.error.body
          });
      }
    }
    switch (_response.error.reason) {
      case "non-json":
        throw new RivetError({
          statusCode: _response.error.statusCode,
          body: _response.error.rawBody
        });
      case "timeout":
        throw new RivetTimeoutError();
      case "unknown":
        throw new RivetError({
          message: _response.error.errorMessage
        });
    }
  }
  async _getAuthorizationHeader() {
    const bearer = await Supplier.get(this.options.token);
    if (bearer != null) {
      return `Bearer ${bearer}`;
    }
    return void 0;
  }
};

// src/api/resources/cloud/resources/games/resources/versions/client/Client.ts
init_core();
var import_url_join11 = __toESM(require_url_join());
init_serialization();
var Versions = class {
  constructor(options) {
    this.options = options;
  }
  /**
   * Creates a new game version.
   * @throws {Rivet.InternalError}
   * @throws {Rivet.RateLimitError}
   * @throws {Rivet.ForbiddenError}
   * @throws {Rivet.UnauthorizedError}
   * @throws {Rivet.NotFoundError}
   * @throws {Rivet.BadRequestError}
   */
  async createGameVersion(gameId, request) {
    const _response = await fetcher({
      url: (0, import_url_join11.default)(
        this.options.environment ?? RivetEnvironment.Production,
        `/cloud/games/${gameId}/versions`
      ),
      method: "POST",
      headers: {
        Authorization: await this._getAuthorizationHeader()
      },
      contentType: "application/json",
      body: await cloud_exports2.games.CreateGameVersionRequest.jsonOrThrow(request, {
        unrecognizedObjectKeys: "strip"
      })
    });
    if (_response.ok) {
      return await cloud_exports2.games.CreateGameVersionResponse.parseOrThrow(_response.body, {
        unrecognizedObjectKeys: "passthrough",
        allowUnrecognizedUnionMembers: true,
        allowUnrecognizedEnumValues: true
      });
    }
    if (_response.error.reason === "status-code") {
      switch (_response.error.statusCode) {
        case 500:
          throw new api_exports.InternalError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 429:
          throw new api_exports.RateLimitError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 403:
          throw new api_exports.ForbiddenError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 408:
          throw new api_exports.UnauthorizedError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 404:
          throw new api_exports.NotFoundError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 400:
          throw new api_exports.BadRequestError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        default:
          throw new RivetError({
            statusCode: _response.error.statusCode,
            body: _response.error.body
          });
      }
    }
    switch (_response.error.reason) {
      case "non-json":
        throw new RivetError({
          statusCode: _response.error.statusCode,
          body: _response.error.rawBody
        });
      case "timeout":
        throw new RivetTimeoutError();
      case "unknown":
        throw new RivetError({
          message: _response.error.errorMessage
        });
    }
  }
  /**
   * Validates information used to create a new game version.
   * @throws {Rivet.InternalError}
   * @throws {Rivet.RateLimitError}
   * @throws {Rivet.ForbiddenError}
   * @throws {Rivet.UnauthorizedError}
   * @throws {Rivet.NotFoundError}
   * @throws {Rivet.BadRequestError}
   */
  async validateGameVersion(gameId, request) {
    const _response = await fetcher({
      url: (0, import_url_join11.default)(
        this.options.environment ?? RivetEnvironment.Production,
        `/cloud/games/${gameId}/versions/validate`
      ),
      method: "POST",
      headers: {
        Authorization: await this._getAuthorizationHeader()
      },
      contentType: "application/json",
      body: await cloud_exports2.games.ValidateGameVersionRequest.jsonOrThrow(request, {
        unrecognizedObjectKeys: "strip"
      })
    });
    if (_response.ok) {
      return await cloud_exports2.games.ValidateGameVersionResponse.parseOrThrow(_response.body, {
        unrecognizedObjectKeys: "passthrough",
        allowUnrecognizedUnionMembers: true,
        allowUnrecognizedEnumValues: true
      });
    }
    if (_response.error.reason === "status-code") {
      switch (_response.error.statusCode) {
        case 500:
          throw new api_exports.InternalError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 429:
          throw new api_exports.RateLimitError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 403:
          throw new api_exports.ForbiddenError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 408:
          throw new api_exports.UnauthorizedError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 404:
          throw new api_exports.NotFoundError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 400:
          throw new api_exports.BadRequestError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        default:
          throw new RivetError({
            statusCode: _response.error.statusCode,
            body: _response.error.body
          });
      }
    }
    switch (_response.error.reason) {
      case "non-json":
        throw new RivetError({
          statusCode: _response.error.statusCode,
          body: _response.error.rawBody
        });
      case "timeout":
        throw new RivetTimeoutError();
      case "unknown":
        throw new RivetError({
          message: _response.error.errorMessage
        });
    }
  }
  /**
   * Returns a game version by its version ID.
   * @throws {Rivet.InternalError}
   * @throws {Rivet.RateLimitError}
   * @throws {Rivet.ForbiddenError}
   * @throws {Rivet.UnauthorizedError}
   * @throws {Rivet.NotFoundError}
   * @throws {Rivet.BadRequestError}
   */
  async getGameVersionById(gameId, versionId) {
    const _response = await fetcher({
      url: (0, import_url_join11.default)(
        this.options.environment ?? RivetEnvironment.Production,
        `/cloud/games/${gameId}/versions/${versionId}`
      ),
      method: "GET",
      headers: {
        Authorization: await this._getAuthorizationHeader()
      },
      contentType: "application/json"
    });
    if (_response.ok) {
      return await cloud_exports2.games.GetGameVersionByIdResponse.parseOrThrow(_response.body, {
        unrecognizedObjectKeys: "passthrough",
        allowUnrecognizedUnionMembers: true,
        allowUnrecognizedEnumValues: true
      });
    }
    if (_response.error.reason === "status-code") {
      switch (_response.error.statusCode) {
        case 500:
          throw new api_exports.InternalError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 429:
          throw new api_exports.RateLimitError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 403:
          throw new api_exports.ForbiddenError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 408:
          throw new api_exports.UnauthorizedError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 404:
          throw new api_exports.NotFoundError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 400:
          throw new api_exports.BadRequestError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        default:
          throw new RivetError({
            statusCode: _response.error.statusCode,
            body: _response.error.body
          });
      }
    }
    switch (_response.error.reason) {
      case "non-json":
        throw new RivetError({
          statusCode: _response.error.statusCode,
          body: _response.error.rawBody
        });
      case "timeout":
        throw new RivetTimeoutError();
      case "unknown":
        throw new RivetError({
          message: _response.error.errorMessage
        });
    }
  }
  async _getAuthorizationHeader() {
    const bearer = await Supplier.get(this.options.token);
    if (bearer != null) {
      return `Bearer ${bearer}`;
    }
    return void 0;
  }
};

// src/api/resources/cloud/resources/games/client/Client.ts
var Games2 = class {
  constructor(options) {
    this.options = options;
  }
  _namespaces;
  get namespaces() {
    return this._namespaces ?? (this._namespaces = new Namespaces(this.options));
  }
  _avatars;
  get avatars() {
    return this._avatars ?? (this._avatars = new Avatars(this.options));
  }
  _builds;
  get builds() {
    return this._builds ?? (this._builds = new Builds(this.options));
  }
  _cdn;
  get cdn() {
    return this._cdn ?? (this._cdn = new Cdn(this.options));
  }
  _games;
  get games() {
    return this._games ?? (this._games = new Games(this.options));
  }
  _matchmaker;
  get matchmaker() {
    return this._matchmaker ?? (this._matchmaker = new Matchmaker(this.options));
  }
  _tokens;
  get tokens() {
    return this._tokens ?? (this._tokens = new Tokens(this.options));
  }
  _versions;
  get versions() {
    return this._versions ?? (this._versions = new Versions(this.options));
  }
};

// src/api/resources/cloud/resources/auth/client/Client.ts
init_core();
var import_url_join12 = __toESM(require_url_join());
init_serialization();
var Auth = class {
  constructor(options) {
    this.options = options;
  }
  /**
   * Returns information about the current authenticated agent.
   * @throws {Rivet.InternalError}
   * @throws {Rivet.RateLimitError}
   * @throws {Rivet.ForbiddenError}
   * @throws {Rivet.UnauthorizedError}
   * @throws {Rivet.NotFoundError}
   * @throws {Rivet.BadRequestError}
   */
  async inspect() {
    const _response = await fetcher({
      url: (0, import_url_join12.default)(this.options.environment ?? RivetEnvironment.Production, "/cloud/auth/inspect"),
      method: "GET",
      headers: {
        Authorization: await this._getAuthorizationHeader()
      },
      contentType: "application/json"
    });
    if (_response.ok) {
      return await cloud_exports2.InspectResponse.parseOrThrow(_response.body, {
        unrecognizedObjectKeys: "passthrough",
        allowUnrecognizedUnionMembers: true,
        allowUnrecognizedEnumValues: true
      });
    }
    if (_response.error.reason === "status-code") {
      switch (_response.error.statusCode) {
        case 500:
          throw new api_exports.InternalError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 429:
          throw new api_exports.RateLimitError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 403:
          throw new api_exports.ForbiddenError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 408:
          throw new api_exports.UnauthorizedError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 404:
          throw new api_exports.NotFoundError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 400:
          throw new api_exports.BadRequestError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        default:
          throw new RivetError({
            statusCode: _response.error.statusCode,
            body: _response.error.body
          });
      }
    }
    switch (_response.error.reason) {
      case "non-json":
        throw new RivetError({
          statusCode: _response.error.statusCode,
          body: _response.error.rawBody
        });
      case "timeout":
        throw new RivetTimeoutError();
      case "unknown":
        throw new RivetError({
          message: _response.error.errorMessage
        });
    }
  }
  async _getAuthorizationHeader() {
    const bearer = await Supplier.get(this.options.token);
    if (bearer != null) {
      return `Bearer ${bearer}`;
    }
    return void 0;
  }
};

// src/api/resources/cloud/resources/devices/resources/links/client/Client.ts
init_core();
var import_url_join13 = __toESM(require_url_join());
init_serialization();
var Links = class {
  constructor(options) {
    this.options = options;
  }
  /**
   * @throws {Rivet.InternalError}
   * @throws {Rivet.RateLimitError}
   * @throws {Rivet.ForbiddenError}
   * @throws {Rivet.UnauthorizedError}
   * @throws {Rivet.NotFoundError}
   * @throws {Rivet.BadRequestError}
   */
  async prepare() {
    const _response = await fetcher({
      url: (0, import_url_join13.default)(this.options.environment ?? RivetEnvironment.Production, "/cloud/devices/links"),
      method: "POST",
      headers: {
        Authorization: await this._getAuthorizationHeader()
      },
      contentType: "application/json"
    });
    if (_response.ok) {
      return await cloud_exports2.devices.PrepareDeviceLinkResponse.parseOrThrow(_response.body, {
        unrecognizedObjectKeys: "passthrough",
        allowUnrecognizedUnionMembers: true,
        allowUnrecognizedEnumValues: true
      });
    }
    if (_response.error.reason === "status-code") {
      switch (_response.error.statusCode) {
        case 500:
          throw new api_exports.InternalError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 429:
          throw new api_exports.RateLimitError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 403:
          throw new api_exports.ForbiddenError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 408:
          throw new api_exports.UnauthorizedError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 404:
          throw new api_exports.NotFoundError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 400:
          throw new api_exports.BadRequestError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        default:
          throw new RivetError({
            statusCode: _response.error.statusCode,
            body: _response.error.body
          });
      }
    }
    switch (_response.error.reason) {
      case "non-json":
        throw new RivetError({
          statusCode: _response.error.statusCode,
          body: _response.error.rawBody
        });
      case "timeout":
        throw new RivetTimeoutError();
      case "unknown":
        throw new RivetError({
          message: _response.error.errorMessage
        });
    }
  }
  /**
   * @throws {Rivet.InternalError}
   * @throws {Rivet.RateLimitError}
   * @throws {Rivet.ForbiddenError}
   * @throws {Rivet.UnauthorizedError}
   * @throws {Rivet.NotFoundError}
   * @throws {Rivet.BadRequestError}
   */
  async get(request) {
    const { deviceLinkToken, watchIndex } = request;
    const _queryParams = new URLSearchParams();
    _queryParams.append("device_link_token", deviceLinkToken);
    if (watchIndex != null) {
      _queryParams.append("watch_index", watchIndex);
    }
    const _response = await fetcher({
      url: (0, import_url_join13.default)(this.options.environment ?? RivetEnvironment.Production, "/cloud/devices/links"),
      method: "GET",
      headers: {
        Authorization: await this._getAuthorizationHeader()
      },
      contentType: "application/json",
      queryParameters: _queryParams
    });
    if (_response.ok) {
      return await cloud_exports2.devices.GetDeviceLinkResponse.parseOrThrow(_response.body, {
        unrecognizedObjectKeys: "passthrough",
        allowUnrecognizedUnionMembers: true,
        allowUnrecognizedEnumValues: true
      });
    }
    if (_response.error.reason === "status-code") {
      switch (_response.error.statusCode) {
        case 500:
          throw new api_exports.InternalError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 429:
          throw new api_exports.RateLimitError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 403:
          throw new api_exports.ForbiddenError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 408:
          throw new api_exports.UnauthorizedError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 404:
          throw new api_exports.NotFoundError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 400:
          throw new api_exports.BadRequestError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        default:
          throw new RivetError({
            statusCode: _response.error.statusCode,
            body: _response.error.body
          });
      }
    }
    switch (_response.error.reason) {
      case "non-json":
        throw new RivetError({
          statusCode: _response.error.statusCode,
          body: _response.error.rawBody
        });
      case "timeout":
        throw new RivetTimeoutError();
      case "unknown":
        throw new RivetError({
          message: _response.error.errorMessage
        });
    }
  }
  async _getAuthorizationHeader() {
    const bearer = await Supplier.get(this.options.token);
    if (bearer != null) {
      return `Bearer ${bearer}`;
    }
    return void 0;
  }
};

// src/api/resources/cloud/resources/devices/client/Client.ts
var Devices = class {
  constructor(options) {
    this.options = options;
  }
  _links;
  get links() {
    return this._links ?? (this._links = new Links(this.options));
  }
};

// src/api/resources/cloud/resources/groups/client/Client.ts
init_core();
var import_url_join14 = __toESM(require_url_join());
init_serialization();
var Groups = class {
  constructor(options) {
    this.options = options;
  }
  /**
   * Validates information used to create a new group.
   * @throws {Rivet.InternalError}
   * @throws {Rivet.RateLimitError}
   * @throws {Rivet.ForbiddenError}
   * @throws {Rivet.UnauthorizedError}
   * @throws {Rivet.NotFoundError}
   * @throws {Rivet.BadRequestError}
   */
  async validate(request) {
    const _response = await fetcher({
      url: (0, import_url_join14.default)(
        this.options.environment ?? RivetEnvironment.Production,
        "/cloud/groups/validate"
      ),
      method: "POST",
      headers: {
        Authorization: await this._getAuthorizationHeader()
      },
      contentType: "application/json",
      body: await cloud_exports2.ValidateGroupRequest.jsonOrThrow(request, {
        unrecognizedObjectKeys: "strip"
      })
    });
    if (_response.ok) {
      return await cloud_exports2.ValidateGroupResponse.parseOrThrow(_response.body, {
        unrecognizedObjectKeys: "passthrough",
        allowUnrecognizedUnionMembers: true,
        allowUnrecognizedEnumValues: true
      });
    }
    if (_response.error.reason === "status-code") {
      switch (_response.error.statusCode) {
        case 500:
          throw new api_exports.InternalError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 429:
          throw new api_exports.RateLimitError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 403:
          throw new api_exports.ForbiddenError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 408:
          throw new api_exports.UnauthorizedError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 404:
          throw new api_exports.NotFoundError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 400:
          throw new api_exports.BadRequestError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        default:
          throw new RivetError({
            statusCode: _response.error.statusCode,
            body: _response.error.body
          });
      }
    }
    switch (_response.error.reason) {
      case "non-json":
        throw new RivetError({
          statusCode: _response.error.statusCode,
          body: _response.error.rawBody
        });
      case "timeout":
        throw new RivetTimeoutError();
      case "unknown":
        throw new RivetError({
          message: _response.error.errorMessage
        });
    }
  }
  /**
   * Converts the given group into a developer group.
   * @throws {Rivet.InternalError}
   * @throws {Rivet.RateLimitError}
   * @throws {Rivet.ForbiddenError}
   * @throws {Rivet.UnauthorizedError}
   * @throws {Rivet.NotFoundError}
   * @throws {Rivet.BadRequestError}
   */
  async convertGroup(groupId) {
    const _response = await fetcher({
      url: (0, import_url_join14.default)(
        this.options.environment ?? RivetEnvironment.Production,
        `/cloud/groups/${groupId}/convert`
      ),
      method: "POST",
      headers: {
        Authorization: await this._getAuthorizationHeader()
      },
      contentType: "application/json"
    });
    if (_response.ok) {
      return;
    }
    if (_response.error.reason === "status-code") {
      switch (_response.error.statusCode) {
        case 500:
          throw new api_exports.InternalError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 429:
          throw new api_exports.RateLimitError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 403:
          throw new api_exports.ForbiddenError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 408:
          throw new api_exports.UnauthorizedError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 404:
          throw new api_exports.NotFoundError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 400:
          throw new api_exports.BadRequestError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        default:
          throw new RivetError({
            statusCode: _response.error.statusCode,
            body: _response.error.body
          });
      }
    }
    switch (_response.error.reason) {
      case "non-json":
        throw new RivetError({
          statusCode: _response.error.statusCode,
          body: _response.error.rawBody
        });
      case "timeout":
        throw new RivetTimeoutError();
      case "unknown":
        throw new RivetError({
          message: _response.error.errorMessage
        });
    }
  }
  async _getAuthorizationHeader() {
    const bearer = await Supplier.get(this.options.token);
    if (bearer != null) {
      return `Bearer ${bearer}`;
    }
    return void 0;
  }
};

// src/api/resources/cloud/resources/logs/client/Client.ts
init_core();
var import_url_join15 = __toESM(require_url_join());
init_serialization();
var Logs2 = class {
  constructor(options) {
    this.options = options;
  }
  /**
   * Returns performance information about a Rivet Ray.
   * @throws {Rivet.InternalError}
   * @throws {Rivet.RateLimitError}
   * @throws {Rivet.ForbiddenError}
   * @throws {Rivet.UnauthorizedError}
   * @throws {Rivet.NotFoundError}
   * @throws {Rivet.BadRequestError}
   */
  async getRayPerfLogs(rayId) {
    const _response = await fetcher({
      url: (0, import_url_join15.default)(
        this.options.environment ?? RivetEnvironment.Production,
        `/cloud/rays/${rayId}/perf`
      ),
      method: "GET",
      headers: {
        Authorization: await this._getAuthorizationHeader()
      },
      contentType: "application/json"
    });
    if (_response.ok) {
      return await cloud_exports2.GetRayPerfLogsResponse.parseOrThrow(_response.body, {
        unrecognizedObjectKeys: "passthrough",
        allowUnrecognizedUnionMembers: true,
        allowUnrecognizedEnumValues: true
      });
    }
    if (_response.error.reason === "status-code") {
      switch (_response.error.statusCode) {
        case 500:
          throw new api_exports.InternalError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 429:
          throw new api_exports.RateLimitError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 403:
          throw new api_exports.ForbiddenError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 408:
          throw new api_exports.UnauthorizedError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 404:
          throw new api_exports.NotFoundError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 400:
          throw new api_exports.BadRequestError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        default:
          throw new RivetError({
            statusCode: _response.error.statusCode,
            body: _response.error.body
          });
      }
    }
    switch (_response.error.reason) {
      case "non-json":
        throw new RivetError({
          statusCode: _response.error.statusCode,
          body: _response.error.rawBody
        });
      case "timeout":
        throw new RivetTimeoutError();
      case "unknown":
        throw new RivetError({
          message: _response.error.errorMessage
        });
    }
  }
  async _getAuthorizationHeader() {
    const bearer = await Supplier.get(this.options.token);
    if (bearer != null) {
      return `Bearer ${bearer}`;
    }
    return void 0;
  }
};

// src/api/resources/cloud/resources/tiers/client/Client.ts
init_core();
var import_url_join16 = __toESM(require_url_join());
init_serialization();
var Tiers = class {
  constructor(options) {
    this.options = options;
  }
  /**
   * Returns all available region tiers.
   * @throws {Rivet.InternalError}
   * @throws {Rivet.RateLimitError}
   * @throws {Rivet.ForbiddenError}
   * @throws {Rivet.UnauthorizedError}
   * @throws {Rivet.NotFoundError}
   * @throws {Rivet.BadRequestError}
   */
  async getRegionTiers() {
    const _response = await fetcher({
      url: (0, import_url_join16.default)(this.options.environment ?? RivetEnvironment.Production, "/cloud/region-tiers"),
      method: "GET",
      headers: {
        Authorization: await this._getAuthorizationHeader()
      },
      contentType: "application/json"
    });
    if (_response.ok) {
      return await cloud_exports2.GetRegionTiersResponse.parseOrThrow(_response.body, {
        unrecognizedObjectKeys: "passthrough",
        allowUnrecognizedUnionMembers: true,
        allowUnrecognizedEnumValues: true
      });
    }
    if (_response.error.reason === "status-code") {
      switch (_response.error.statusCode) {
        case 500:
          throw new api_exports.InternalError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 429:
          throw new api_exports.RateLimitError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 403:
          throw new api_exports.ForbiddenError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 408:
          throw new api_exports.UnauthorizedError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 404:
          throw new api_exports.NotFoundError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 400:
          throw new api_exports.BadRequestError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        default:
          throw new RivetError({
            statusCode: _response.error.statusCode,
            body: _response.error.body
          });
      }
    }
    switch (_response.error.reason) {
      case "non-json":
        throw new RivetError({
          statusCode: _response.error.statusCode,
          body: _response.error.rawBody
        });
      case "timeout":
        throw new RivetTimeoutError();
      case "unknown":
        throw new RivetError({
          message: _response.error.errorMessage
        });
    }
  }
  async _getAuthorizationHeader() {
    const bearer = await Supplier.get(this.options.token);
    if (bearer != null) {
      return `Bearer ${bearer}`;
    }
    return void 0;
  }
};

// src/api/resources/cloud/resources/uploads/client/Client.ts
init_core();
var import_url_join17 = __toESM(require_url_join());
init_serialization();
var Uploads = class {
  constructor(options) {
    this.options = options;
  }
  /**
   * Marks an upload as complete.
   * @throws {Rivet.InternalError}
   * @throws {Rivet.RateLimitError}
   * @throws {Rivet.ForbiddenError}
   * @throws {Rivet.UnauthorizedError}
   * @throws {Rivet.NotFoundError}
   * @throws {Rivet.BadRequestError}
   */
  async completeUpload(uploadId) {
    const _response = await fetcher({
      url: (0, import_url_join17.default)(
        this.options.environment ?? RivetEnvironment.Production,
        `/cloud/uploads/${uploadId}/complete`
      ),
      method: "POST",
      headers: {
        Authorization: await this._getAuthorizationHeader()
      },
      contentType: "application/json"
    });
    if (_response.ok) {
      return;
    }
    if (_response.error.reason === "status-code") {
      switch (_response.error.statusCode) {
        case 500:
          throw new api_exports.InternalError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 429:
          throw new api_exports.RateLimitError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 403:
          throw new api_exports.ForbiddenError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 408:
          throw new api_exports.UnauthorizedError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 404:
          throw new api_exports.NotFoundError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 400:
          throw new api_exports.BadRequestError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        default:
          throw new RivetError({
            statusCode: _response.error.statusCode,
            body: _response.error.body
          });
      }
    }
    switch (_response.error.reason) {
      case "non-json":
        throw new RivetError({
          statusCode: _response.error.statusCode,
          body: _response.error.rawBody
        });
      case "timeout":
        throw new RivetTimeoutError();
      case "unknown":
        throw new RivetError({
          message: _response.error.errorMessage
        });
    }
  }
  async _getAuthorizationHeader() {
    const bearer = await Supplier.get(this.options.token);
    if (bearer != null) {
      return `Bearer ${bearer}`;
    }
    return void 0;
  }
};

// src/api/resources/cloud/client/Client.ts
var Cloud = class {
  constructor(options) {
    this.options = options;
  }
  /**
   * Returns the basic information required to use the cloud APIs.
   * @throws {Rivet.InternalError}
   * @throws {Rivet.RateLimitError}
   * @throws {Rivet.ForbiddenError}
   * @throws {Rivet.UnauthorizedError}
   * @throws {Rivet.NotFoundError}
   * @throws {Rivet.BadRequestError}
   */
  async bootstrap() {
    const _response = await fetcher({
      url: (0, import_url_join18.default)(this.options.environment ?? RivetEnvironment.Production, "/cloud/bootstrap"),
      method: "GET",
      headers: {
        Authorization: await this._getAuthorizationHeader()
      },
      contentType: "application/json"
    });
    if (_response.ok) {
      return await cloud_exports2.BootstrapResponse.parseOrThrow(_response.body, {
        unrecognizedObjectKeys: "passthrough",
        allowUnrecognizedUnionMembers: true,
        allowUnrecognizedEnumValues: true
      });
    }
    if (_response.error.reason === "status-code") {
      switch (_response.error.statusCode) {
        case 500:
          throw new api_exports.InternalError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 429:
          throw new api_exports.RateLimitError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 403:
          throw new api_exports.ForbiddenError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 408:
          throw new api_exports.UnauthorizedError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 404:
          throw new api_exports.NotFoundError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 400:
          throw new api_exports.BadRequestError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        default:
          throw new RivetError({
            statusCode: _response.error.statusCode,
            body: _response.error.body
          });
      }
    }
    switch (_response.error.reason) {
      case "non-json":
        throw new RivetError({
          statusCode: _response.error.statusCode,
          body: _response.error.rawBody
        });
      case "timeout":
        throw new RivetTimeoutError();
      case "unknown":
        throw new RivetError({
          message: _response.error.errorMessage
        });
    }
  }
  _games;
  get games() {
    return this._games ?? (this._games = new Games2(this.options));
  }
  _auth;
  get auth() {
    return this._auth ?? (this._auth = new Auth(this.options));
  }
  _devices;
  get devices() {
    return this._devices ?? (this._devices = new Devices(this.options));
  }
  _groups;
  get groups() {
    return this._groups ?? (this._groups = new Groups(this.options));
  }
  _logs;
  get logs() {
    return this._logs ?? (this._logs = new Logs2(this.options));
  }
  _tiers;
  get tiers() {
    return this._tiers ?? (this._tiers = new Tiers(this.options));
  }
  _uploads;
  get uploads() {
    return this._uploads ?? (this._uploads = new Uploads(this.options));
  }
  async _getAuthorizationHeader() {
    const bearer = await Supplier.get(this.options.token);
    if (bearer != null) {
      return `Bearer ${bearer}`;
    }
    return void 0;
  }
};

// src/api/resources/group/client/Client.ts
init_core();
var import_url_join21 = __toESM(require_url_join());
init_serialization();

// src/api/resources/group/resources/invites/client/Client.ts
init_core();
var import_url_join19 = __toESM(require_url_join());
init_serialization();
var Invites = class {
  constructor(options) {
    this.options = options;
  }
  /**
   * Inspects a group invite returning information about the team that created it.
   * @throws {Rivet.InternalError}
   * @throws {Rivet.RateLimitError}
   * @throws {Rivet.ForbiddenError}
   * @throws {Rivet.UnauthorizedError}
   * @throws {Rivet.NotFoundError}
   * @throws {Rivet.BadRequestError}
   */
  async getInvite(groupInviteCode) {
    const _response = await fetcher({
      url: (0, import_url_join19.default)(
        this.options.environment ?? RivetEnvironment.Production,
        `/group/invites/${groupInviteCode}`
      ),
      method: "GET",
      headers: {
        Authorization: await this._getAuthorizationHeader()
      },
      contentType: "application/json"
    });
    if (_response.ok) {
      return await group_exports2.GetInviteResponse.parseOrThrow(_response.body, {
        unrecognizedObjectKeys: "passthrough",
        allowUnrecognizedUnionMembers: true,
        allowUnrecognizedEnumValues: true
      });
    }
    if (_response.error.reason === "status-code") {
      switch (_response.error.statusCode) {
        case 500:
          throw new api_exports.InternalError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 429:
          throw new api_exports.RateLimitError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 403:
          throw new api_exports.ForbiddenError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 408:
          throw new api_exports.UnauthorizedError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 404:
          throw new api_exports.NotFoundError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 400:
          throw new api_exports.BadRequestError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        default:
          throw new RivetError({
            statusCode: _response.error.statusCode,
            body: _response.error.body
          });
      }
    }
    switch (_response.error.reason) {
      case "non-json":
        throw new RivetError({
          statusCode: _response.error.statusCode,
          body: _response.error.rawBody
        });
      case "timeout":
        throw new RivetTimeoutError();
      case "unknown":
        throw new RivetError({
          message: _response.error.errorMessage
        });
    }
  }
  /**
   * Consumes a group invite to join a group.
   * @throws {Rivet.InternalError}
   * @throws {Rivet.RateLimitError}
   * @throws {Rivet.ForbiddenError}
   * @throws {Rivet.UnauthorizedError}
   * @throws {Rivet.NotFoundError}
   * @throws {Rivet.BadRequestError}
   */
  async consumeInvite(groupInviteCode) {
    const _response = await fetcher({
      url: (0, import_url_join19.default)(
        this.options.environment ?? RivetEnvironment.Production,
        `/group/invites/${groupInviteCode}/consume`
      ),
      method: "POST",
      headers: {
        Authorization: await this._getAuthorizationHeader()
      },
      contentType: "application/json"
    });
    if (_response.ok) {
      return await group_exports2.ConsumeInviteResponse.parseOrThrow(_response.body, {
        unrecognizedObjectKeys: "passthrough",
        allowUnrecognizedUnionMembers: true,
        allowUnrecognizedEnumValues: true
      });
    }
    if (_response.error.reason === "status-code") {
      switch (_response.error.statusCode) {
        case 500:
          throw new api_exports.InternalError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 429:
          throw new api_exports.RateLimitError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 403:
          throw new api_exports.ForbiddenError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 408:
          throw new api_exports.UnauthorizedError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 404:
          throw new api_exports.NotFoundError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 400:
          throw new api_exports.BadRequestError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        default:
          throw new RivetError({
            statusCode: _response.error.statusCode,
            body: _response.error.body
          });
      }
    }
    switch (_response.error.reason) {
      case "non-json":
        throw new RivetError({
          statusCode: _response.error.statusCode,
          body: _response.error.rawBody
        });
      case "timeout":
        throw new RivetTimeoutError();
      case "unknown":
        throw new RivetError({
          message: _response.error.errorMessage
        });
    }
  }
  /**
   * Creates a group invite. Can be shared with other identities to let them join this group.
   * @throws {Rivet.InternalError}
   * @throws {Rivet.RateLimitError}
   * @throws {Rivet.ForbiddenError}
   * @throws {Rivet.UnauthorizedError}
   * @throws {Rivet.NotFoundError}
   * @throws {Rivet.BadRequestError}
   */
  async createInvite(groupId, request) {
    const _response = await fetcher({
      url: (0, import_url_join19.default)(
        this.options.environment ?? RivetEnvironment.Production,
        `/group/groups/${groupId}/invites`
      ),
      method: "POST",
      headers: {
        Authorization: await this._getAuthorizationHeader()
      },
      contentType: "application/json",
      body: await group_exports2.CreateInviteRequest.jsonOrThrow(request, { unrecognizedObjectKeys: "strip" })
    });
    if (_response.ok) {
      return await group_exports2.CreateInviteResponse.parseOrThrow(_response.body, {
        unrecognizedObjectKeys: "passthrough",
        allowUnrecognizedUnionMembers: true,
        allowUnrecognizedEnumValues: true
      });
    }
    if (_response.error.reason === "status-code") {
      switch (_response.error.statusCode) {
        case 500:
          throw new api_exports.InternalError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 429:
          throw new api_exports.RateLimitError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 403:
          throw new api_exports.ForbiddenError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 408:
          throw new api_exports.UnauthorizedError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 404:
          throw new api_exports.NotFoundError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 400:
          throw new api_exports.BadRequestError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        default:
          throw new RivetError({
            statusCode: _response.error.statusCode,
            body: _response.error.body
          });
      }
    }
    switch (_response.error.reason) {
      case "non-json":
        throw new RivetError({
          statusCode: _response.error.statusCode,
          body: _response.error.rawBody
        });
      case "timeout":
        throw new RivetTimeoutError();
      case "unknown":
        throw new RivetError({
          message: _response.error.errorMessage
        });
    }
  }
  async _getAuthorizationHeader() {
    const bearer = await Supplier.get(this.options.token);
    if (bearer != null) {
      return `Bearer ${bearer}`;
    }
    return void 0;
  }
};

// src/api/resources/group/resources/joinRequests/client/Client.ts
init_core();
var import_url_join20 = __toESM(require_url_join());
init_serialization();
var JoinRequests = class {
  constructor(options) {
    this.options = options;
  }
  /**
   * Requests to join a group.
   * @throws {Rivet.InternalError}
   * @throws {Rivet.RateLimitError}
   * @throws {Rivet.ForbiddenError}
   * @throws {Rivet.UnauthorizedError}
   * @throws {Rivet.NotFoundError}
   * @throws {Rivet.BadRequestError}
   */
  async createJoinRequest(groupId) {
    const _response = await fetcher({
      url: (0, import_url_join20.default)(
        this.options.environment ?? RivetEnvironment.Production,
        `/group/groups/${groupId}/join-request`
      ),
      method: "POST",
      headers: {
        Authorization: await this._getAuthorizationHeader()
      },
      contentType: "application/json"
    });
    if (_response.ok) {
      return;
    }
    if (_response.error.reason === "status-code") {
      switch (_response.error.statusCode) {
        case 500:
          throw new api_exports.InternalError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 429:
          throw new api_exports.RateLimitError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 403:
          throw new api_exports.ForbiddenError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 408:
          throw new api_exports.UnauthorizedError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 404:
          throw new api_exports.NotFoundError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 400:
          throw new api_exports.BadRequestError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        default:
          throw new RivetError({
            statusCode: _response.error.statusCode,
            body: _response.error.body
          });
      }
    }
    switch (_response.error.reason) {
      case "non-json":
        throw new RivetError({
          statusCode: _response.error.statusCode,
          body: _response.error.rawBody
        });
      case "timeout":
        throw new RivetTimeoutError();
      case "unknown":
        throw new RivetError({
          message: _response.error.errorMessage
        });
    }
  }
  /**
   * Resolves a join request for a given group.
   * @throws {Rivet.InternalError}
   * @throws {Rivet.RateLimitError}
   * @throws {Rivet.ForbiddenError}
   * @throws {Rivet.UnauthorizedError}
   * @throws {Rivet.NotFoundError}
   * @throws {Rivet.BadRequestError}
   */
  async resolveJoinRequest(groupId, identityId, request) {
    const _response = await fetcher({
      url: (0, import_url_join20.default)(
        this.options.environment ?? RivetEnvironment.Production,
        `/group/groups/${groupId}/join-request/${identityId}`
      ),
      method: "POST",
      headers: {
        Authorization: await this._getAuthorizationHeader()
      },
      contentType: "application/json",
      body: await group_exports2.ResolveJoinRequestRequest.jsonOrThrow(request, {
        unrecognizedObjectKeys: "strip"
      })
    });
    if (_response.ok) {
      return;
    }
    if (_response.error.reason === "status-code") {
      switch (_response.error.statusCode) {
        case 500:
          throw new api_exports.InternalError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 429:
          throw new api_exports.RateLimitError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 403:
          throw new api_exports.ForbiddenError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 408:
          throw new api_exports.UnauthorizedError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 404:
          throw new api_exports.NotFoundError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 400:
          throw new api_exports.BadRequestError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        default:
          throw new RivetError({
            statusCode: _response.error.statusCode,
            body: _response.error.body
          });
      }
    }
    switch (_response.error.reason) {
      case "non-json":
        throw new RivetError({
          statusCode: _response.error.statusCode,
          body: _response.error.rawBody
        });
      case "timeout":
        throw new RivetTimeoutError();
      case "unknown":
        throw new RivetError({
          message: _response.error.errorMessage
        });
    }
  }
  async _getAuthorizationHeader() {
    const bearer = await Supplier.get(this.options.token);
    if (bearer != null) {
      return `Bearer ${bearer}`;
    }
    return void 0;
  }
};

// src/api/resources/group/client/Client.ts
var Group2 = class {
  constructor(options) {
    this.options = options;
  }
  /**
   * Returns a list of suggested groups.
   * @throws {Rivet.InternalError}
   * @throws {Rivet.RateLimitError}
   * @throws {Rivet.ForbiddenError}
   * @throws {Rivet.UnauthorizedError}
   * @throws {Rivet.NotFoundError}
   * @throws {Rivet.BadRequestError}
   */
  async listSuggested(request = {}) {
    const { watchIndex } = request;
    const _queryParams = new URLSearchParams();
    if (watchIndex != null) {
      _queryParams.append("watch_index", watchIndex);
    }
    const _response = await fetcher({
      url: (0, import_url_join21.default)(this.options.environment ?? RivetEnvironment.Production, "/group/groups"),
      method: "GET",
      headers: {
        Authorization: await this._getAuthorizationHeader()
      },
      contentType: "application/json",
      queryParameters: _queryParams
    });
    if (_response.ok) {
      return await group_exports2.ListSuggestedResponse.parseOrThrow(_response.body, {
        unrecognizedObjectKeys: "passthrough",
        allowUnrecognizedUnionMembers: true,
        allowUnrecognizedEnumValues: true
      });
    }
    if (_response.error.reason === "status-code") {
      switch (_response.error.statusCode) {
        case 500:
          throw new api_exports.InternalError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 429:
          throw new api_exports.RateLimitError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 403:
          throw new api_exports.ForbiddenError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 408:
          throw new api_exports.UnauthorizedError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 404:
          throw new api_exports.NotFoundError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 400:
          throw new api_exports.BadRequestError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        default:
          throw new RivetError({
            statusCode: _response.error.statusCode,
            body: _response.error.body
          });
      }
    }
    switch (_response.error.reason) {
      case "non-json":
        throw new RivetError({
          statusCode: _response.error.statusCode,
          body: _response.error.rawBody
        });
      case "timeout":
        throw new RivetTimeoutError();
      case "unknown":
        throw new RivetError({
          message: _response.error.errorMessage
        });
    }
  }
  /**
   * Creates a new group.
   * @throws {Rivet.InternalError}
   * @throws {Rivet.RateLimitError}
   * @throws {Rivet.ForbiddenError}
   * @throws {Rivet.UnauthorizedError}
   * @throws {Rivet.NotFoundError}
   * @throws {Rivet.BadRequestError}
   */
  async create(request) {
    const _response = await fetcher({
      url: (0, import_url_join21.default)(this.options.environment ?? RivetEnvironment.Production, "/group/groups"),
      method: "POST",
      headers: {
        Authorization: await this._getAuthorizationHeader()
      },
      contentType: "application/json",
      body: await group_exports2.CreateRequest.jsonOrThrow(request, { unrecognizedObjectKeys: "strip" })
    });
    if (_response.ok) {
      return await group_exports2.CreateResponse.parseOrThrow(_response.body, {
        unrecognizedObjectKeys: "passthrough",
        allowUnrecognizedUnionMembers: true,
        allowUnrecognizedEnumValues: true
      });
    }
    if (_response.error.reason === "status-code") {
      switch (_response.error.statusCode) {
        case 500:
          throw new api_exports.InternalError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 429:
          throw new api_exports.RateLimitError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 403:
          throw new api_exports.ForbiddenError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 408:
          throw new api_exports.UnauthorizedError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 404:
          throw new api_exports.NotFoundError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 400:
          throw new api_exports.BadRequestError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        default:
          throw new RivetError({
            statusCode: _response.error.statusCode,
            body: _response.error.body
          });
      }
    }
    switch (_response.error.reason) {
      case "non-json":
        throw new RivetError({
          statusCode: _response.error.statusCode,
          body: _response.error.rawBody
        });
      case "timeout":
        throw new RivetTimeoutError();
      case "unknown":
        throw new RivetError({
          message: _response.error.errorMessage
        });
    }
  }
  /**
   * Prepares an avatar image upload.
   * Complete upload with `rivet.api.group#CompleteAvatarUpload`.
   * @throws {Rivet.InternalError}
   * @throws {Rivet.RateLimitError}
   * @throws {Rivet.ForbiddenError}
   * @throws {Rivet.UnauthorizedError}
   * @throws {Rivet.NotFoundError}
   * @throws {Rivet.BadRequestError}
   */
  async prepareAvatarUpload(request) {
    const _response = await fetcher({
      url: (0, import_url_join21.default)(
        this.options.environment ?? RivetEnvironment.Production,
        "/group/groups/avatar-upload/prepare"
      ),
      method: "POST",
      headers: {
        Authorization: await this._getAuthorizationHeader()
      },
      contentType: "application/json",
      body: await group_exports2.PrepareAvatarUploadRequest.jsonOrThrow(request, {
        unrecognizedObjectKeys: "strip"
      })
    });
    if (_response.ok) {
      return await group_exports2.PrepareAvatarUploadResponse.parseOrThrow(_response.body, {
        unrecognizedObjectKeys: "passthrough",
        allowUnrecognizedUnionMembers: true,
        allowUnrecognizedEnumValues: true
      });
    }
    if (_response.error.reason === "status-code") {
      switch (_response.error.statusCode) {
        case 500:
          throw new api_exports.InternalError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 429:
          throw new api_exports.RateLimitError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 403:
          throw new api_exports.ForbiddenError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 408:
          throw new api_exports.UnauthorizedError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 404:
          throw new api_exports.NotFoundError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 400:
          throw new api_exports.BadRequestError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        default:
          throw new RivetError({
            statusCode: _response.error.statusCode,
            body: _response.error.body
          });
      }
    }
    switch (_response.error.reason) {
      case "non-json":
        throw new RivetError({
          statusCode: _response.error.statusCode,
          body: _response.error.rawBody
        });
      case "timeout":
        throw new RivetTimeoutError();
      case "unknown":
        throw new RivetError({
          message: _response.error.errorMessage
        });
    }
  }
  /**
   * Validate contents of group profile. Use to provide immediate feedback on profile changes before committing them.
   * @throws {Rivet.InternalError}
   * @throws {Rivet.RateLimitError}
   * @throws {Rivet.ForbiddenError}
   * @throws {Rivet.UnauthorizedError}
   * @throws {Rivet.NotFoundError}
   * @throws {Rivet.BadRequestError}
   */
  async validateProfile(request) {
    const _response = await fetcher({
      url: (0, import_url_join21.default)(
        this.options.environment ?? RivetEnvironment.Production,
        "/group/groups/profile/validate"
      ),
      method: "POST",
      headers: {
        Authorization: await this._getAuthorizationHeader()
      },
      contentType: "application/json",
      body: await group_exports2.ValidateProfileRequest.jsonOrThrow(request, {
        unrecognizedObjectKeys: "strip"
      })
    });
    if (_response.ok) {
      return await group_exports2.ValidateProfileResponse.parseOrThrow(_response.body, {
        unrecognizedObjectKeys: "passthrough",
        allowUnrecognizedUnionMembers: true,
        allowUnrecognizedEnumValues: true
      });
    }
    if (_response.error.reason === "status-code") {
      switch (_response.error.statusCode) {
        case 500:
          throw new api_exports.InternalError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 429:
          throw new api_exports.RateLimitError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 403:
          throw new api_exports.ForbiddenError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 408:
          throw new api_exports.UnauthorizedError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 404:
          throw new api_exports.NotFoundError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 400:
          throw new api_exports.BadRequestError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        default:
          throw new RivetError({
            statusCode: _response.error.statusCode,
            body: _response.error.body
          });
      }
    }
    switch (_response.error.reason) {
      case "non-json":
        throw new RivetError({
          statusCode: _response.error.statusCode,
          body: _response.error.rawBody
        });
      case "timeout":
        throw new RivetTimeoutError();
      case "unknown":
        throw new RivetError({
          message: _response.error.errorMessage
        });
    }
  }
  /**
   * Fuzzy search for groups.
   * @throws {Rivet.InternalError}
   * @throws {Rivet.RateLimitError}
   * @throws {Rivet.ForbiddenError}
   * @throws {Rivet.UnauthorizedError}
   * @throws {Rivet.NotFoundError}
   * @throws {Rivet.BadRequestError}
   */
  async search(request) {
    const { query, anchor, limit } = request;
    const _queryParams = new URLSearchParams();
    _queryParams.append("query", query);
    if (anchor != null) {
      _queryParams.append("anchor", anchor);
    }
    if (limit != null) {
      _queryParams.append("limit", limit.toString());
    }
    const _response = await fetcher({
      url: (0, import_url_join21.default)(this.options.environment ?? RivetEnvironment.Production, "/group/groups/search"),
      method: "GET",
      headers: {
        Authorization: await this._getAuthorizationHeader()
      },
      contentType: "application/json",
      queryParameters: _queryParams
    });
    if (_response.ok) {
      return await group_exports2.SearchResponse.parseOrThrow(_response.body, {
        unrecognizedObjectKeys: "passthrough",
        allowUnrecognizedUnionMembers: true,
        allowUnrecognizedEnumValues: true
      });
    }
    if (_response.error.reason === "status-code") {
      switch (_response.error.statusCode) {
        case 500:
          throw new api_exports.InternalError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 429:
          throw new api_exports.RateLimitError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 403:
          throw new api_exports.ForbiddenError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 408:
          throw new api_exports.UnauthorizedError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 404:
          throw new api_exports.NotFoundError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 400:
          throw new api_exports.BadRequestError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        default:
          throw new RivetError({
            statusCode: _response.error.statusCode,
            body: _response.error.body
          });
      }
    }
    switch (_response.error.reason) {
      case "non-json":
        throw new RivetError({
          statusCode: _response.error.statusCode,
          body: _response.error.rawBody
        });
      case "timeout":
        throw new RivetTimeoutError();
      case "unknown":
        throw new RivetError({
          message: _response.error.errorMessage
        });
    }
  }
  /**
   * Completes an avatar image upload. Must be called after the file upload
   * process completes.
   * Call `rivet.api.group#PrepareAvatarUpload` first.
   * @throws {Rivet.InternalError}
   * @throws {Rivet.RateLimitError}
   * @throws {Rivet.ForbiddenError}
   * @throws {Rivet.UnauthorizedError}
   * @throws {Rivet.NotFoundError}
   * @throws {Rivet.BadRequestError}
   */
  async completeAvatarUpload(groupId, uploadId) {
    const _response = await fetcher({
      url: (0, import_url_join21.default)(
        this.options.environment ?? RivetEnvironment.Production,
        `/group/groups/${groupId}/avatar-upload/${uploadId}/complete`
      ),
      method: "POST",
      headers: {
        Authorization: await this._getAuthorizationHeader()
      },
      contentType: "application/json"
    });
    if (_response.ok) {
      return;
    }
    if (_response.error.reason === "status-code") {
      switch (_response.error.statusCode) {
        case 500:
          throw new api_exports.InternalError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 429:
          throw new api_exports.RateLimitError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 403:
          throw new api_exports.ForbiddenError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 408:
          throw new api_exports.UnauthorizedError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 404:
          throw new api_exports.NotFoundError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 400:
          throw new api_exports.BadRequestError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        default:
          throw new RivetError({
            statusCode: _response.error.statusCode,
            body: _response.error.body
          });
      }
    }
    switch (_response.error.reason) {
      case "non-json":
        throw new RivetError({
          statusCode: _response.error.statusCode,
          body: _response.error.rawBody
        });
      case "timeout":
        throw new RivetTimeoutError();
      case "unknown":
        throw new RivetError({
          message: _response.error.errorMessage
        });
    }
  }
  /**
   * Returns a group's bans. Must have valid permissions to view.
   * @throws {Rivet.InternalError}
   * @throws {Rivet.RateLimitError}
   * @throws {Rivet.ForbiddenError}
   * @throws {Rivet.UnauthorizedError}
   * @throws {Rivet.NotFoundError}
   * @throws {Rivet.BadRequestError}
   */
  async getBans(groupId, request = {}) {
    const { anchor, count, watchIndex } = request;
    const _queryParams = new URLSearchParams();
    if (anchor != null) {
      _queryParams.append("anchor", anchor);
    }
    if (count != null) {
      _queryParams.append("count", count.toString());
    }
    if (watchIndex != null) {
      _queryParams.append("watch_index", watchIndex);
    }
    const _response = await fetcher({
      url: (0, import_url_join21.default)(
        this.options.environment ?? RivetEnvironment.Production,
        `/group/groups/${groupId}/bans`
      ),
      method: "GET",
      headers: {
        Authorization: await this._getAuthorizationHeader()
      },
      contentType: "application/json",
      queryParameters: _queryParams
    });
    if (_response.ok) {
      return await group_exports2.GetBansResponse.parseOrThrow(_response.body, {
        unrecognizedObjectKeys: "passthrough",
        allowUnrecognizedUnionMembers: true,
        allowUnrecognizedEnumValues: true
      });
    }
    if (_response.error.reason === "status-code") {
      switch (_response.error.statusCode) {
        case 500:
          throw new api_exports.InternalError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 429:
          throw new api_exports.RateLimitError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 403:
          throw new api_exports.ForbiddenError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 408:
          throw new api_exports.UnauthorizedError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 404:
          throw new api_exports.NotFoundError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 400:
          throw new api_exports.BadRequestError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        default:
          throw new RivetError({
            statusCode: _response.error.statusCode,
            body: _response.error.body
          });
      }
    }
    switch (_response.error.reason) {
      case "non-json":
        throw new RivetError({
          statusCode: _response.error.statusCode,
          body: _response.error.rawBody
        });
      case "timeout":
        throw new RivetTimeoutError();
      case "unknown":
        throw new RivetError({
          message: _response.error.errorMessage
        });
    }
  }
  /**
   * Bans an identity from a group. Must be the owner of the group to perform this action. The banned identity will no longer be able to create a join request or use a group invite.
   * @throws {Rivet.InternalError}
   * @throws {Rivet.RateLimitError}
   * @throws {Rivet.ForbiddenError}
   * @throws {Rivet.UnauthorizedError}
   * @throws {Rivet.NotFoundError}
   * @throws {Rivet.BadRequestError}
   */
  async banIdentity(groupId, identityId) {
    const _response = await fetcher({
      url: (0, import_url_join21.default)(
        this.options.environment ?? RivetEnvironment.Production,
        `/group/groups/${groupId}/bans/${identityId}`
      ),
      method: "POST",
      headers: {
        Authorization: await this._getAuthorizationHeader()
      },
      contentType: "application/json"
    });
    if (_response.ok) {
      return;
    }
    if (_response.error.reason === "status-code") {
      switch (_response.error.statusCode) {
        case 500:
          throw new api_exports.InternalError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 429:
          throw new api_exports.RateLimitError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 403:
          throw new api_exports.ForbiddenError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 408:
          throw new api_exports.UnauthorizedError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 404:
          throw new api_exports.NotFoundError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 400:
          throw new api_exports.BadRequestError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        default:
          throw new RivetError({
            statusCode: _response.error.statusCode,
            body: _response.error.body
          });
      }
    }
    switch (_response.error.reason) {
      case "non-json":
        throw new RivetError({
          statusCode: _response.error.statusCode,
          body: _response.error.rawBody
        });
      case "timeout":
        throw new RivetTimeoutError();
      case "unknown":
        throw new RivetError({
          message: _response.error.errorMessage
        });
    }
  }
  /**
   * Unbans an identity from a group. Must be the owner of the group to perform this action.
   * @throws {Rivet.InternalError}
   * @throws {Rivet.RateLimitError}
   * @throws {Rivet.ForbiddenError}
   * @throws {Rivet.UnauthorizedError}
   * @throws {Rivet.NotFoundError}
   * @throws {Rivet.BadRequestError}
   */
  async unbanIdentity(groupId, identityId) {
    const _response = await fetcher({
      url: (0, import_url_join21.default)(
        this.options.environment ?? RivetEnvironment.Production,
        `/group/groups/${groupId}/bans/${identityId}`
      ),
      method: "DELETE",
      headers: {
        Authorization: await this._getAuthorizationHeader()
      },
      contentType: "application/json"
    });
    if (_response.ok) {
      return;
    }
    if (_response.error.reason === "status-code") {
      switch (_response.error.statusCode) {
        case 500:
          throw new api_exports.InternalError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 429:
          throw new api_exports.RateLimitError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 403:
          throw new api_exports.ForbiddenError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 408:
          throw new api_exports.UnauthorizedError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 404:
          throw new api_exports.NotFoundError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 400:
          throw new api_exports.BadRequestError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        default:
          throw new RivetError({
            statusCode: _response.error.statusCode,
            body: _response.error.body
          });
      }
    }
    switch (_response.error.reason) {
      case "non-json":
        throw new RivetError({
          statusCode: _response.error.statusCode,
          body: _response.error.rawBody
        });
      case "timeout":
        throw new RivetTimeoutError();
      case "unknown":
        throw new RivetError({
          message: _response.error.errorMessage
        });
    }
  }
  /**
   * Returns a group's join requests. Must have valid permissions to view.
   * @throws {Rivet.InternalError}
   * @throws {Rivet.RateLimitError}
   * @throws {Rivet.ForbiddenError}
   * @throws {Rivet.UnauthorizedError}
   * @throws {Rivet.NotFoundError}
   * @throws {Rivet.BadRequestError}
   */
  async getJoinRequests(groupId, request = {}) {
    const { anchor, count, watchIndex } = request;
    const _queryParams = new URLSearchParams();
    if (anchor != null) {
      _queryParams.append("anchor", anchor);
    }
    if (count != null) {
      _queryParams.append("count", count.toString());
    }
    if (watchIndex != null) {
      _queryParams.append("watch_index", watchIndex);
    }
    const _response = await fetcher({
      url: (0, import_url_join21.default)(
        this.options.environment ?? RivetEnvironment.Production,
        `/group/groups/${groupId}/join-requests`
      ),
      method: "GET",
      headers: {
        Authorization: await this._getAuthorizationHeader()
      },
      contentType: "application/json",
      queryParameters: _queryParams
    });
    if (_response.ok) {
      return await group_exports2.GetJoinRequestsResponse.parseOrThrow(_response.body, {
        unrecognizedObjectKeys: "passthrough",
        allowUnrecognizedUnionMembers: true,
        allowUnrecognizedEnumValues: true
      });
    }
    if (_response.error.reason === "status-code") {
      switch (_response.error.statusCode) {
        case 500:
          throw new api_exports.InternalError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 429:
          throw new api_exports.RateLimitError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 403:
          throw new api_exports.ForbiddenError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 408:
          throw new api_exports.UnauthorizedError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 404:
          throw new api_exports.NotFoundError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 400:
          throw new api_exports.BadRequestError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        default:
          throw new RivetError({
            statusCode: _response.error.statusCode,
            body: _response.error.body
          });
      }
    }
    switch (_response.error.reason) {
      case "non-json":
        throw new RivetError({
          statusCode: _response.error.statusCode,
          body: _response.error.rawBody
        });
      case "timeout":
        throw new RivetTimeoutError();
      case "unknown":
        throw new RivetError({
          message: _response.error.errorMessage
        });
    }
  }
  /**
   * Kicks an identity from a group. Must be the owner of the group to perform this action.
   * @throws {Rivet.InternalError}
   * @throws {Rivet.RateLimitError}
   * @throws {Rivet.ForbiddenError}
   * @throws {Rivet.UnauthorizedError}
   * @throws {Rivet.NotFoundError}
   * @throws {Rivet.BadRequestError}
   */
  async kickMember(groupId, identityId) {
    const _response = await fetcher({
      url: (0, import_url_join21.default)(
        this.options.environment ?? RivetEnvironment.Production,
        `/group/groups/${groupId}/kick/${identityId}`
      ),
      method: "POST",
      headers: {
        Authorization: await this._getAuthorizationHeader()
      },
      contentType: "application/json"
    });
    if (_response.ok) {
      return;
    }
    if (_response.error.reason === "status-code") {
      switch (_response.error.statusCode) {
        case 500:
          throw new api_exports.InternalError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 429:
          throw new api_exports.RateLimitError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 403:
          throw new api_exports.ForbiddenError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 408:
          throw new api_exports.UnauthorizedError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 404:
          throw new api_exports.NotFoundError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 400:
          throw new api_exports.BadRequestError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        default:
          throw new RivetError({
            statusCode: _response.error.statusCode,
            body: _response.error.body
          });
      }
    }
    switch (_response.error.reason) {
      case "non-json":
        throw new RivetError({
          statusCode: _response.error.statusCode,
          body: _response.error.rawBody
        });
      case "timeout":
        throw new RivetTimeoutError();
      case "unknown":
        throw new RivetError({
          message: _response.error.errorMessage
        });
    }
  }
  /**
   * Leaves a group.
   * @throws {Rivet.InternalError}
   * @throws {Rivet.RateLimitError}
   * @throws {Rivet.ForbiddenError}
   * @throws {Rivet.UnauthorizedError}
   * @throws {Rivet.NotFoundError}
   * @throws {Rivet.BadRequestError}
   */
  async leave(groupId) {
    const _response = await fetcher({
      url: (0, import_url_join21.default)(
        this.options.environment ?? RivetEnvironment.Production,
        `/group/groups/${groupId}/leave`
      ),
      method: "POST",
      headers: {
        Authorization: await this._getAuthorizationHeader()
      },
      contentType: "application/json"
    });
    if (_response.ok) {
      return;
    }
    if (_response.error.reason === "status-code") {
      switch (_response.error.statusCode) {
        case 500:
          throw new api_exports.InternalError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 429:
          throw new api_exports.RateLimitError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 403:
          throw new api_exports.ForbiddenError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 408:
          throw new api_exports.UnauthorizedError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 404:
          throw new api_exports.NotFoundError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 400:
          throw new api_exports.BadRequestError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        default:
          throw new RivetError({
            statusCode: _response.error.statusCode,
            body: _response.error.body
          });
      }
    }
    switch (_response.error.reason) {
      case "non-json":
        throw new RivetError({
          statusCode: _response.error.statusCode,
          body: _response.error.rawBody
        });
      case "timeout":
        throw new RivetTimeoutError();
      case "unknown":
        throw new RivetError({
          message: _response.error.errorMessage
        });
    }
  }
  /**
   * Returns a group's members.
   * @throws {Rivet.InternalError}
   * @throws {Rivet.RateLimitError}
   * @throws {Rivet.ForbiddenError}
   * @throws {Rivet.UnauthorizedError}
   * @throws {Rivet.NotFoundError}
   * @throws {Rivet.BadRequestError}
   */
  async getMembers(groupId, request = {}) {
    const { anchor, count, watchIndex } = request;
    const _queryParams = new URLSearchParams();
    if (anchor != null) {
      _queryParams.append("anchor", anchor);
    }
    if (count != null) {
      _queryParams.append("count", count.toString());
    }
    if (watchIndex != null) {
      _queryParams.append("watch_index", watchIndex);
    }
    const _response = await fetcher({
      url: (0, import_url_join21.default)(
        this.options.environment ?? RivetEnvironment.Production,
        `/group/groups/${groupId}/members`
      ),
      method: "GET",
      headers: {
        Authorization: await this._getAuthorizationHeader()
      },
      contentType: "application/json",
      queryParameters: _queryParams
    });
    if (_response.ok) {
      return await group_exports2.GetMembersResponse.parseOrThrow(_response.body, {
        unrecognizedObjectKeys: "passthrough",
        allowUnrecognizedUnionMembers: true,
        allowUnrecognizedEnumValues: true
      });
    }
    if (_response.error.reason === "status-code") {
      switch (_response.error.statusCode) {
        case 500:
          throw new api_exports.InternalError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 429:
          throw new api_exports.RateLimitError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 403:
          throw new api_exports.ForbiddenError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 408:
          throw new api_exports.UnauthorizedError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 404:
          throw new api_exports.NotFoundError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 400:
          throw new api_exports.BadRequestError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        default:
          throw new RivetError({
            statusCode: _response.error.statusCode,
            body: _response.error.body
          });
      }
    }
    switch (_response.error.reason) {
      case "non-json":
        throw new RivetError({
          statusCode: _response.error.statusCode,
          body: _response.error.rawBody
        });
      case "timeout":
        throw new RivetTimeoutError();
      case "unknown":
        throw new RivetError({
          message: _response.error.errorMessage
        });
    }
  }
  /**
   * Returns a group profile.
   * @throws {Rivet.InternalError}
   * @throws {Rivet.RateLimitError}
   * @throws {Rivet.ForbiddenError}
   * @throws {Rivet.UnauthorizedError}
   * @throws {Rivet.NotFoundError}
   * @throws {Rivet.BadRequestError}
   */
  async getProfile(groupId, request = {}) {
    const { watchIndex } = request;
    const _queryParams = new URLSearchParams();
    if (watchIndex != null) {
      _queryParams.append("watch_index", watchIndex);
    }
    const _response = await fetcher({
      url: (0, import_url_join21.default)(
        this.options.environment ?? RivetEnvironment.Production,
        `/group/groups/${groupId}/profile`
      ),
      method: "GET",
      headers: {
        Authorization: await this._getAuthorizationHeader()
      },
      contentType: "application/json",
      queryParameters: _queryParams
    });
    if (_response.ok) {
      return await group_exports2.GetProfileResponse.parseOrThrow(_response.body, {
        unrecognizedObjectKeys: "passthrough",
        allowUnrecognizedUnionMembers: true,
        allowUnrecognizedEnumValues: true
      });
    }
    if (_response.error.reason === "status-code") {
      switch (_response.error.statusCode) {
        case 500:
          throw new api_exports.InternalError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 429:
          throw new api_exports.RateLimitError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 403:
          throw new api_exports.ForbiddenError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 408:
          throw new api_exports.UnauthorizedError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 404:
          throw new api_exports.NotFoundError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 400:
          throw new api_exports.BadRequestError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        default:
          throw new RivetError({
            statusCode: _response.error.statusCode,
            body: _response.error.body
          });
      }
    }
    switch (_response.error.reason) {
      case "non-json":
        throw new RivetError({
          statusCode: _response.error.statusCode,
          body: _response.error.rawBody
        });
      case "timeout":
        throw new RivetTimeoutError();
      case "unknown":
        throw new RivetError({
          message: _response.error.errorMessage
        });
    }
  }
  /**
   * @throws {Rivet.InternalError}
   * @throws {Rivet.RateLimitError}
   * @throws {Rivet.ForbiddenError}
   * @throws {Rivet.UnauthorizedError}
   * @throws {Rivet.NotFoundError}
   * @throws {Rivet.BadRequestError}
   */
  async updateProfile(groupId, request) {
    const _response = await fetcher({
      url: (0, import_url_join21.default)(
        this.options.environment ?? RivetEnvironment.Production,
        `/group/groups/${groupId}/profile`
      ),
      method: "POST",
      headers: {
        Authorization: await this._getAuthorizationHeader()
      },
      contentType: "application/json",
      body: await group_exports2.UpdateProfileRequest.jsonOrThrow(request, {
        unrecognizedObjectKeys: "strip"
      })
    });
    if (_response.ok) {
      return;
    }
    if (_response.error.reason === "status-code") {
      switch (_response.error.statusCode) {
        case 500:
          throw new api_exports.InternalError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 429:
          throw new api_exports.RateLimitError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 403:
          throw new api_exports.ForbiddenError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 408:
          throw new api_exports.UnauthorizedError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 404:
          throw new api_exports.NotFoundError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 400:
          throw new api_exports.BadRequestError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        default:
          throw new RivetError({
            statusCode: _response.error.statusCode,
            body: _response.error.body
          });
      }
    }
    switch (_response.error.reason) {
      case "non-json":
        throw new RivetError({
          statusCode: _response.error.statusCode,
          body: _response.error.rawBody
        });
      case "timeout":
        throw new RivetTimeoutError();
      case "unknown":
        throw new RivetError({
          message: _response.error.errorMessage
        });
    }
  }
  /**
   * @throws {Rivet.InternalError}
   * @throws {Rivet.RateLimitError}
   * @throws {Rivet.ForbiddenError}
   * @throws {Rivet.UnauthorizedError}
   * @throws {Rivet.NotFoundError}
   * @throws {Rivet.BadRequestError}
   */
  async getSummary(groupId) {
    const _response = await fetcher({
      url: (0, import_url_join21.default)(
        this.options.environment ?? RivetEnvironment.Production,
        `/group/groups/${groupId}/summary`
      ),
      method: "GET",
      headers: {
        Authorization: await this._getAuthorizationHeader()
      },
      contentType: "application/json"
    });
    if (_response.ok) {
      return await group_exports2.GetSummaryResponse.parseOrThrow(_response.body, {
        unrecognizedObjectKeys: "passthrough",
        allowUnrecognizedUnionMembers: true,
        allowUnrecognizedEnumValues: true
      });
    }
    if (_response.error.reason === "status-code") {
      switch (_response.error.statusCode) {
        case 500:
          throw new api_exports.InternalError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 429:
          throw new api_exports.RateLimitError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 403:
          throw new api_exports.ForbiddenError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 408:
          throw new api_exports.UnauthorizedError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 404:
          throw new api_exports.NotFoundError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 400:
          throw new api_exports.BadRequestError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        default:
          throw new RivetError({
            statusCode: _response.error.statusCode,
            body: _response.error.body
          });
      }
    }
    switch (_response.error.reason) {
      case "non-json":
        throw new RivetError({
          statusCode: _response.error.statusCode,
          body: _response.error.rawBody
        });
      case "timeout":
        throw new RivetTimeoutError();
      case "unknown":
        throw new RivetError({
          message: _response.error.errorMessage
        });
    }
  }
  /**
   * Transfers ownership of a group to another identity.
   * @throws {Rivet.InternalError}
   * @throws {Rivet.RateLimitError}
   * @throws {Rivet.ForbiddenError}
   * @throws {Rivet.UnauthorizedError}
   * @throws {Rivet.NotFoundError}
   * @throws {Rivet.BadRequestError}
   */
  async transferOwnership(groupId, request) {
    const _response = await fetcher({
      url: (0, import_url_join21.default)(
        this.options.environment ?? RivetEnvironment.Production,
        `/group/groups/${groupId}/transfer-owner`
      ),
      method: "POST",
      headers: {
        Authorization: await this._getAuthorizationHeader()
      },
      contentType: "application/json",
      body: await group_exports2.TransferOwnershipRequest.jsonOrThrow(request, {
        unrecognizedObjectKeys: "strip"
      })
    });
    if (_response.ok) {
      return;
    }
    if (_response.error.reason === "status-code") {
      switch (_response.error.statusCode) {
        case 500:
          throw new api_exports.InternalError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 429:
          throw new api_exports.RateLimitError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 403:
          throw new api_exports.ForbiddenError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 408:
          throw new api_exports.UnauthorizedError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 404:
          throw new api_exports.NotFoundError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 400:
          throw new api_exports.BadRequestError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        default:
          throw new RivetError({
            statusCode: _response.error.statusCode,
            body: _response.error.body
          });
      }
    }
    switch (_response.error.reason) {
      case "non-json":
        throw new RivetError({
          statusCode: _response.error.statusCode,
          body: _response.error.rawBody
        });
      case "timeout":
        throw new RivetTimeoutError();
      case "unknown":
        throw new RivetError({
          message: _response.error.errorMessage
        });
    }
  }
  _invites;
  get invites() {
    return this._invites ?? (this._invites = new Invites(this.options));
  }
  _joinRequests;
  get joinRequests() {
    return this._joinRequests ?? (this._joinRequests = new JoinRequests(this.options));
  }
  async _getAuthorizationHeader() {
    const bearer = await Supplier.get(this.options.token);
    if (bearer != null) {
      return `Bearer ${bearer}`;
    }
    return void 0;
  }
};

// src/api/resources/identity/client/Client.ts
init_core();
var import_url_join24 = __toESM(require_url_join());
init_serialization();

// src/api/resources/identity/resources/events/client/Client.ts
init_core();
var import_url_join22 = __toESM(require_url_join());
init_serialization();
var Events = class {
  constructor(options) {
    this.options = options;
  }
  /**
   * Returns all events relative to the current identity.
   * @throws {Rivet.InternalError}
   * @throws {Rivet.RateLimitError}
   * @throws {Rivet.ForbiddenError}
   * @throws {Rivet.UnauthorizedError}
   * @throws {Rivet.NotFoundError}
   * @throws {Rivet.BadRequestError}
   */
  async watch(request = {}) {
    const { watchIndex } = request;
    const _queryParams = new URLSearchParams();
    if (watchIndex != null) {
      _queryParams.append("watch_index", watchIndex);
    }
    const _response = await fetcher({
      url: (0, import_url_join22.default)(this.options.environment ?? RivetEnvironment.Production, "/identity/events/live"),
      method: "GET",
      headers: {
        Authorization: await this._getAuthorizationHeader()
      },
      contentType: "application/json",
      queryParameters: _queryParams
    });
    if (_response.ok) {
      return await identity_exports4.WatchEventsResponse.parseOrThrow(_response.body, {
        unrecognizedObjectKeys: "passthrough",
        allowUnrecognizedUnionMembers: true,
        allowUnrecognizedEnumValues: true
      });
    }
    if (_response.error.reason === "status-code") {
      switch (_response.error.statusCode) {
        case 500:
          throw new api_exports.InternalError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 429:
          throw new api_exports.RateLimitError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 403:
          throw new api_exports.ForbiddenError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 408:
          throw new api_exports.UnauthorizedError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 404:
          throw new api_exports.NotFoundError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 400:
          throw new api_exports.BadRequestError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        default:
          throw new RivetError({
            statusCode: _response.error.statusCode,
            body: _response.error.body
          });
      }
    }
    switch (_response.error.reason) {
      case "non-json":
        throw new RivetError({
          statusCode: _response.error.statusCode,
          body: _response.error.rawBody
        });
      case "timeout":
        throw new RivetTimeoutError();
      case "unknown":
        throw new RivetError({
          message: _response.error.errorMessage
        });
    }
  }
  async _getAuthorizationHeader() {
    const bearer = await Supplier.get(this.options.token);
    if (bearer != null) {
      return `Bearer ${bearer}`;
    }
    return void 0;
  }
};

// src/api/resources/identity/resources/links/client/Client.ts
init_core();
var import_url_join23 = __toESM(require_url_join());
init_serialization();
var Links2 = class {
  constructor(options) {
    this.options = options;
  }
  /**
   * Begins the process for linking an identity with the Rivet Hub.
   * # Importance of Linking Identities
   * When an identity is created via `rivet.api.identity#SetupIdentity`, the identity is temporary
   * and is not shared with other games the user plays.
   * In order to make the identity permanent and synchronize the identity with
   * other games, the identity must be linked with the hub.
   * # Linking Process
   * The linking process works by opening `identity_link_url` in a browser then polling
   * `rivet.api.identity#GetGameLink` to wait for it to complete.
   * This is designed to be as flexible as possible so `identity_link_url` can be opened
   * on any device. For example, when playing a console game, the user can scan a
   * QR code for `identity_link_url` to authenticate on their phone.
   *
   * @throws {Rivet.InternalError}
   * @throws {Rivet.RateLimitError}
   * @throws {Rivet.ForbiddenError}
   * @throws {Rivet.UnauthorizedError}
   * @throws {Rivet.NotFoundError}
   * @throws {Rivet.BadRequestError}
   */
  async prepare() {
    const _response = await fetcher({
      url: (0, import_url_join23.default)(this.options.environment ?? RivetEnvironment.Production, "/identity/game-links"),
      method: "POST",
      headers: {
        Authorization: await this._getAuthorizationHeader()
      },
      contentType: "application/json"
    });
    if (_response.ok) {
      return await identity_exports4.PrepareGameLinkResponse.parseOrThrow(_response.body, {
        unrecognizedObjectKeys: "passthrough",
        allowUnrecognizedUnionMembers: true,
        allowUnrecognizedEnumValues: true
      });
    }
    if (_response.error.reason === "status-code") {
      switch (_response.error.statusCode) {
        case 500:
          throw new api_exports.InternalError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 429:
          throw new api_exports.RateLimitError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 403:
          throw new api_exports.ForbiddenError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 408:
          throw new api_exports.UnauthorizedError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 404:
          throw new api_exports.NotFoundError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 400:
          throw new api_exports.BadRequestError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        default:
          throw new RivetError({
            statusCode: _response.error.statusCode,
            body: _response.error.body
          });
      }
    }
    switch (_response.error.reason) {
      case "non-json":
        throw new RivetError({
          statusCode: _response.error.statusCode,
          body: _response.error.rawBody
        });
      case "timeout":
        throw new RivetTimeoutError();
      case "unknown":
        throw new RivetError({
          message: _response.error.errorMessage
        });
    }
  }
  /**
   * Returns the current status of a linking process. Once `status` is `complete`, the identity's profile should be fetched again since they may have switched accounts.
   * @throws {Rivet.InternalError}
   * @throws {Rivet.RateLimitError}
   * @throws {Rivet.ForbiddenError}
   * @throws {Rivet.UnauthorizedError}
   * @throws {Rivet.NotFoundError}
   * @throws {Rivet.BadRequestError}
   */
  async get(request) {
    const { identityLinkToken, watchIndex } = request;
    const _queryParams = new URLSearchParams();
    _queryParams.append("identity_link_token", identityLinkToken);
    if (watchIndex != null) {
      _queryParams.append("watch_index", watchIndex);
    }
    const _response = await fetcher({
      url: (0, import_url_join23.default)(this.options.environment ?? RivetEnvironment.Production, "/identity/game-links"),
      method: "GET",
      headers: {
        Authorization: await this._getAuthorizationHeader()
      },
      contentType: "application/json",
      queryParameters: _queryParams
    });
    if (_response.ok) {
      return await identity_exports4.GetGameLinkResponse.parseOrThrow(_response.body, {
        unrecognizedObjectKeys: "passthrough",
        allowUnrecognizedUnionMembers: true,
        allowUnrecognizedEnumValues: true
      });
    }
    if (_response.error.reason === "status-code") {
      switch (_response.error.statusCode) {
        case 500:
          throw new api_exports.InternalError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 429:
          throw new api_exports.RateLimitError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 403:
          throw new api_exports.ForbiddenError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 408:
          throw new api_exports.UnauthorizedError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 404:
          throw new api_exports.NotFoundError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 400:
          throw new api_exports.BadRequestError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        default:
          throw new RivetError({
            statusCode: _response.error.statusCode,
            body: _response.error.body
          });
      }
    }
    switch (_response.error.reason) {
      case "non-json":
        throw new RivetError({
          statusCode: _response.error.statusCode,
          body: _response.error.rawBody
        });
      case "timeout":
        throw new RivetTimeoutError();
      case "unknown":
        throw new RivetError({
          message: _response.error.errorMessage
        });
    }
  }
  async _getAuthorizationHeader() {
    const bearer = await Supplier.get(this.options.token);
    if (bearer != null) {
      return `Bearer ${bearer}`;
    }
    return void 0;
  }
};

// src/api/resources/identity/client/Client.ts
var Identity = class {
  constructor(options) {
    this.options = options;
  }
  /**
   * Gets or creates an identity.
   * Passing an existing identity token in the body refreshes the token.
   * Temporary Accounts
   * Until the identity is linked with the Rivet Hub (see `PrepareGameLink`), this identity will be temporary but still behave like all other identities.
   * This is intended to allow users to play the game without signing up while still having the benefits of having an account. When they are ready to save their account, they should be instructed to link their account (see `PrepareGameLink`).
   * Storing Token
   * `identity_token` should be stored in some form of persistent storage. The token should be read from storage and passed to `Setup` every time the client starts.
   * @throws {Rivet.InternalError}
   * @throws {Rivet.RateLimitError}
   * @throws {Rivet.ForbiddenError}
   * @throws {Rivet.UnauthorizedError}
   * @throws {Rivet.NotFoundError}
   * @throws {Rivet.BadRequestError}
   */
  async setup(request = {}) {
    const _response = await fetcher({
      url: (0, import_url_join24.default)(this.options.environment ?? RivetEnvironment.Production, "/identity/identities"),
      method: "POST",
      headers: {
        Authorization: await this._getAuthorizationHeader()
      },
      contentType: "application/json",
      body: await identity_exports4.SetupRequest.jsonOrThrow(request, { unrecognizedObjectKeys: "strip" })
    });
    if (_response.ok) {
      return await identity_exports4.SetupResponse.parseOrThrow(_response.body, {
        unrecognizedObjectKeys: "passthrough",
        allowUnrecognizedUnionMembers: true,
        allowUnrecognizedEnumValues: true
      });
    }
    if (_response.error.reason === "status-code") {
      switch (_response.error.statusCode) {
        case 500:
          throw new api_exports.InternalError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 429:
          throw new api_exports.RateLimitError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 403:
          throw new api_exports.ForbiddenError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 408:
          throw new api_exports.UnauthorizedError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 404:
          throw new api_exports.NotFoundError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 400:
          throw new api_exports.BadRequestError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        default:
          throw new RivetError({
            statusCode: _response.error.statusCode,
            body: _response.error.body
          });
      }
    }
    switch (_response.error.reason) {
      case "non-json":
        throw new RivetError({
          statusCode: _response.error.statusCode,
          body: _response.error.rawBody
        });
      case "timeout":
        throw new RivetTimeoutError();
      case "unknown":
        throw new RivetError({
          message: _response.error.errorMessage
        });
    }
  }
  /**
   * Fetches an identity profile.
   * @throws {Rivet.InternalError}
   * @throws {Rivet.RateLimitError}
   * @throws {Rivet.ForbiddenError}
   * @throws {Rivet.UnauthorizedError}
   * @throws {Rivet.NotFoundError}
   * @throws {Rivet.BadRequestError}
   */
  async getProfile(identityId, request = {}) {
    const { watchIndex } = request;
    const _queryParams = new URLSearchParams();
    if (watchIndex != null) {
      _queryParams.append("watch_index", watchIndex);
    }
    const _response = await fetcher({
      url: (0, import_url_join24.default)(
        this.options.environment ?? RivetEnvironment.Production,
        `/identity/identities/${identityId}/profile`
      ),
      method: "GET",
      headers: {
        Authorization: await this._getAuthorizationHeader()
      },
      contentType: "application/json",
      queryParameters: _queryParams
    });
    if (_response.ok) {
      return await identity_exports4.GetProfileResponse.parseOrThrow(_response.body, {
        unrecognizedObjectKeys: "passthrough",
        allowUnrecognizedUnionMembers: true,
        allowUnrecognizedEnumValues: true
      });
    }
    if (_response.error.reason === "status-code") {
      switch (_response.error.statusCode) {
        case 500:
          throw new api_exports.InternalError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 429:
          throw new api_exports.RateLimitError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 403:
          throw new api_exports.ForbiddenError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 408:
          throw new api_exports.UnauthorizedError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 404:
          throw new api_exports.NotFoundError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 400:
          throw new api_exports.BadRequestError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        default:
          throw new RivetError({
            statusCode: _response.error.statusCode,
            body: _response.error.body
          });
      }
    }
    switch (_response.error.reason) {
      case "non-json":
        throw new RivetError({
          statusCode: _response.error.statusCode,
          body: _response.error.rawBody
        });
      case "timeout":
        throw new RivetTimeoutError();
      case "unknown":
        throw new RivetError({
          message: _response.error.errorMessage
        });
    }
  }
  /**
   * Fetches the current identity's profile.
   * @throws {Rivet.InternalError}
   * @throws {Rivet.RateLimitError}
   * @throws {Rivet.ForbiddenError}
   * @throws {Rivet.UnauthorizedError}
   * @throws {Rivet.NotFoundError}
   * @throws {Rivet.BadRequestError}
   */
  async getSelfProfile(request = {}) {
    const { watchIndex } = request;
    const _queryParams = new URLSearchParams();
    if (watchIndex != null) {
      _queryParams.append("watch_index", watchIndex);
    }
    const _response = await fetcher({
      url: (0, import_url_join24.default)(
        this.options.environment ?? RivetEnvironment.Production,
        "/identity/identities/self/profile"
      ),
      method: "GET",
      headers: {
        Authorization: await this._getAuthorizationHeader()
      },
      contentType: "application/json",
      queryParameters: _queryParams
    });
    if (_response.ok) {
      return await identity_exports4.GetProfileResponse.parseOrThrow(_response.body, {
        unrecognizedObjectKeys: "passthrough",
        allowUnrecognizedUnionMembers: true,
        allowUnrecognizedEnumValues: true
      });
    }
    if (_response.error.reason === "status-code") {
      switch (_response.error.statusCode) {
        case 500:
          throw new api_exports.InternalError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 429:
          throw new api_exports.RateLimitError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 403:
          throw new api_exports.ForbiddenError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 408:
          throw new api_exports.UnauthorizedError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 404:
          throw new api_exports.NotFoundError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 400:
          throw new api_exports.BadRequestError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        default:
          throw new RivetError({
            statusCode: _response.error.statusCode,
            body: _response.error.body
          });
      }
    }
    switch (_response.error.reason) {
      case "non-json":
        throw new RivetError({
          statusCode: _response.error.statusCode,
          body: _response.error.rawBody
        });
      case "timeout":
        throw new RivetTimeoutError();
      case "unknown":
        throw new RivetError({
          message: _response.error.errorMessage
        });
    }
  }
  /**
   * Fetches a list of identity handles.
   * @throws {Rivet.InternalError}
   * @throws {Rivet.RateLimitError}
   * @throws {Rivet.ForbiddenError}
   * @throws {Rivet.UnauthorizedError}
   * @throws {Rivet.NotFoundError}
   * @throws {Rivet.BadRequestError}
   */
  async getHandles(request) {
    const { identityIds } = request;
    const _queryParams = new URLSearchParams();
    if (Array.isArray(identityIds)) {
      for (const _item of identityIds) {
        _queryParams.append("identity_ids", _item);
      }
    } else {
      _queryParams.append("identity_ids", identityIds);
    }
    const _response = await fetcher({
      url: (0, import_url_join24.default)(
        this.options.environment ?? RivetEnvironment.Production,
        "/identity/identities/batch/handle"
      ),
      method: "GET",
      headers: {
        Authorization: await this._getAuthorizationHeader()
      },
      contentType: "application/json",
      queryParameters: _queryParams
    });
    if (_response.ok) {
      return await identity_exports4.GetHandlesResponse.parseOrThrow(_response.body, {
        unrecognizedObjectKeys: "passthrough",
        allowUnrecognizedUnionMembers: true,
        allowUnrecognizedEnumValues: true
      });
    }
    if (_response.error.reason === "status-code") {
      switch (_response.error.statusCode) {
        case 500:
          throw new api_exports.InternalError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 429:
          throw new api_exports.RateLimitError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 403:
          throw new api_exports.ForbiddenError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 408:
          throw new api_exports.UnauthorizedError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 404:
          throw new api_exports.NotFoundError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 400:
          throw new api_exports.BadRequestError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        default:
          throw new RivetError({
            statusCode: _response.error.statusCode,
            body: _response.error.body
          });
      }
    }
    switch (_response.error.reason) {
      case "non-json":
        throw new RivetError({
          statusCode: _response.error.statusCode,
          body: _response.error.rawBody
        });
      case "timeout":
        throw new RivetTimeoutError();
      case "unknown":
        throw new RivetError({
          message: _response.error.errorMessage
        });
    }
  }
  /**
   * Fetches a list of identity summaries.
   * @throws {Rivet.InternalError}
   * @throws {Rivet.RateLimitError}
   * @throws {Rivet.ForbiddenError}
   * @throws {Rivet.UnauthorizedError}
   * @throws {Rivet.NotFoundError}
   * @throws {Rivet.BadRequestError}
   */
  async getSummaries(request) {
    const { identityIds } = request;
    const _queryParams = new URLSearchParams();
    if (Array.isArray(identityIds)) {
      for (const _item of identityIds) {
        _queryParams.append("identity_ids", _item);
      }
    } else {
      _queryParams.append("identity_ids", identityIds);
    }
    const _response = await fetcher({
      url: (0, import_url_join24.default)(
        this.options.environment ?? RivetEnvironment.Production,
        "/identity/identities/batch/summary"
      ),
      method: "GET",
      headers: {
        Authorization: await this._getAuthorizationHeader()
      },
      contentType: "application/json",
      queryParameters: _queryParams
    });
    if (_response.ok) {
      return await identity_exports4.GetSummariesResponse.parseOrThrow(_response.body, {
        unrecognizedObjectKeys: "passthrough",
        allowUnrecognizedUnionMembers: true,
        allowUnrecognizedEnumValues: true
      });
    }
    if (_response.error.reason === "status-code") {
      switch (_response.error.statusCode) {
        case 500:
          throw new api_exports.InternalError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 429:
          throw new api_exports.RateLimitError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 403:
          throw new api_exports.ForbiddenError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 408:
          throw new api_exports.UnauthorizedError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 404:
          throw new api_exports.NotFoundError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 400:
          throw new api_exports.BadRequestError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        default:
          throw new RivetError({
            statusCode: _response.error.statusCode,
            body: _response.error.body
          });
      }
    }
    switch (_response.error.reason) {
      case "non-json":
        throw new RivetError({
          statusCode: _response.error.statusCode,
          body: _response.error.rawBody
        });
      case "timeout":
        throw new RivetTimeoutError();
      case "unknown":
        throw new RivetError({
          message: _response.error.errorMessage
        });
    }
  }
  /**
   * Updates profile of the current identity.
   * @throws {Rivet.InternalError}
   * @throws {Rivet.RateLimitError}
   * @throws {Rivet.ForbiddenError}
   * @throws {Rivet.UnauthorizedError}
   * @throws {Rivet.NotFoundError}
   * @throws {Rivet.BadRequestError}
   */
  async updateProfile(request = {}) {
    const _response = await fetcher({
      url: (0, import_url_join24.default)(
        this.options.environment ?? RivetEnvironment.Production,
        "/identity/identities/self/profile"
      ),
      method: "POST",
      headers: {
        Authorization: await this._getAuthorizationHeader()
      },
      contentType: "application/json",
      body: await identity_exports4.UpdateProfileRequest.jsonOrThrow(request, {
        unrecognizedObjectKeys: "strip"
      })
    });
    if (_response.ok) {
      return;
    }
    if (_response.error.reason === "status-code") {
      switch (_response.error.statusCode) {
        case 500:
          throw new api_exports.InternalError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 429:
          throw new api_exports.RateLimitError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 403:
          throw new api_exports.ForbiddenError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 408:
          throw new api_exports.UnauthorizedError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 404:
          throw new api_exports.NotFoundError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 400:
          throw new api_exports.BadRequestError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        default:
          throw new RivetError({
            statusCode: _response.error.statusCode,
            body: _response.error.body
          });
      }
    }
    switch (_response.error.reason) {
      case "non-json":
        throw new RivetError({
          statusCode: _response.error.statusCode,
          body: _response.error.rawBody
        });
      case "timeout":
        throw new RivetTimeoutError();
      case "unknown":
        throw new RivetError({
          message: _response.error.errorMessage
        });
    }
  }
  /**
   * Validate contents of identity profile. Use to provide immediate feedback on profile changes before committing them.
   * @throws {Rivet.InternalError}
   * @throws {Rivet.RateLimitError}
   * @throws {Rivet.ForbiddenError}
   * @throws {Rivet.UnauthorizedError}
   * @throws {Rivet.NotFoundError}
   * @throws {Rivet.BadRequestError}
   */
  async validateProfile(request = {}) {
    const _response = await fetcher({
      url: (0, import_url_join24.default)(
        this.options.environment ?? RivetEnvironment.Production,
        "/identity/identities/self/profile/validate"
      ),
      method: "POST",
      headers: {
        Authorization: await this._getAuthorizationHeader()
      },
      contentType: "application/json",
      body: await identity_exports4.ValidateProfileRequest.jsonOrThrow(request, {
        unrecognizedObjectKeys: "strip"
      })
    });
    if (_response.ok) {
      return;
    }
    if (_response.error.reason === "status-code") {
      switch (_response.error.statusCode) {
        case 500:
          throw new api_exports.InternalError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 429:
          throw new api_exports.RateLimitError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 403:
          throw new api_exports.ForbiddenError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 408:
          throw new api_exports.UnauthorizedError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 404:
          throw new api_exports.NotFoundError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 400:
          throw new api_exports.BadRequestError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        default:
          throw new RivetError({
            statusCode: _response.error.statusCode,
            body: _response.error.body
          });
      }
    }
    switch (_response.error.reason) {
      case "non-json":
        throw new RivetError({
          statusCode: _response.error.statusCode,
          body: _response.error.rawBody
        });
      case "timeout":
        throw new RivetTimeoutError();
      case "unknown":
        throw new RivetError({
          message: _response.error.errorMessage
        });
    }
  }
  /**
   * Fuzzy search for identities.
   * @throws {Rivet.InternalError}
   * @throws {Rivet.RateLimitError}
   * @throws {Rivet.ForbiddenError}
   * @throws {Rivet.UnauthorizedError}
   * @throws {Rivet.NotFoundError}
   * @throws {Rivet.BadRequestError}
   */
  async search(request) {
    const { query, anchor, limit } = request;
    const _queryParams = new URLSearchParams();
    _queryParams.append("query", query);
    if (anchor != null) {
      _queryParams.append("anchor", anchor);
    }
    if (limit != null) {
      _queryParams.append("limit", limit.toString());
    }
    const _response = await fetcher({
      url: (0, import_url_join24.default)(
        this.options.environment ?? RivetEnvironment.Production,
        "/identity/identities/search"
      ),
      method: "GET",
      headers: {
        Authorization: await this._getAuthorizationHeader()
      },
      contentType: "application/json",
      queryParameters: _queryParams
    });
    if (_response.ok) {
      return await identity_exports4.SearchResponse.parseOrThrow(_response.body, {
        unrecognizedObjectKeys: "passthrough",
        allowUnrecognizedUnionMembers: true,
        allowUnrecognizedEnumValues: true
      });
    }
    if (_response.error.reason === "status-code") {
      switch (_response.error.statusCode) {
        case 500:
          throw new api_exports.InternalError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 429:
          throw new api_exports.RateLimitError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 403:
          throw new api_exports.ForbiddenError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 408:
          throw new api_exports.UnauthorizedError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 404:
          throw new api_exports.NotFoundError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 400:
          throw new api_exports.BadRequestError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        default:
          throw new RivetError({
            statusCode: _response.error.statusCode,
            body: _response.error.body
          });
      }
    }
    switch (_response.error.reason) {
      case "non-json":
        throw new RivetError({
          statusCode: _response.error.statusCode,
          body: _response.error.rawBody
        });
      case "timeout":
        throw new RivetTimeoutError();
      case "unknown":
        throw new RivetError({
          message: _response.error.errorMessage
        });
    }
  }
  /**
   * Sets the current identity's game activity. This activity will automatically be removed when the identity goes offline.
   * @throws {Rivet.InternalError}
   * @throws {Rivet.RateLimitError}
   * @throws {Rivet.ForbiddenError}
   * @throws {Rivet.UnauthorizedError}
   * @throws {Rivet.NotFoundError}
   * @throws {Rivet.BadRequestError}
   */
  async setGameActivity(request) {
    const _response = await fetcher({
      url: (0, import_url_join24.default)(
        this.options.environment ?? RivetEnvironment.Production,
        "/identity/identities/self/activity"
      ),
      method: "POST",
      headers: {
        Authorization: await this._getAuthorizationHeader()
      },
      contentType: "application/json",
      body: await identity_exports4.SetGameActivityRequest.jsonOrThrow(request, {
        unrecognizedObjectKeys: "strip"
      })
    });
    if (_response.ok) {
      return;
    }
    if (_response.error.reason === "status-code") {
      switch (_response.error.statusCode) {
        case 500:
          throw new api_exports.InternalError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 429:
          throw new api_exports.RateLimitError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 403:
          throw new api_exports.ForbiddenError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 408:
          throw new api_exports.UnauthorizedError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 404:
          throw new api_exports.NotFoundError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 400:
          throw new api_exports.BadRequestError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        default:
          throw new RivetError({
            statusCode: _response.error.statusCode,
            body: _response.error.body
          });
      }
    }
    switch (_response.error.reason) {
      case "non-json":
        throw new RivetError({
          statusCode: _response.error.statusCode,
          body: _response.error.rawBody
        });
      case "timeout":
        throw new RivetTimeoutError();
      case "unknown":
        throw new RivetError({
          message: _response.error.errorMessage
        });
    }
  }
  /**
   * Removes the current identity's game activity.
   * @throws {Rivet.InternalError}
   * @throws {Rivet.RateLimitError}
   * @throws {Rivet.ForbiddenError}
   * @throws {Rivet.UnauthorizedError}
   * @throws {Rivet.NotFoundError}
   * @throws {Rivet.BadRequestError}
   */
  async removeGameActivity() {
    const _response = await fetcher({
      url: (0, import_url_join24.default)(
        this.options.environment ?? RivetEnvironment.Production,
        "/identity/identities/self/activity"
      ),
      method: "DELETE",
      headers: {
        Authorization: await this._getAuthorizationHeader()
      },
      contentType: "application/json"
    });
    if (_response.ok) {
      return;
    }
    if (_response.error.reason === "status-code") {
      switch (_response.error.statusCode) {
        case 500:
          throw new api_exports.InternalError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 429:
          throw new api_exports.RateLimitError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 403:
          throw new api_exports.ForbiddenError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 408:
          throw new api_exports.UnauthorizedError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 404:
          throw new api_exports.NotFoundError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 400:
          throw new api_exports.BadRequestError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        default:
          throw new RivetError({
            statusCode: _response.error.statusCode,
            body: _response.error.body
          });
      }
    }
    switch (_response.error.reason) {
      case "non-json":
        throw new RivetError({
          statusCode: _response.error.statusCode,
          body: _response.error.rawBody
        });
      case "timeout":
        throw new RivetTimeoutError();
      case "unknown":
        throw new RivetError({
          message: _response.error.errorMessage
        });
    }
  }
  /**
   * Updates the current identity's status.
   * @throws {Rivet.InternalError}
   * @throws {Rivet.RateLimitError}
   * @throws {Rivet.ForbiddenError}
   * @throws {Rivet.UnauthorizedError}
   * @throws {Rivet.NotFoundError}
   * @throws {Rivet.BadRequestError}
   */
  async updateStatus(request) {
    const _response = await fetcher({
      url: (0, import_url_join24.default)(
        this.options.environment ?? RivetEnvironment.Production,
        "/identity/identities/identities/self/status"
      ),
      method: "POST",
      headers: {
        Authorization: await this._getAuthorizationHeader()
      },
      contentType: "application/json",
      body: await identity_exports4.UpdateStatusRequest.jsonOrThrow(request, {
        unrecognizedObjectKeys: "strip"
      })
    });
    if (_response.ok) {
      return;
    }
    if (_response.error.reason === "status-code") {
      switch (_response.error.statusCode) {
        case 500:
          throw new api_exports.InternalError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 429:
          throw new api_exports.RateLimitError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 403:
          throw new api_exports.ForbiddenError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 408:
          throw new api_exports.UnauthorizedError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 404:
          throw new api_exports.NotFoundError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 400:
          throw new api_exports.BadRequestError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        default:
          throw new RivetError({
            statusCode: _response.error.statusCode,
            body: _response.error.body
          });
      }
    }
    switch (_response.error.reason) {
      case "non-json":
        throw new RivetError({
          statusCode: _response.error.statusCode,
          body: _response.error.rawBody
        });
      case "timeout":
        throw new RivetTimeoutError();
      case "unknown":
        throw new RivetError({
          message: _response.error.errorMessage
        });
    }
  }
  /**
   * Follows the given identity. In order for identities to be "friends", the other identity has to also follow this identity.
   * @throws {Rivet.InternalError}
   * @throws {Rivet.RateLimitError}
   * @throws {Rivet.ForbiddenError}
   * @throws {Rivet.UnauthorizedError}
   * @throws {Rivet.NotFoundError}
   * @throws {Rivet.BadRequestError}
   */
  async follow(identityId) {
    const _response = await fetcher({
      url: (0, import_url_join24.default)(
        this.options.environment ?? RivetEnvironment.Production,
        `/identity/identities/${identityId}/follow`
      ),
      method: "POST",
      headers: {
        Authorization: await this._getAuthorizationHeader()
      },
      contentType: "application/json"
    });
    if (_response.ok) {
      return;
    }
    if (_response.error.reason === "status-code") {
      switch (_response.error.statusCode) {
        case 500:
          throw new api_exports.InternalError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 429:
          throw new api_exports.RateLimitError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 403:
          throw new api_exports.ForbiddenError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 408:
          throw new api_exports.UnauthorizedError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 404:
          throw new api_exports.NotFoundError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 400:
          throw new api_exports.BadRequestError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        default:
          throw new RivetError({
            statusCode: _response.error.statusCode,
            body: _response.error.body
          });
      }
    }
    switch (_response.error.reason) {
      case "non-json":
        throw new RivetError({
          statusCode: _response.error.statusCode,
          body: _response.error.rawBody
        });
      case "timeout":
        throw new RivetTimeoutError();
      case "unknown":
        throw new RivetError({
          message: _response.error.errorMessage
        });
    }
  }
  /**
   * Unfollows the given identity.
   * @throws {Rivet.InternalError}
   * @throws {Rivet.RateLimitError}
   * @throws {Rivet.ForbiddenError}
   * @throws {Rivet.UnauthorizedError}
   * @throws {Rivet.NotFoundError}
   * @throws {Rivet.BadRequestError}
   */
  async unfollow(identityId) {
    const _response = await fetcher({
      url: (0, import_url_join24.default)(
        this.options.environment ?? RivetEnvironment.Production,
        `/identity/identities/${identityId}/follow`
      ),
      method: "DELETE",
      headers: {
        Authorization: await this._getAuthorizationHeader()
      },
      contentType: "application/json"
    });
    if (_response.ok) {
      return;
    }
    if (_response.error.reason === "status-code") {
      switch (_response.error.statusCode) {
        case 500:
          throw new api_exports.InternalError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 429:
          throw new api_exports.RateLimitError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 403:
          throw new api_exports.ForbiddenError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 408:
          throw new api_exports.UnauthorizedError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 404:
          throw new api_exports.NotFoundError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 400:
          throw new api_exports.BadRequestError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        default:
          throw new RivetError({
            statusCode: _response.error.statusCode,
            body: _response.error.body
          });
      }
    }
    switch (_response.error.reason) {
      case "non-json":
        throw new RivetError({
          statusCode: _response.error.statusCode,
          body: _response.error.rawBody
        });
      case "timeout":
        throw new RivetTimeoutError();
      case "unknown":
        throw new RivetError({
          message: _response.error.errorMessage
        });
    }
  }
  /**
   * Prepares an avatar image upload. Complete upload with `CompleteIdentityAvatarUpload`.
   * @throws {Rivet.InternalError}
   * @throws {Rivet.RateLimitError}
   * @throws {Rivet.ForbiddenError}
   * @throws {Rivet.UnauthorizedError}
   * @throws {Rivet.NotFoundError}
   * @throws {Rivet.BadRequestError}
   */
  async prepareAvatarUpload(request) {
    const _response = await fetcher({
      url: (0, import_url_join24.default)(
        this.options.environment ?? RivetEnvironment.Production,
        "/identity/identities/avatar-upload/prepare"
      ),
      method: "POST",
      headers: {
        Authorization: await this._getAuthorizationHeader()
      },
      contentType: "application/json",
      body: await identity_exports4.PrepareAvatarUploadRequest.jsonOrThrow(request, {
        unrecognizedObjectKeys: "strip"
      })
    });
    if (_response.ok) {
      return await identity_exports4.PrepareAvatarUploadResponse.parseOrThrow(_response.body, {
        unrecognizedObjectKeys: "passthrough",
        allowUnrecognizedUnionMembers: true,
        allowUnrecognizedEnumValues: true
      });
    }
    if (_response.error.reason === "status-code") {
      switch (_response.error.statusCode) {
        case 500:
          throw new api_exports.InternalError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 429:
          throw new api_exports.RateLimitError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 403:
          throw new api_exports.ForbiddenError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 408:
          throw new api_exports.UnauthorizedError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 404:
          throw new api_exports.NotFoundError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 400:
          throw new api_exports.BadRequestError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        default:
          throw new RivetError({
            statusCode: _response.error.statusCode,
            body: _response.error.body
          });
      }
    }
    switch (_response.error.reason) {
      case "non-json":
        throw new RivetError({
          statusCode: _response.error.statusCode,
          body: _response.error.rawBody
        });
      case "timeout":
        throw new RivetTimeoutError();
      case "unknown":
        throw new RivetError({
          message: _response.error.errorMessage
        });
    }
  }
  /**
   * Completes an avatar image upload. Must be called after the file upload process completes.
   * @throws {Rivet.InternalError}
   * @throws {Rivet.RateLimitError}
   * @throws {Rivet.ForbiddenError}
   * @throws {Rivet.UnauthorizedError}
   * @throws {Rivet.NotFoundError}
   * @throws {Rivet.BadRequestError}
   */
  async completeAvatarUpload(uploadId) {
    const _response = await fetcher({
      url: (0, import_url_join24.default)(
        this.options.environment ?? RivetEnvironment.Production,
        `/identity/identities/avatar-upload/${uploadId}/complete`
      ),
      method: "POST",
      headers: {
        Authorization: await this._getAuthorizationHeader()
      },
      contentType: "application/json"
    });
    if (_response.ok) {
      return;
    }
    if (_response.error.reason === "status-code") {
      switch (_response.error.statusCode) {
        case 500:
          throw new api_exports.InternalError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 429:
          throw new api_exports.RateLimitError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 403:
          throw new api_exports.ForbiddenError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 408:
          throw new api_exports.UnauthorizedError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 404:
          throw new api_exports.NotFoundError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 400:
          throw new api_exports.BadRequestError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        default:
          throw new RivetError({
            statusCode: _response.error.statusCode,
            body: _response.error.body
          });
      }
    }
    switch (_response.error.reason) {
      case "non-json":
        throw new RivetError({
          statusCode: _response.error.statusCode,
          body: _response.error.rawBody
        });
      case "timeout":
        throw new RivetTimeoutError();
      case "unknown":
        throw new RivetError({
          message: _response.error.errorMessage
        });
    }
  }
  /**
   * Completes an avatar image upload. Must be called after the file upload process completes.
   * @throws {Rivet.InternalError}
   * @throws {Rivet.RateLimitError}
   * @throws {Rivet.ForbiddenError}
   * @throws {Rivet.UnauthorizedError}
   * @throws {Rivet.NotFoundError}
   * @throws {Rivet.BadRequestError}
   */
  async signupForBeta(request) {
    const _response = await fetcher({
      url: (0, import_url_join24.default)(
        this.options.environment ?? RivetEnvironment.Production,
        "/identity/identities/self/beta-signup"
      ),
      method: "POST",
      headers: {
        Authorization: await this._getAuthorizationHeader()
      },
      contentType: "application/json",
      body: await identity_exports4.SignupForBetaRequest.jsonOrThrow(request, {
        unrecognizedObjectKeys: "strip"
      })
    });
    if (_response.ok) {
      return;
    }
    if (_response.error.reason === "status-code") {
      switch (_response.error.statusCode) {
        case 500:
          throw new api_exports.InternalError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 429:
          throw new api_exports.RateLimitError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 403:
          throw new api_exports.ForbiddenError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 408:
          throw new api_exports.UnauthorizedError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 404:
          throw new api_exports.NotFoundError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 400:
          throw new api_exports.BadRequestError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        default:
          throw new RivetError({
            statusCode: _response.error.statusCode,
            body: _response.error.body
          });
      }
    }
    switch (_response.error.reason) {
      case "non-json":
        throw new RivetError({
          statusCode: _response.error.statusCode,
          body: _response.error.rawBody
        });
      case "timeout":
        throw new RivetTimeoutError();
      case "unknown":
        throw new RivetError({
          message: _response.error.errorMessage
        });
    }
  }
  /**
   * Creates an abuse report for an identity.
   * @throws {Rivet.InternalError}
   * @throws {Rivet.RateLimitError}
   * @throws {Rivet.ForbiddenError}
   * @throws {Rivet.UnauthorizedError}
   * @throws {Rivet.NotFoundError}
   * @throws {Rivet.BadRequestError}
   */
  async report(identityId, request = {}) {
    const _response = await fetcher({
      url: (0, import_url_join24.default)(
        this.options.environment ?? RivetEnvironment.Production,
        `/identity/identities/${identityId}/report`
      ),
      method: "POST",
      headers: {
        Authorization: await this._getAuthorizationHeader()
      },
      contentType: "application/json",
      body: await identity_exports4.ReportRequest.jsonOrThrow(request, { unrecognizedObjectKeys: "strip" })
    });
    if (_response.ok) {
      return;
    }
    if (_response.error.reason === "status-code") {
      switch (_response.error.statusCode) {
        case 500:
          throw new api_exports.InternalError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 429:
          throw new api_exports.RateLimitError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 403:
          throw new api_exports.ForbiddenError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 408:
          throw new api_exports.UnauthorizedError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 404:
          throw new api_exports.NotFoundError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 400:
          throw new api_exports.BadRequestError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        default:
          throw new RivetError({
            statusCode: _response.error.statusCode,
            body: _response.error.body
          });
      }
    }
    switch (_response.error.reason) {
      case "non-json":
        throw new RivetError({
          statusCode: _response.error.statusCode,
          body: _response.error.rawBody
        });
      case "timeout":
        throw new RivetTimeoutError();
      case "unknown":
        throw new RivetError({
          message: _response.error.errorMessage
        });
    }
  }
  /**
   * @throws {Rivet.InternalError}
   * @throws {Rivet.RateLimitError}
   * @throws {Rivet.ForbiddenError}
   * @throws {Rivet.UnauthorizedError}
   * @throws {Rivet.NotFoundError}
   * @throws {Rivet.BadRequestError}
   */
  async listFollowers(identityId, request = {}) {
    const { anchor, limit } = request;
    const _queryParams = new URLSearchParams();
    if (anchor != null) {
      _queryParams.append("anchor", anchor);
    }
    if (limit != null) {
      _queryParams.append("limit", limit);
    }
    const _response = await fetcher({
      url: (0, import_url_join24.default)(
        this.options.environment ?? RivetEnvironment.Production,
        `/identity/identities/${identityId}/followers`
      ),
      method: "GET",
      headers: {
        Authorization: await this._getAuthorizationHeader()
      },
      contentType: "application/json",
      queryParameters: _queryParams
    });
    if (_response.ok) {
      return await identity_exports4.ListFollowersResponse.parseOrThrow(_response.body, {
        unrecognizedObjectKeys: "passthrough",
        allowUnrecognizedUnionMembers: true,
        allowUnrecognizedEnumValues: true
      });
    }
    if (_response.error.reason === "status-code") {
      switch (_response.error.statusCode) {
        case 500:
          throw new api_exports.InternalError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 429:
          throw new api_exports.RateLimitError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 403:
          throw new api_exports.ForbiddenError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 408:
          throw new api_exports.UnauthorizedError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 404:
          throw new api_exports.NotFoundError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 400:
          throw new api_exports.BadRequestError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        default:
          throw new RivetError({
            statusCode: _response.error.statusCode,
            body: _response.error.body
          });
      }
    }
    switch (_response.error.reason) {
      case "non-json":
        throw new RivetError({
          statusCode: _response.error.statusCode,
          body: _response.error.rawBody
        });
      case "timeout":
        throw new RivetTimeoutError();
      case "unknown":
        throw new RivetError({
          message: _response.error.errorMessage
        });
    }
  }
  /**
   * @throws {Rivet.InternalError}
   * @throws {Rivet.RateLimitError}
   * @throws {Rivet.ForbiddenError}
   * @throws {Rivet.UnauthorizedError}
   * @throws {Rivet.NotFoundError}
   * @throws {Rivet.BadRequestError}
   */
  async listFollowing(identityId, request = {}) {
    const { anchor, limit } = request;
    const _queryParams = new URLSearchParams();
    if (anchor != null) {
      _queryParams.append("anchor", anchor);
    }
    if (limit != null) {
      _queryParams.append("limit", limit);
    }
    const _response = await fetcher({
      url: (0, import_url_join24.default)(
        this.options.environment ?? RivetEnvironment.Production,
        `/identity/identities/${identityId}/following`
      ),
      method: "GET",
      headers: {
        Authorization: await this._getAuthorizationHeader()
      },
      contentType: "application/json",
      queryParameters: _queryParams
    });
    if (_response.ok) {
      return await identity_exports4.ListFollowingResponse.parseOrThrow(_response.body, {
        unrecognizedObjectKeys: "passthrough",
        allowUnrecognizedUnionMembers: true,
        allowUnrecognizedEnumValues: true
      });
    }
    if (_response.error.reason === "status-code") {
      switch (_response.error.statusCode) {
        case 500:
          throw new api_exports.InternalError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 429:
          throw new api_exports.RateLimitError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 403:
          throw new api_exports.ForbiddenError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 408:
          throw new api_exports.UnauthorizedError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 404:
          throw new api_exports.NotFoundError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 400:
          throw new api_exports.BadRequestError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        default:
          throw new RivetError({
            statusCode: _response.error.statusCode,
            body: _response.error.body
          });
      }
    }
    switch (_response.error.reason) {
      case "non-json":
        throw new RivetError({
          statusCode: _response.error.statusCode,
          body: _response.error.rawBody
        });
      case "timeout":
        throw new RivetTimeoutError();
      case "unknown":
        throw new RivetError({
          message: _response.error.errorMessage
        });
    }
  }
  /**
   * @throws {Rivet.InternalError}
   * @throws {Rivet.RateLimitError}
   * @throws {Rivet.ForbiddenError}
   * @throws {Rivet.UnauthorizedError}
   * @throws {Rivet.NotFoundError}
   * @throws {Rivet.BadRequestError}
   */
  async listFriends(request = {}) {
    const { anchor, limit } = request;
    const _queryParams = new URLSearchParams();
    if (anchor != null) {
      _queryParams.append("anchor", anchor);
    }
    if (limit != null) {
      _queryParams.append("limit", limit);
    }
    const _response = await fetcher({
      url: (0, import_url_join24.default)(
        this.options.environment ?? RivetEnvironment.Production,
        "/identity/identities/self/friends"
      ),
      method: "GET",
      headers: {
        Authorization: await this._getAuthorizationHeader()
      },
      contentType: "application/json",
      queryParameters: _queryParams
    });
    if (_response.ok) {
      return await identity_exports4.ListFriendsResponse.parseOrThrow(_response.body, {
        unrecognizedObjectKeys: "passthrough",
        allowUnrecognizedUnionMembers: true,
        allowUnrecognizedEnumValues: true
      });
    }
    if (_response.error.reason === "status-code") {
      switch (_response.error.statusCode) {
        case 500:
          throw new api_exports.InternalError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 429:
          throw new api_exports.RateLimitError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 403:
          throw new api_exports.ForbiddenError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 408:
          throw new api_exports.UnauthorizedError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 404:
          throw new api_exports.NotFoundError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 400:
          throw new api_exports.BadRequestError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        default:
          throw new RivetError({
            statusCode: _response.error.statusCode,
            body: _response.error.body
          });
      }
    }
    switch (_response.error.reason) {
      case "non-json":
        throw new RivetError({
          statusCode: _response.error.statusCode,
          body: _response.error.rawBody
        });
      case "timeout":
        throw new RivetTimeoutError();
      case "unknown":
        throw new RivetError({
          message: _response.error.errorMessage
        });
    }
  }
  /**
   * @throws {Rivet.InternalError}
   * @throws {Rivet.RateLimitError}
   * @throws {Rivet.ForbiddenError}
   * @throws {Rivet.UnauthorizedError}
   * @throws {Rivet.NotFoundError}
   * @throws {Rivet.BadRequestError}
   */
  async listMutualFriends(identityId, request = {}) {
    const { anchor, limit } = request;
    const _queryParams = new URLSearchParams();
    if (anchor != null) {
      _queryParams.append("anchor", anchor);
    }
    if (limit != null) {
      _queryParams.append("limit", limit);
    }
    const _response = await fetcher({
      url: (0, import_url_join24.default)(
        this.options.environment ?? RivetEnvironment.Production,
        `/identity/identities/${identityId}/mutual-friends`
      ),
      method: "GET",
      headers: {
        Authorization: await this._getAuthorizationHeader()
      },
      contentType: "application/json",
      queryParameters: _queryParams
    });
    if (_response.ok) {
      return await identity_exports4.ListMutualFriendsResponse.parseOrThrow(_response.body, {
        unrecognizedObjectKeys: "passthrough",
        allowUnrecognizedUnionMembers: true,
        allowUnrecognizedEnumValues: true
      });
    }
    if (_response.error.reason === "status-code") {
      switch (_response.error.statusCode) {
        case 500:
          throw new api_exports.InternalError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 429:
          throw new api_exports.RateLimitError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 403:
          throw new api_exports.ForbiddenError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 408:
          throw new api_exports.UnauthorizedError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 404:
          throw new api_exports.NotFoundError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 400:
          throw new api_exports.BadRequestError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        default:
          throw new RivetError({
            statusCode: _response.error.statusCode,
            body: _response.error.body
          });
      }
    }
    switch (_response.error.reason) {
      case "non-json":
        throw new RivetError({
          statusCode: _response.error.statusCode,
          body: _response.error.rawBody
        });
      case "timeout":
        throw new RivetTimeoutError();
      case "unknown":
        throw new RivetError({
          message: _response.error.errorMessage
        });
    }
  }
  /**
   * @throws {Rivet.InternalError}
   * @throws {Rivet.RateLimitError}
   * @throws {Rivet.ForbiddenError}
   * @throws {Rivet.UnauthorizedError}
   * @throws {Rivet.NotFoundError}
   * @throws {Rivet.BadRequestError}
   */
  async listRecentFollowers(request = {}) {
    const { count, watchIndex } = request;
    const _queryParams = new URLSearchParams();
    if (count != null) {
      _queryParams.append("count", count.toString());
    }
    if (watchIndex != null) {
      _queryParams.append("watch_index", watchIndex);
    }
    const _response = await fetcher({
      url: (0, import_url_join24.default)(
        this.options.environment ?? RivetEnvironment.Production,
        "/identity/identities/self/recent-followers"
      ),
      method: "GET",
      headers: {
        Authorization: await this._getAuthorizationHeader()
      },
      contentType: "application/json",
      queryParameters: _queryParams
    });
    if (_response.ok) {
      return await identity_exports4.ListRecentFollowersResponse.parseOrThrow(_response.body, {
        unrecognizedObjectKeys: "passthrough",
        allowUnrecognizedUnionMembers: true,
        allowUnrecognizedEnumValues: true
      });
    }
    if (_response.error.reason === "status-code") {
      switch (_response.error.statusCode) {
        case 500:
          throw new api_exports.InternalError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 429:
          throw new api_exports.RateLimitError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 403:
          throw new api_exports.ForbiddenError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 408:
          throw new api_exports.UnauthorizedError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 404:
          throw new api_exports.NotFoundError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 400:
          throw new api_exports.BadRequestError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        default:
          throw new RivetError({
            statusCode: _response.error.statusCode,
            body: _response.error.body
          });
      }
    }
    switch (_response.error.reason) {
      case "non-json":
        throw new RivetError({
          statusCode: _response.error.statusCode,
          body: _response.error.rawBody
        });
      case "timeout":
        throw new RivetTimeoutError();
      case "unknown":
        throw new RivetError({
          message: _response.error.errorMessage
        });
    }
  }
  /**
   * @throws {Rivet.InternalError}
   * @throws {Rivet.RateLimitError}
   * @throws {Rivet.ForbiddenError}
   * @throws {Rivet.UnauthorizedError}
   * @throws {Rivet.NotFoundError}
   * @throws {Rivet.BadRequestError}
   */
  async ignoreRecentFollower(identityId) {
    const _response = await fetcher({
      url: (0, import_url_join24.default)(
        this.options.environment ?? RivetEnvironment.Production,
        `/identity/identities/self/recent-followers/${identityId}/ignore`
      ),
      method: "POST",
      headers: {
        Authorization: await this._getAuthorizationHeader()
      },
      contentType: "application/json"
    });
    if (_response.ok) {
      return;
    }
    if (_response.error.reason === "status-code") {
      switch (_response.error.statusCode) {
        case 500:
          throw new api_exports.InternalError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 429:
          throw new api_exports.RateLimitError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 403:
          throw new api_exports.ForbiddenError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 408:
          throw new api_exports.UnauthorizedError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 404:
          throw new api_exports.NotFoundError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 400:
          throw new api_exports.BadRequestError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        default:
          throw new RivetError({
            statusCode: _response.error.statusCode,
            body: _response.error.body
          });
      }
    }
    switch (_response.error.reason) {
      case "non-json":
        throw new RivetError({
          statusCode: _response.error.statusCode,
          body: _response.error.rawBody
        });
      case "timeout":
        throw new RivetTimeoutError();
      case "unknown":
        throw new RivetError({
          message: _response.error.errorMessage
        });
    }
  }
  /**
   * @throws {Rivet.InternalError}
   * @throws {Rivet.RateLimitError}
   * @throws {Rivet.ForbiddenError}
   * @throws {Rivet.UnauthorizedError}
   * @throws {Rivet.NotFoundError}
   * @throws {Rivet.BadRequestError}
   */
  async markDeletion() {
    const _response = await fetcher({
      url: (0, import_url_join24.default)(
        this.options.environment ?? RivetEnvironment.Production,
        "/identity/identities/self/delete-request"
      ),
      method: "POST",
      headers: {
        Authorization: await this._getAuthorizationHeader()
      },
      contentType: "application/json"
    });
    if (_response.ok) {
      return;
    }
    if (_response.error.reason === "status-code") {
      switch (_response.error.statusCode) {
        case 500:
          throw new api_exports.InternalError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 429:
          throw new api_exports.RateLimitError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 403:
          throw new api_exports.ForbiddenError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 408:
          throw new api_exports.UnauthorizedError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 404:
          throw new api_exports.NotFoundError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 400:
          throw new api_exports.BadRequestError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        default:
          throw new RivetError({
            statusCode: _response.error.statusCode,
            body: _response.error.body
          });
      }
    }
    switch (_response.error.reason) {
      case "non-json":
        throw new RivetError({
          statusCode: _response.error.statusCode,
          body: _response.error.rawBody
        });
      case "timeout":
        throw new RivetTimeoutError();
      case "unknown":
        throw new RivetError({
          message: _response.error.errorMessage
        });
    }
  }
  /**
   * @throws {Rivet.InternalError}
   * @throws {Rivet.RateLimitError}
   * @throws {Rivet.ForbiddenError}
   * @throws {Rivet.UnauthorizedError}
   * @throws {Rivet.NotFoundError}
   * @throws {Rivet.BadRequestError}
   */
  async unmarkDeletion() {
    const _response = await fetcher({
      url: (0, import_url_join24.default)(
        this.options.environment ?? RivetEnvironment.Production,
        "/identity/identities/self/delete-request"
      ),
      method: "DELETE",
      headers: {
        Authorization: await this._getAuthorizationHeader()
      },
      contentType: "application/json"
    });
    if (_response.ok) {
      return;
    }
    if (_response.error.reason === "status-code") {
      switch (_response.error.statusCode) {
        case 500:
          throw new api_exports.InternalError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 429:
          throw new api_exports.RateLimitError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 403:
          throw new api_exports.ForbiddenError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 408:
          throw new api_exports.UnauthorizedError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 404:
          throw new api_exports.NotFoundError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 400:
          throw new api_exports.BadRequestError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        default:
          throw new RivetError({
            statusCode: _response.error.statusCode,
            body: _response.error.body
          });
      }
    }
    switch (_response.error.reason) {
      case "non-json":
        throw new RivetError({
          statusCode: _response.error.statusCode,
          body: _response.error.rawBody
        });
      case "timeout":
        throw new RivetTimeoutError();
      case "unknown":
        throw new RivetError({
          message: _response.error.errorMessage
        });
    }
  }
  _events;
  get events() {
    return this._events ?? (this._events = new Events(this.options));
  }
  _links;
  get links() {
    return this._links ?? (this._links = new Links2(this.options));
  }
  async _getAuthorizationHeader() {
    const bearer = await Supplier.get(this.options.token);
    if (bearer != null) {
      return `Bearer ${bearer}`;
    }
    return void 0;
  }
};

// src/api/resources/kv/client/Client.ts
init_core();
var import_url_join25 = __toESM(require_url_join());
init_serialization();
var Kv = class {
  constructor(options) {
    this.options = options;
  }
  /**
   * Returns a specific key-value entry by key.
   * @throws {Rivet.InternalError}
   * @throws {Rivet.RateLimitError}
   * @throws {Rivet.ForbiddenError}
   * @throws {Rivet.UnauthorizedError}
   * @throws {Rivet.NotFoundError}
   * @throws {Rivet.BadRequestError}
   */
  async get(request) {
    const { key, watchIndex, namespaceId } = request;
    const _queryParams = new URLSearchParams();
    _queryParams.append("key", key);
    if (watchIndex != null) {
      _queryParams.append("watch_index", watchIndex);
    }
    if (namespaceId != null) {
      _queryParams.append("namespace_id", namespaceId);
    }
    const _response = await fetcher({
      url: (0, import_url_join25.default)(this.options.environment ?? RivetEnvironment.Production, "/kv/entries"),
      method: "GET",
      headers: {
        Authorization: await this._getAuthorizationHeader()
      },
      contentType: "application/json",
      queryParameters: _queryParams
    });
    if (_response.ok) {
      return await kv_exports4.GetResponse.parseOrThrow(_response.body, {
        unrecognizedObjectKeys: "passthrough",
        allowUnrecognizedUnionMembers: true,
        allowUnrecognizedEnumValues: true
      });
    }
    if (_response.error.reason === "status-code") {
      switch (_response.error.statusCode) {
        case 500:
          throw new api_exports.InternalError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 429:
          throw new api_exports.RateLimitError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 403:
          throw new api_exports.ForbiddenError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 408:
          throw new api_exports.UnauthorizedError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 404:
          throw new api_exports.NotFoundError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 400:
          throw new api_exports.BadRequestError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        default:
          throw new RivetError({
            statusCode: _response.error.statusCode,
            body: _response.error.body
          });
      }
    }
    switch (_response.error.reason) {
      case "non-json":
        throw new RivetError({
          statusCode: _response.error.statusCode,
          body: _response.error.rawBody
        });
      case "timeout":
        throw new RivetTimeoutError();
      case "unknown":
        throw new RivetError({
          message: _response.error.errorMessage
        });
    }
  }
  /**
   * Puts (sets or overwrites) a key-value entry by key.
   * @throws {Rivet.InternalError}
   * @throws {Rivet.RateLimitError}
   * @throws {Rivet.ForbiddenError}
   * @throws {Rivet.UnauthorizedError}
   * @throws {Rivet.NotFoundError}
   * @throws {Rivet.BadRequestError}
   */
  async put(request) {
    const _response = await fetcher({
      url: (0, import_url_join25.default)(this.options.environment ?? RivetEnvironment.Production, "/kv/entries"),
      method: "PUT",
      headers: {
        Authorization: await this._getAuthorizationHeader()
      },
      contentType: "application/json",
      body: await kv_exports4.PutRequest.jsonOrThrow(request, { unrecognizedObjectKeys: "strip" })
    });
    if (_response.ok) {
      return;
    }
    if (_response.error.reason === "status-code") {
      switch (_response.error.statusCode) {
        case 500:
          throw new api_exports.InternalError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 429:
          throw new api_exports.RateLimitError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 403:
          throw new api_exports.ForbiddenError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 408:
          throw new api_exports.UnauthorizedError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 404:
          throw new api_exports.NotFoundError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 400:
          throw new api_exports.BadRequestError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        default:
          throw new RivetError({
            statusCode: _response.error.statusCode,
            body: _response.error.body
          });
      }
    }
    switch (_response.error.reason) {
      case "non-json":
        throw new RivetError({
          statusCode: _response.error.statusCode,
          body: _response.error.rawBody
        });
      case "timeout":
        throw new RivetTimeoutError();
      case "unknown":
        throw new RivetError({
          message: _response.error.errorMessage
        });
    }
  }
  /**
   * Deletes a key-value entry by key.
   * @throws {Rivet.InternalError}
   * @throws {Rivet.RateLimitError}
   * @throws {Rivet.ForbiddenError}
   * @throws {Rivet.UnauthorizedError}
   * @throws {Rivet.NotFoundError}
   * @throws {Rivet.BadRequestError}
   */
  async delete(request) {
    const { key, namespaceId } = request;
    const _queryParams = new URLSearchParams();
    _queryParams.append("key", key);
    if (namespaceId != null) {
      _queryParams.append("namespace_id", namespaceId);
    }
    const _response = await fetcher({
      url: (0, import_url_join25.default)(this.options.environment ?? RivetEnvironment.Production, "/kv/entries"),
      method: "DELETE",
      headers: {
        Authorization: await this._getAuthorizationHeader()
      },
      contentType: "application/json",
      queryParameters: _queryParams
    });
    if (_response.ok) {
      return;
    }
    if (_response.error.reason === "status-code") {
      switch (_response.error.statusCode) {
        case 500:
          throw new api_exports.InternalError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 429:
          throw new api_exports.RateLimitError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 403:
          throw new api_exports.ForbiddenError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 408:
          throw new api_exports.UnauthorizedError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 404:
          throw new api_exports.NotFoundError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 400:
          throw new api_exports.BadRequestError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        default:
          throw new RivetError({
            statusCode: _response.error.statusCode,
            body: _response.error.body
          });
      }
    }
    switch (_response.error.reason) {
      case "non-json":
        throw new RivetError({
          statusCode: _response.error.statusCode,
          body: _response.error.rawBody
        });
      case "timeout":
        throw new RivetTimeoutError();
      case "unknown":
        throw new RivetError({
          message: _response.error.errorMessage
        });
    }
  }
  /**
   * Gets multiple key-value entries by key(s).
   * @throws {Rivet.InternalError}
   * @throws {Rivet.RateLimitError}
   * @throws {Rivet.ForbiddenError}
   * @throws {Rivet.UnauthorizedError}
   * @throws {Rivet.NotFoundError}
   * @throws {Rivet.BadRequestError}
   */
  async getBatch(request) {
    const { keys: keys2, watchIndex, namespaceId } = request;
    const _queryParams = new URLSearchParams();
    if (Array.isArray(keys2)) {
      for (const _item of keys2) {
        _queryParams.append("keys", _item);
      }
    } else {
      _queryParams.append("keys", keys2);
    }
    if (watchIndex != null) {
      _queryParams.append("watch_index", watchIndex);
    }
    if (namespaceId != null) {
      _queryParams.append("namespace_id", namespaceId);
    }
    const _response = await fetcher({
      url: (0, import_url_join25.default)(this.options.environment ?? RivetEnvironment.Production, "/kv/entries/batch"),
      method: "GET",
      headers: {
        Authorization: await this._getAuthorizationHeader()
      },
      contentType: "application/json",
      queryParameters: _queryParams
    });
    if (_response.ok) {
      return await kv_exports4.GetBatchResponse.parseOrThrow(_response.body, {
        unrecognizedObjectKeys: "passthrough",
        allowUnrecognizedUnionMembers: true,
        allowUnrecognizedEnumValues: true
      });
    }
    if (_response.error.reason === "status-code") {
      switch (_response.error.statusCode) {
        case 500:
          throw new api_exports.InternalError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 429:
          throw new api_exports.RateLimitError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 403:
          throw new api_exports.ForbiddenError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 408:
          throw new api_exports.UnauthorizedError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 404:
          throw new api_exports.NotFoundError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 400:
          throw new api_exports.BadRequestError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        default:
          throw new RivetError({
            statusCode: _response.error.statusCode,
            body: _response.error.body
          });
      }
    }
    switch (_response.error.reason) {
      case "non-json":
        throw new RivetError({
          statusCode: _response.error.statusCode,
          body: _response.error.rawBody
        });
      case "timeout":
        throw new RivetTimeoutError();
      case "unknown":
        throw new RivetError({
          message: _response.error.errorMessage
        });
    }
  }
  /**
   * Puts (sets or overwrites) multiple key-value entries by key(s).
   * @throws {Rivet.InternalError}
   * @throws {Rivet.RateLimitError}
   * @throws {Rivet.ForbiddenError}
   * @throws {Rivet.UnauthorizedError}
   * @throws {Rivet.NotFoundError}
   * @throws {Rivet.BadRequestError}
   */
  async putBatch(request) {
    const _response = await fetcher({
      url: (0, import_url_join25.default)(this.options.environment ?? RivetEnvironment.Production, "/kv/entries/batch"),
      method: "PUT",
      headers: {
        Authorization: await this._getAuthorizationHeader()
      },
      contentType: "application/json",
      body: await kv_exports4.PutBatchRequest.jsonOrThrow(request, { unrecognizedObjectKeys: "strip" })
    });
    if (_response.ok) {
      return;
    }
    if (_response.error.reason === "status-code") {
      switch (_response.error.statusCode) {
        case 500:
          throw new api_exports.InternalError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 429:
          throw new api_exports.RateLimitError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 403:
          throw new api_exports.ForbiddenError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 408:
          throw new api_exports.UnauthorizedError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 404:
          throw new api_exports.NotFoundError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 400:
          throw new api_exports.BadRequestError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        default:
          throw new RivetError({
            statusCode: _response.error.statusCode,
            body: _response.error.body
          });
      }
    }
    switch (_response.error.reason) {
      case "non-json":
        throw new RivetError({
          statusCode: _response.error.statusCode,
          body: _response.error.rawBody
        });
      case "timeout":
        throw new RivetTimeoutError();
      case "unknown":
        throw new RivetError({
          message: _response.error.errorMessage
        });
    }
  }
  /**
   * Deletes multiple key-value entries by key(s).
   * @throws {Rivet.InternalError}
   * @throws {Rivet.RateLimitError}
   * @throws {Rivet.ForbiddenError}
   * @throws {Rivet.UnauthorizedError}
   * @throws {Rivet.NotFoundError}
   * @throws {Rivet.BadRequestError}
   */
  async deleteBatch(request) {
    const { keys: keys2, namespaceId } = request;
    const _queryParams = new URLSearchParams();
    if (Array.isArray(keys2)) {
      for (const _item of keys2) {
        _queryParams.append("keys", _item);
      }
    } else {
      _queryParams.append("keys", keys2);
    }
    if (namespaceId != null) {
      _queryParams.append("namespace_id", namespaceId);
    }
    const _response = await fetcher({
      url: (0, import_url_join25.default)(this.options.environment ?? RivetEnvironment.Production, "/kv/entries/batch"),
      method: "DELETE",
      headers: {
        Authorization: await this._getAuthorizationHeader()
      },
      contentType: "application/json",
      queryParameters: _queryParams
    });
    if (_response.ok) {
      return;
    }
    if (_response.error.reason === "status-code") {
      switch (_response.error.statusCode) {
        case 500:
          throw new api_exports.InternalError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 429:
          throw new api_exports.RateLimitError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 403:
          throw new api_exports.ForbiddenError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 408:
          throw new api_exports.UnauthorizedError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 404:
          throw new api_exports.NotFoundError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 400:
          throw new api_exports.BadRequestError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        default:
          throw new RivetError({
            statusCode: _response.error.statusCode,
            body: _response.error.body
          });
      }
    }
    switch (_response.error.reason) {
      case "non-json":
        throw new RivetError({
          statusCode: _response.error.statusCode,
          body: _response.error.rawBody
        });
      case "timeout":
        throw new RivetTimeoutError();
      case "unknown":
        throw new RivetError({
          message: _response.error.errorMessage
        });
    }
  }
  async _getAuthorizationHeader() {
    const bearer = await Supplier.get(this.options.token);
    if (bearer != null) {
      return `Bearer ${bearer}`;
    }
    return void 0;
  }
};

// src/api/resources/module/client/Client.ts
init_core();
var import_url_join26 = __toESM(require_url_join());
init_serialization();
var Module = class {
  constructor(options) {
    this.options = options;
  }
  /**
   * Makes a request to a module's script.
   *
   * @throws {Rivet.InternalError}
   * @throws {Rivet.RateLimitError}
   * @throws {Rivet.ForbiddenError}
   * @throws {Rivet.UnauthorizedError}
   * @throws {Rivet.NotFoundError}
   * @throws {Rivet.BadRequestError}
   */
  async call(module2, script, request) {
    const { origin, ..._body } = request;
    const _response = await fetcher({
      url: (0, import_url_join26.default)(
        this.options.environment ?? RivetEnvironment.Production,
        `/module/modules/${module2}/scripts/${script}/call`
      ),
      method: "POST",
      headers: {
        Authorization: await this._getAuthorizationHeader(),
        origin
      },
      contentType: "application/json",
      body: await module_exports2.FindLobbyRequest.jsonOrThrow(_body, { unrecognizedObjectKeys: "strip" })
    });
    if (_response.ok) {
      return await module_exports2.CallResponse.parseOrThrow(_response.body, {
        unrecognizedObjectKeys: "passthrough",
        allowUnrecognizedUnionMembers: true,
        allowUnrecognizedEnumValues: true
      });
    }
    if (_response.error.reason === "status-code") {
      switch (_response.error.statusCode) {
        case 500:
          throw new api_exports.InternalError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 429:
          throw new api_exports.RateLimitError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 403:
          throw new api_exports.ForbiddenError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 408:
          throw new api_exports.UnauthorizedError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 404:
          throw new api_exports.NotFoundError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 400:
          throw new api_exports.BadRequestError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        default:
          throw new RivetError({
            statusCode: _response.error.statusCode,
            body: _response.error.body
          });
      }
    }
    switch (_response.error.reason) {
      case "non-json":
        throw new RivetError({
          statusCode: _response.error.statusCode,
          body: _response.error.rawBody
        });
      case "timeout":
        throw new RivetTimeoutError();
      case "unknown":
        throw new RivetError({
          message: _response.error.errorMessage
        });
    }
  }
  async _getAuthorizationHeader() {
    const bearer = await Supplier.get(this.options.token);
    if (bearer != null) {
      return `Bearer ${bearer}`;
    }
    return void 0;
  }
};

// src/api/resources/matchmaker/resources/lobbies/client/Client.ts
init_core();
var import_url_join27 = __toESM(require_url_join());
init_serialization();
var Lobbies = class {
  constructor(options) {
    this.options = options;
  }
  /**
   * Marks the current lobby as ready to accept connections.  Players will not be able to connect to this lobby until the  lobby is flagged as ready.
   * @throws {Rivet.InternalError}
   * @throws {Rivet.RateLimitError}
   * @throws {Rivet.ForbiddenError}
   * @throws {Rivet.UnauthorizedError}
   * @throws {Rivet.NotFoundError}
   * @throws {Rivet.BadRequestError}
   */
  async ready() {
    const _response = await fetcher({
      url: (0, import_url_join27.default)(
        this.options.environment ?? RivetEnvironment.Production,
        "/matchmaker/lobbies/ready"
      ),
      method: "POST",
      headers: {
        Authorization: await this._getAuthorizationHeader()
      },
      contentType: "application/json"
    });
    if (_response.ok) {
      return;
    }
    if (_response.error.reason === "status-code") {
      switch (_response.error.statusCode) {
        case 500:
          throw new api_exports.InternalError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 429:
          throw new api_exports.RateLimitError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 403:
          throw new api_exports.ForbiddenError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 408:
          throw new api_exports.UnauthorizedError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 404:
          throw new api_exports.NotFoundError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 400:
          throw new api_exports.BadRequestError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        default:
          throw new RivetError({
            statusCode: _response.error.statusCode,
            body: _response.error.body
          });
      }
    }
    switch (_response.error.reason) {
      case "non-json":
        throw new RivetError({
          statusCode: _response.error.statusCode,
          body: _response.error.rawBody
        });
      case "timeout":
        throw new RivetTimeoutError();
      case "unknown":
        throw new RivetError({
          message: _response.error.errorMessage
        });
    }
  }
  /**
   * If `is_closed` is `true`, the matchmaker will no longer route players to the lobby. Players can still
   * join using the /join endpoint (this can be disabled by the developer by rejecting all new connections
   * after setting the lobby to closed).
   * Does not shutdown the lobby.
   *
   * @throws {Rivet.InternalError}
   * @throws {Rivet.RateLimitError}
   * @throws {Rivet.ForbiddenError}
   * @throws {Rivet.UnauthorizedError}
   * @throws {Rivet.NotFoundError}
   * @throws {Rivet.BadRequestError}
   */
  async setClosed(request) {
    const _response = await fetcher({
      url: (0, import_url_join27.default)(
        this.options.environment ?? RivetEnvironment.Production,
        "/matchmaker/lobbies/closed"
      ),
      method: "PUT",
      headers: {
        Authorization: await this._getAuthorizationHeader()
      },
      contentType: "application/json",
      body: await matchmaker_exports6.SetLobbyClosedRequest.jsonOrThrow(request, {
        unrecognizedObjectKeys: "strip"
      })
    });
    if (_response.ok) {
      return;
    }
    if (_response.error.reason === "status-code") {
      switch (_response.error.statusCode) {
        case 500:
          throw new api_exports.InternalError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 429:
          throw new api_exports.RateLimitError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 403:
          throw new api_exports.ForbiddenError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 408:
          throw new api_exports.UnauthorizedError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 404:
          throw new api_exports.NotFoundError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 400:
          throw new api_exports.BadRequestError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        default:
          throw new RivetError({
            statusCode: _response.error.statusCode,
            body: _response.error.body
          });
      }
    }
    switch (_response.error.reason) {
      case "non-json":
        throw new RivetError({
          statusCode: _response.error.statusCode,
          body: _response.error.rawBody
        });
      case "timeout":
        throw new RivetTimeoutError();
      case "unknown":
        throw new RivetError({
          message: _response.error.errorMessage
        });
    }
  }
  /**
   * @throws {Rivet.InternalError}
   * @throws {Rivet.RateLimitError}
   * @throws {Rivet.ForbiddenError}
   * @throws {Rivet.UnauthorizedError}
   * @throws {Rivet.NotFoundError}
   * @throws {Rivet.BadRequestError}
   */
  async setState(request) {
    const _response = await fetcher({
      url: (0, import_url_join27.default)(
        this.options.environment ?? RivetEnvironment.Production,
        "/matchmaker/lobbies/state"
      ),
      method: "PUT",
      headers: {
        Authorization: await this._getAuthorizationHeader()
      },
      contentType: "application/json",
      body: await matchmaker_exports6.lobbies.setState.Request.jsonOrThrow(request, {
        unrecognizedObjectKeys: "strip"
      })
    });
    if (_response.ok) {
      return;
    }
    if (_response.error.reason === "status-code") {
      switch (_response.error.statusCode) {
        case 500:
          throw new api_exports.InternalError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 429:
          throw new api_exports.RateLimitError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 403:
          throw new api_exports.ForbiddenError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 408:
          throw new api_exports.UnauthorizedError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 404:
          throw new api_exports.NotFoundError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 400:
          throw new api_exports.BadRequestError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        default:
          throw new RivetError({
            statusCode: _response.error.statusCode,
            body: _response.error.body
          });
      }
    }
    switch (_response.error.reason) {
      case "non-json":
        throw new RivetError({
          statusCode: _response.error.statusCode,
          body: _response.error.rawBody
        });
      case "timeout":
        throw new RivetTimeoutError();
      case "unknown":
        throw new RivetError({
          message: _response.error.errorMessage
        });
    }
  }
  /**
   * @throws {Rivet.InternalError}
   * @throws {Rivet.RateLimitError}
   * @throws {Rivet.ForbiddenError}
   * @throws {Rivet.UnauthorizedError}
   * @throws {Rivet.NotFoundError}
   * @throws {Rivet.BadRequestError}
   */
  async getState(lobbyId) {
    const _response = await fetcher({
      url: (0, import_url_join27.default)(
        this.options.environment ?? RivetEnvironment.Production,
        `/matchmaker/lobbies/${lobbyId}/state`
      ),
      method: "GET",
      headers: {
        Authorization: await this._getAuthorizationHeader()
      },
      contentType: "application/json"
    });
    if (_response.ok) {
      return await matchmaker_exports6.lobbies.getState.Response.parseOrThrow(_response.body, {
        unrecognizedObjectKeys: "passthrough",
        allowUnrecognizedUnionMembers: true,
        allowUnrecognizedEnumValues: true
      });
    }
    if (_response.error.reason === "status-code") {
      switch (_response.error.statusCode) {
        case 500:
          throw new api_exports.InternalError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 429:
          throw new api_exports.RateLimitError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 403:
          throw new api_exports.ForbiddenError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 408:
          throw new api_exports.UnauthorizedError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 404:
          throw new api_exports.NotFoundError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 400:
          throw new api_exports.BadRequestError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        default:
          throw new RivetError({
            statusCode: _response.error.statusCode,
            body: _response.error.body
          });
      }
    }
    switch (_response.error.reason) {
      case "non-json":
        throw new RivetError({
          statusCode: _response.error.statusCode,
          body: _response.error.rawBody
        });
      case "timeout":
        throw new RivetTimeoutError();
      case "unknown":
        throw new RivetError({
          message: _response.error.errorMessage
        });
    }
  }
  /**
   * Finds a lobby based on the given criteria.
   * If a lobby is not found and `prevent_auto_create_lobby` is `true`,
   * a new lobby will be created.
   *
   * @throws {Rivet.InternalError}
   * @throws {Rivet.RateLimitError}
   * @throws {Rivet.ForbiddenError}
   * @throws {Rivet.UnauthorizedError}
   * @throws {Rivet.NotFoundError}
   * @throws {Rivet.BadRequestError}
   */
  async find(request) {
    const { origin, ..._body } = request;
    const _response = await fetcher({
      url: (0, import_url_join27.default)(
        this.options.environment ?? RivetEnvironment.Production,
        "/matchmaker/lobbies/find"
      ),
      method: "POST",
      headers: {
        Authorization: await this._getAuthorizationHeader(),
        origin
      },
      contentType: "application/json",
      body: await matchmaker_exports6.FindLobbyRequest.jsonOrThrow(_body, { unrecognizedObjectKeys: "strip" })
    });
    if (_response.ok) {
      return await matchmaker_exports6.FindLobbyResponse.parseOrThrow(_response.body, {
        unrecognizedObjectKeys: "passthrough",
        allowUnrecognizedUnionMembers: true,
        allowUnrecognizedEnumValues: true
      });
    }
    if (_response.error.reason === "status-code") {
      switch (_response.error.statusCode) {
        case 500:
          throw new api_exports.InternalError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 429:
          throw new api_exports.RateLimitError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 403:
          throw new api_exports.ForbiddenError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 408:
          throw new api_exports.UnauthorizedError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 404:
          throw new api_exports.NotFoundError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 400:
          throw new api_exports.BadRequestError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        default:
          throw new RivetError({
            statusCode: _response.error.statusCode,
            body: _response.error.body
          });
      }
    }
    switch (_response.error.reason) {
      case "non-json":
        throw new RivetError({
          statusCode: _response.error.statusCode,
          body: _response.error.rawBody
        });
      case "timeout":
        throw new RivetTimeoutError();
      case "unknown":
        throw new RivetError({
          message: _response.error.errorMessage
        });
    }
  }
  /**
   * Joins a specific lobby.
   * This request will use the direct player count configured for the
   * lobby group.
   *
   * @throws {Rivet.InternalError}
   * @throws {Rivet.RateLimitError}
   * @throws {Rivet.ForbiddenError}
   * @throws {Rivet.UnauthorizedError}
   * @throws {Rivet.NotFoundError}
   * @throws {Rivet.BadRequestError}
   */
  async join(request) {
    const _response = await fetcher({
      url: (0, import_url_join27.default)(
        this.options.environment ?? RivetEnvironment.Production,
        "/matchmaker/lobbies/join"
      ),
      method: "POST",
      headers: {
        Authorization: await this._getAuthorizationHeader()
      },
      contentType: "application/json",
      body: await matchmaker_exports6.JoinLobbyRequest.jsonOrThrow(request, {
        unrecognizedObjectKeys: "strip"
      })
    });
    if (_response.ok) {
      return await matchmaker_exports6.JoinLobbyResponse.parseOrThrow(_response.body, {
        unrecognizedObjectKeys: "passthrough",
        allowUnrecognizedUnionMembers: true,
        allowUnrecognizedEnumValues: true
      });
    }
    if (_response.error.reason === "status-code") {
      switch (_response.error.statusCode) {
        case 500:
          throw new api_exports.InternalError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 429:
          throw new api_exports.RateLimitError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 403:
          throw new api_exports.ForbiddenError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 408:
          throw new api_exports.UnauthorizedError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 404:
          throw new api_exports.NotFoundError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 400:
          throw new api_exports.BadRequestError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        default:
          throw new RivetError({
            statusCode: _response.error.statusCode,
            body: _response.error.body
          });
      }
    }
    switch (_response.error.reason) {
      case "non-json":
        throw new RivetError({
          statusCode: _response.error.statusCode,
          body: _response.error.rawBody
        });
      case "timeout":
        throw new RivetTimeoutError();
      case "unknown":
        throw new RivetError({
          message: _response.error.errorMessage
        });
    }
  }
  /**
   * Creates a custom lobby.
   *
   * @throws {Rivet.InternalError}
   * @throws {Rivet.RateLimitError}
   * @throws {Rivet.ForbiddenError}
   * @throws {Rivet.UnauthorizedError}
   * @throws {Rivet.NotFoundError}
   * @throws {Rivet.BadRequestError}
   */
  async create(request) {
    const _response = await fetcher({
      url: (0, import_url_join27.default)(
        this.options.environment ?? RivetEnvironment.Production,
        "/matchmaker/lobbies/create"
      ),
      method: "POST",
      headers: {
        Authorization: await this._getAuthorizationHeader()
      },
      contentType: "application/json",
      body: await matchmaker_exports6.CreateLobbyRequest.jsonOrThrow(request, {
        unrecognizedObjectKeys: "strip"
      })
    });
    if (_response.ok) {
      return await matchmaker_exports6.CreateLobbyResponse.parseOrThrow(_response.body, {
        unrecognizedObjectKeys: "passthrough",
        allowUnrecognizedUnionMembers: true,
        allowUnrecognizedEnumValues: true
      });
    }
    if (_response.error.reason === "status-code") {
      switch (_response.error.statusCode) {
        case 500:
          throw new api_exports.InternalError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 429:
          throw new api_exports.RateLimitError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 403:
          throw new api_exports.ForbiddenError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 408:
          throw new api_exports.UnauthorizedError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 404:
          throw new api_exports.NotFoundError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 400:
          throw new api_exports.BadRequestError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        default:
          throw new RivetError({
            statusCode: _response.error.statusCode,
            body: _response.error.body
          });
      }
    }
    switch (_response.error.reason) {
      case "non-json":
        throw new RivetError({
          statusCode: _response.error.statusCode,
          body: _response.error.rawBody
        });
      case "timeout":
        throw new RivetTimeoutError();
      case "unknown":
        throw new RivetError({
          message: _response.error.errorMessage
        });
    }
  }
  /**
   * Lists all open lobbies.
   * @throws {Rivet.InternalError}
   * @throws {Rivet.RateLimitError}
   * @throws {Rivet.ForbiddenError}
   * @throws {Rivet.UnauthorizedError}
   * @throws {Rivet.NotFoundError}
   * @throws {Rivet.BadRequestError}
   */
  async list(request = {}) {
    const { includeState } = request;
    const _queryParams = new URLSearchParams();
    if (includeState != null) {
      _queryParams.append("include_state", includeState.toString());
    }
    const _response = await fetcher({
      url: (0, import_url_join27.default)(
        this.options.environment ?? RivetEnvironment.Production,
        "/matchmaker/lobbies/list"
      ),
      method: "GET",
      headers: {
        Authorization: await this._getAuthorizationHeader()
      },
      contentType: "application/json",
      queryParameters: _queryParams
    });
    if (_response.ok) {
      return await matchmaker_exports6.ListLobbiesResponse.parseOrThrow(_response.body, {
        unrecognizedObjectKeys: "passthrough",
        allowUnrecognizedUnionMembers: true,
        allowUnrecognizedEnumValues: true
      });
    }
    if (_response.error.reason === "status-code") {
      switch (_response.error.statusCode) {
        case 500:
          throw new api_exports.InternalError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 429:
          throw new api_exports.RateLimitError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 403:
          throw new api_exports.ForbiddenError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 408:
          throw new api_exports.UnauthorizedError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 404:
          throw new api_exports.NotFoundError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 400:
          throw new api_exports.BadRequestError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        default:
          throw new RivetError({
            statusCode: _response.error.statusCode,
            body: _response.error.body
          });
      }
    }
    switch (_response.error.reason) {
      case "non-json":
        throw new RivetError({
          statusCode: _response.error.statusCode,
          body: _response.error.rawBody
        });
      case "timeout":
        throw new RivetTimeoutError();
      case "unknown":
        throw new RivetError({
          message: _response.error.errorMessage
        });
    }
  }
  async _getAuthorizationHeader() {
    const bearer = await Supplier.get(this.options.token);
    if (bearer != null) {
      return `Bearer ${bearer}`;
    }
    return void 0;
  }
};

// src/api/resources/matchmaker/resources/players/client/Client.ts
init_core();
var import_url_join28 = __toESM(require_url_join());
init_serialization();
var Players = class {
  constructor(options) {
    this.options = options;
  }
  /**
   * Validates the player token is valid and has not already been consumed then
   * marks the player as connected.
   * # Player Tokens and Reserved Slots
   * Player tokens reserve a spot in the lobby until they expire. This allows for
   * precise matchmaking up to exactly the lobby's player limit, which is
   * important for games with small lobbies and a high influx of players.
   * By calling this endpoint with the player token, the player's spot is marked
   * as connected and will not expire. If this endpoint is never called, the
   * player's token will expire and this spot will be filled by another player.
   * # Anti-Botting
   * Player tokens are only issued by caling `lobbies.join`, calling `lobbies.find`, or
   * from the `GlobalEventMatchmakerLobbyJoin` event.
   * These endpoints have anti-botting measures (i.e. enforcing max player
   * limits, captchas, and detecting bots), so valid player tokens provide some
   * confidence that the player is not a bot.
   * Therefore, it's important to make sure the token is valid by waiting for
   * this endpoint to return OK before allowing the connected socket to do
   * anything else. If this endpoint returns an error, the socket should be
   * disconnected immediately.
   * # How to Transmit the Player Token
   * The client is responsible for acquiring the player token by caling
   * `lobbies.join`, calling `lobbies.find`, or from the `GlobalEventMatchmakerLobbyJoin`
   * event.  Beyond that, it's up to the developer how the player token is
   * transmitted to the lobby.
   * If using WebSockets, the player token can be transmitted as a query
   * parameter.
   * Otherwise, the player token will likely be automatically sent by the client
   * once the socket opens. As mentioned above, nothing else should happen until
   * the player token is validated.
   *
   * @throws {Rivet.InternalError}
   * @throws {Rivet.RateLimitError}
   * @throws {Rivet.ForbiddenError}
   * @throws {Rivet.UnauthorizedError}
   * @throws {Rivet.NotFoundError}
   * @throws {Rivet.BadRequestError}
   */
  async connected(request) {
    const _response = await fetcher({
      url: (0, import_url_join28.default)(
        this.options.environment ?? RivetEnvironment.Production,
        "/matchmaker/players/connected"
      ),
      method: "POST",
      headers: {
        Authorization: await this._getAuthorizationHeader()
      },
      contentType: "application/json",
      body: await matchmaker_exports6.PlayerConnectedRequest.jsonOrThrow(request, {
        unrecognizedObjectKeys: "strip"
      })
    });
    if (_response.ok) {
      return;
    }
    if (_response.error.reason === "status-code") {
      switch (_response.error.statusCode) {
        case 500:
          throw new api_exports.InternalError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 429:
          throw new api_exports.RateLimitError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 403:
          throw new api_exports.ForbiddenError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 408:
          throw new api_exports.UnauthorizedError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 404:
          throw new api_exports.NotFoundError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 400:
          throw new api_exports.BadRequestError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        default:
          throw new RivetError({
            statusCode: _response.error.statusCode,
            body: _response.error.body
          });
      }
    }
    switch (_response.error.reason) {
      case "non-json":
        throw new RivetError({
          statusCode: _response.error.statusCode,
          body: _response.error.rawBody
        });
      case "timeout":
        throw new RivetTimeoutError();
      case "unknown":
        throw new RivetError({
          message: _response.error.errorMessage
        });
    }
  }
  /**
   * Marks a player as disconnected. # Ghost Players If players are not marked as disconnected, lobbies will result with "ghost players" that the matchmaker thinks exist but are no longer connected to the lobby.
   * @throws {Rivet.InternalError}
   * @throws {Rivet.RateLimitError}
   * @throws {Rivet.ForbiddenError}
   * @throws {Rivet.UnauthorizedError}
   * @throws {Rivet.NotFoundError}
   * @throws {Rivet.BadRequestError}
   */
  async disconnected(request) {
    const _response = await fetcher({
      url: (0, import_url_join28.default)(
        this.options.environment ?? RivetEnvironment.Production,
        "/matchmaker/players/disconnected"
      ),
      method: "POST",
      headers: {
        Authorization: await this._getAuthorizationHeader()
      },
      contentType: "application/json",
      body: await matchmaker_exports6.PlayerDisconnectedRequest.jsonOrThrow(request, {
        unrecognizedObjectKeys: "strip"
      })
    });
    if (_response.ok) {
      return;
    }
    if (_response.error.reason === "status-code") {
      switch (_response.error.statusCode) {
        case 500:
          throw new api_exports.InternalError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 429:
          throw new api_exports.RateLimitError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 403:
          throw new api_exports.ForbiddenError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 408:
          throw new api_exports.UnauthorizedError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 404:
          throw new api_exports.NotFoundError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 400:
          throw new api_exports.BadRequestError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        default:
          throw new RivetError({
            statusCode: _response.error.statusCode,
            body: _response.error.body
          });
      }
    }
    switch (_response.error.reason) {
      case "non-json":
        throw new RivetError({
          statusCode: _response.error.statusCode,
          body: _response.error.rawBody
        });
      case "timeout":
        throw new RivetTimeoutError();
      case "unknown":
        throw new RivetError({
          message: _response.error.errorMessage
        });
    }
  }
  /**
   * Gives matchmaker statistics about the players in game.
   * @throws {Rivet.InternalError}
   * @throws {Rivet.RateLimitError}
   * @throws {Rivet.ForbiddenError}
   * @throws {Rivet.UnauthorizedError}
   * @throws {Rivet.NotFoundError}
   * @throws {Rivet.BadRequestError}
   */
  async getStatistics() {
    const _response = await fetcher({
      url: (0, import_url_join28.default)(
        this.options.environment ?? RivetEnvironment.Production,
        "/matchmaker/players/statistics"
      ),
      method: "GET",
      headers: {
        Authorization: await this._getAuthorizationHeader()
      },
      contentType: "application/json"
    });
    if (_response.ok) {
      return await matchmaker_exports6.GetStatisticsResponse.parseOrThrow(_response.body, {
        unrecognizedObjectKeys: "passthrough",
        allowUnrecognizedUnionMembers: true,
        allowUnrecognizedEnumValues: true
      });
    }
    if (_response.error.reason === "status-code") {
      switch (_response.error.statusCode) {
        case 500:
          throw new api_exports.InternalError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 429:
          throw new api_exports.RateLimitError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 403:
          throw new api_exports.ForbiddenError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 408:
          throw new api_exports.UnauthorizedError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 404:
          throw new api_exports.NotFoundError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 400:
          throw new api_exports.BadRequestError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        default:
          throw new RivetError({
            statusCode: _response.error.statusCode,
            body: _response.error.body
          });
      }
    }
    switch (_response.error.reason) {
      case "non-json":
        throw new RivetError({
          statusCode: _response.error.statusCode,
          body: _response.error.rawBody
        });
      case "timeout":
        throw new RivetTimeoutError();
      case "unknown":
        throw new RivetError({
          message: _response.error.errorMessage
        });
    }
  }
  async _getAuthorizationHeader() {
    const bearer = await Supplier.get(this.options.token);
    if (bearer != null) {
      return `Bearer ${bearer}`;
    }
    return void 0;
  }
};

// src/api/resources/matchmaker/resources/regions/client/Client.ts
init_core();
var import_url_join29 = __toESM(require_url_join());
init_serialization();
var Regions = class {
  constructor(options) {
    this.options = options;
  }
  /**
   * Returns a list of regions available to this namespace.
   * Regions are sorted by most optimal to least optimal. The player's IP address
   * is used to calculate the regions' optimality.
   *
   * @throws {Rivet.InternalError}
   * @throws {Rivet.RateLimitError}
   * @throws {Rivet.ForbiddenError}
   * @throws {Rivet.UnauthorizedError}
   * @throws {Rivet.NotFoundError}
   * @throws {Rivet.BadRequestError}
   */
  async list() {
    const _response = await fetcher({
      url: (0, import_url_join29.default)(this.options.environment ?? RivetEnvironment.Production, "/matchmaker/regions"),
      method: "GET",
      headers: {
        Authorization: await this._getAuthorizationHeader()
      },
      contentType: "application/json"
    });
    if (_response.ok) {
      return await matchmaker_exports6.ListRegionsResponse.parseOrThrow(_response.body, {
        unrecognizedObjectKeys: "passthrough",
        allowUnrecognizedUnionMembers: true,
        allowUnrecognizedEnumValues: true
      });
    }
    if (_response.error.reason === "status-code") {
      switch (_response.error.statusCode) {
        case 500:
          throw new api_exports.InternalError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 429:
          throw new api_exports.RateLimitError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 403:
          throw new api_exports.ForbiddenError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 408:
          throw new api_exports.UnauthorizedError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 404:
          throw new api_exports.NotFoundError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        case 400:
          throw new api_exports.BadRequestError(
            await ErrorBody.parseOrThrow(_response.error.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true
            })
          );
        default:
          throw new RivetError({
            statusCode: _response.error.statusCode,
            body: _response.error.body
          });
      }
    }
    switch (_response.error.reason) {
      case "non-json":
        throw new RivetError({
          statusCode: _response.error.statusCode,
          body: _response.error.rawBody
        });
      case "timeout":
        throw new RivetTimeoutError();
      case "unknown":
        throw new RivetError({
          message: _response.error.errorMessage
        });
    }
  }
  async _getAuthorizationHeader() {
    const bearer = await Supplier.get(this.options.token);
    if (bearer != null) {
      return `Bearer ${bearer}`;
    }
    return void 0;
  }
};

// src/api/resources/matchmaker/client/Client.ts
var Matchmaker2 = class {
  constructor(options) {
    this.options = options;
  }
  _lobbies;
  get lobbies() {
    return this._lobbies ?? (this._lobbies = new Lobbies(this.options));
  }
  _players;
  get players() {
    return this._players ?? (this._players = new Players(this.options));
  }
  _regions;
  get regions() {
    return this._regions ?? (this._regions = new Regions(this.options));
  }
};

// src/Client.ts
var RivetClient = class {
  constructor(options) {
    this.options = options;
  }
  _admin;
  get admin() {
    return this._admin ?? (this._admin = new Admin(this.options));
  }
  _cloud;
  get cloud() {
    return this._cloud ?? (this._cloud = new Cloud(this.options));
  }
  _group;
  get group() {
    return this._group ?? (this._group = new Group2(this.options));
  }
  _identity;
  get identity() {
    return this._identity ?? (this._identity = new Identity(this.options));
  }
  _kv;
  get kv() {
    return this._kv ?? (this._kv = new Kv(this.options));
  }
  _module;
  get module() {
    return this._module ?? (this._module = new Module(this.options));
  }
  _matchmaker;
  get matchmaker() {
    return this._matchmaker ?? (this._matchmaker = new Matchmaker2(this.options));
  }
};
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  Rivet,
  RivetClient,
  RivetEnvironment,
  RivetError,
  RivetTimeoutError
});
/*! Bundled license information:

mime-db/index.js:
  (*!
   * mime-db
   * Copyright(c) 2014 Jonathan Ong
   * Copyright(c) 2015-2022 Douglas Christopher Wilson
   * MIT Licensed
   *)

mime-types/index.js:
  (*!
   * mime-types
   * Copyright(c) 2014 Jonathan Ong
   * Copyright(c) 2015 Douglas Christopher Wilson
   * MIT Licensed
   *)
*/
